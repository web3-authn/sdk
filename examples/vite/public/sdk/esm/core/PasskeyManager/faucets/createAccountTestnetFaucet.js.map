{"version":3,"file":"createAccountTestnetFaucet.js","names":["faucetError: any","error: any"],"sources":["../../../../../src/core/PasskeyManager/faucets/createAccountTestnetFaucet.ts"],"sourcesContent":["import { AccessKeyView } from '@near-js/types';\nimport { RegistrationSSEEvent } from '../../types/passkeyManager';\nimport { PasskeyManagerContext } from '..';\nimport { VRFChallenge } from '@/core/types/vrf-worker';\nimport { NearClient } from '@/core/NearClient';\nimport { AccountId } from '@/core/types/accountIds';\nimport { RegistrationPhase, RegistrationStatus } from '../../types/passkeyManager';\nimport type { AuthenticatorOptions } from '../../types/authenticatorOptions';\nimport { DEFAULT_AUTHENTICATOR_OPTIONS } from '../../types/authenticatorOptions';\n\n/**\n * Create NEAR account using testnet faucet service\n * This only works on testnet, for production use the relayer server\n * @deprecated Testnet only, use createAccountAndRegisterWithRelayServer instead for prod\n */\nexport async function createAccountTestnetFaucet(\n  nearAccountId: AccountId,\n  publicKey: string,\n  onEvent?: (event: RegistrationSSEEvent) => void,\n): Promise<{ success: boolean; message: string; error?: string }> {\n  try {\n    console.debug('Creating NEAR account via testnet faucet service');\n\n    onEvent?.({\n      step: 3,\n      phase: RegistrationPhase.STEP_3_ACCESS_KEY_ADDITION,\n      status: RegistrationStatus.PROGRESS,\n      message: 'Creating NEAR account via faucet service...'\n    });\n\n    // Call NEAR testnet faucet service to create account\n    const faucetResponse = await fetch('https://helper.nearprotocol.com/account', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        newAccountId: nearAccountId,\n        newAccountPublicKey: publicKey\n      })\n    });\n\n    if (!faucetResponse.ok) {\n      const errorData = await faucetResponse.json().catch(() => ({}));\n      throw new Error(`Faucet service error: ${faucetResponse.status} - ${errorData.message || 'Unknown error'}`);\n    }\n\n    const faucetResult = await faucetResponse.json();\n    console.debug('Faucet service response:', faucetResult);\n    console.debug('Faucet response status:', faucetResult.status);\n    console.debug('Faucet final_execution_status:', faucetResult.final_execution_status);\n\n    // Check if the transaction actually succeeded on-chain\n    if (faucetResult.status?.Failure) {\n      const failure = faucetResult.status.Failure;\n      console.error('Faucet transaction failed on-chain:', failure);\n\n      // Extract error details\n      let errorMessage = 'Transaction failed on-chain';\n      if (failure.ActionError?.kind) {\n        const errorKind = failure.ActionError.kind;\n        const contractId = nearAccountId.split('.').slice(1).join('.');\n        if (errorKind.CreateAccountNotAllowed) {\n          errorMessage = `\n            Account creation for ${errorKind.CreateAccountNotAllowed.account_id} not allowed.\n            Must be done through the ${contractId} account (via the relay server, not the testnet faucet).\n          `;\n        } else if (errorKind.AccountAlreadyExists) {\n          errorMessage = `Account ${errorKind.AccountAlreadyExists.account_id} already exists`;\n        } else {\n          errorMessage = `${Object.keys(errorKind)[0]}`;\n        }\n      }\n      throw new Error(errorMessage);\n    }\n\n    onEvent?.({\n      step: 3,\n      phase: RegistrationPhase.STEP_3_ACCESS_KEY_ADDITION,\n      status: RegistrationStatus.SUCCESS,\n      message: `NEAR account ${nearAccountId} created successfully via faucet`\n    } as RegistrationSSEEvent);\n\n    return {\n      success: true,\n      message: `Account ${nearAccountId} created successfully via faucet`\n    };\n\n  } catch (faucetError: any) {\n    console.error('Faucet service error:', faucetError);\n    onEvent?.({\n      step: 0,\n      phase: RegistrationPhase.REGISTRATION_ERROR,\n      status: RegistrationStatus.ERROR,\n      message: 'Account creation via faucet failed',\n      error: faucetError.message\n    } as RegistrationSSEEvent);\n\n    return {\n      success: false,\n      message: 'Faucet service failed, continuing with local registration',\n      error: faucetError.message\n    };\n  }\n}\n\n/**\n * Create account and register user using testnet faucet (sequential flow)\n * This is the traditional flow: create account -> verify access key -> register with contract\n * @deprecated Testnet only, use createAccountAndRegisterWithRelayServer instead for prod\n */\nexport async function createAccountAndRegisterWithTestnetFaucet(\n  context: PasskeyManagerContext,\n  nearAccountId: AccountId,\n  publicKey: string,\n  credential: PublicKeyCredential,\n  vrfChallenge: VRFChallenge,\n  deterministicVrfPublicKey: string,\n  authenticatorOptions?: AuthenticatorOptions,\n  onEvent?: (event: RegistrationSSEEvent) => void,\n): Promise<{\n  success: boolean;\n  transactionId?: string;\n  error?: string;\n  preSignedDeleteTransaction?: any;\n}> {\n  const { webAuthnManager, nearClient } = context;\n\n  try {\n    // Step 1: Create account using testnet faucet\n    const accountCreationResult = await createAccountTestnetFaucet(\n      nearAccountId,\n      publicKey,\n      onEvent\n    );\n\n    if (!accountCreationResult.success) {\n      throw new Error(accountCreationResult.error || 'Account creation failed');\n    }\n\n    // Step 2: Wait for access key to be available\n    const accessKeyInfo = await waitForAccessKey(\n      nearClient,\n      nearAccountId,\n      publicKey,\n      10, // max retries\n      1000 // 1 second delay\n    );\n\n    onEvent?.({\n      step: 4,\n      phase: RegistrationPhase.STEP_4_ACCOUNT_VERIFICATION,\n      status: RegistrationStatus.SUCCESS,\n      message: 'Account creation verified successfully'\n    });\n\n    // Step 3: Register with contract\n    const contractRegistrationResult = await webAuthnManager.signVerifyAndRegisterUser({\n      contractId: context.configs.contractId,\n      credential: credential,\n      vrfChallenge: vrfChallenge,\n      deterministicVrfPublicKey: deterministicVrfPublicKey,\n      nearAccountId: nearAccountId,\n      nearPublicKeyStr: publicKey,\n      nearClient: nearClient,\n      deviceNumber: 1, // First device gets device number 1 (1-indexed)\n      onEvent: (progress) => {\n        onEvent?.({\n          step: 6,\n          phase: RegistrationPhase.STEP_6_CONTRACT_REGISTRATION,\n          status: RegistrationStatus.PROGRESS,\n          message: `VRF registration: ${progress.message}`\n        });\n      },\n    });\n\n    if (!contractRegistrationResult.verified || !contractRegistrationResult.signedTransaction) {\n      throw new Error('Contract verification failed');\n    }\n\n    // Broadcast the signed transaction\n    onEvent?.({\n      step: 6,\n      phase: RegistrationPhase.STEP_6_CONTRACT_REGISTRATION,\n      status: RegistrationStatus.PROGRESS,\n      message: 'Broadcasting registration transaction...'\n    });\n\n    const transactionResult = await nearClient.sendTransaction(contractRegistrationResult.signedTransaction);\n    const transactionId = transactionResult?.transaction_outcome?.id;\n\n    onEvent?.({\n      step: 6,\n      phase: RegistrationPhase.STEP_6_CONTRACT_REGISTRATION,\n      status: RegistrationStatus.SUCCESS,\n      message: `VRF registration successful, transaction ID: ${transactionId}`\n    });\n\n    return {\n      success: true,\n      transactionId: transactionId,\n      preSignedDeleteTransaction: contractRegistrationResult.preSignedDeleteTransaction\n    };\n\n  } catch (error: any) {\n    console.error('Sequential registration failed:', error);\n\n    onEvent?.({\n      step: 0,\n      phase: RegistrationPhase.REGISTRATION_ERROR,\n      status: RegistrationStatus.ERROR,\n      message: `Registration failed: ${error.message}`,\n      error: error.message\n    });\n\n    return {\n      success: false,\n      error: error.message,\n      preSignedDeleteTransaction: null\n    };\n  }\n}\n\n/**\n * Wait for access key to be available with retry logic\n * Account creation via faucet may have propagation delays\n */\nasync function waitForAccessKey(\n  nearClient: NearClient,\n  nearAccountId: AccountId,\n  nearPublicKey: string,\n  maxRetries: number = 10,\n  delayMs: number = 1000\n): Promise<AccessKeyView> {\n  console.debug(`Waiting for access key to be available for ${nearAccountId}...`);\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      const accessKeyInfo = await nearClient.viewAccessKey(\n        nearAccountId,\n        nearPublicKey,\n      ) as AccessKeyView;\n\n      console.debug(`Access key found on attempt ${attempt}`);\n      return accessKeyInfo;\n    } catch (error: any) {\n      console.debug(`Access key not available yet (attempt ${attempt}/${maxRetries}):`, error.message);\n\n      if (attempt === maxRetries) {\n        console.error(`Access key still not available after ${maxRetries} attempts`);\n        throw new Error(`Access key not available after ${maxRetries * delayMs}ms. Account creation may have failed.`);\n      }\n\n      // Wait before next attempt with exponential backoff\n      const delay = delayMs * Math.pow(1.5, attempt - 1);\n      console.debug(`   Waiting ${delay}ms before retry...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n  throw new Error('Unexpected error in waitForAccessKey');\n}"],"mappings":";;;;;;;;AAeA,eAAsB,2BACpB,eACA,WACA,SACgE;AAChE,KAAI;AACF,UAAQ,MAAM;AAEd,YAAU;GACR,MAAM;GACN,OAAO,kBAAkB;GACzB,QAAQ,mBAAmB;GAC3B,SAAS;;EAIX,MAAM,iBAAiB,MAAM,MAAM,2CAA2C;GAC5E,QAAQ;GACR,SAAS,EACP,gBAAgB;GAElB,MAAM,KAAK,UAAU;IACnB,cAAc;IACd,qBAAqB;;;AAIzB,MAAI,CAAC,eAAe,IAAI;GACtB,MAAM,YAAY,MAAM,eAAe,OAAO,aAAa;AAC3D,SAAM,IAAI,MAAM,yBAAyB,eAAe,OAAO,KAAK,UAAU,WAAW;;EAG3F,MAAM,eAAe,MAAM,eAAe;AAC1C,UAAQ,MAAM,4BAA4B;AAC1C,UAAQ,MAAM,2BAA2B,aAAa;AACtD,UAAQ,MAAM,kCAAkC,aAAa;AAG7D,MAAI,aAAa,QAAQ,SAAS;GAChC,MAAM,UAAU,aAAa,OAAO;AACpC,WAAQ,MAAM,uCAAuC;GAGrD,IAAI,eAAe;AACnB,OAAI,QAAQ,aAAa,MAAM;IAC7B,MAAM,YAAY,QAAQ,YAAY;IACtC,MAAM,aAAa,cAAc,MAAM,KAAK,MAAM,GAAG,KAAK;AAC1D,QAAI,UAAU,wBACZ,gBAAe;mCACU,UAAU,wBAAwB,WAAW;uCACzC,WAAW;;aAE/B,UAAU,qBACnB,gBAAe,WAAW,UAAU,qBAAqB,WAAW;QAEpE,gBAAe,GAAG,OAAO,KAAK,WAAW;;AAG7C,SAAM,IAAI,MAAM;;AAGlB,YAAU;GACR,MAAM;GACN,OAAO,kBAAkB;GACzB,QAAQ,mBAAmB;GAC3B,SAAS,gBAAgB,cAAc;;AAGzC,SAAO;GACL,SAAS;GACT,SAAS,WAAW,cAAc;;UAG7BA,aAAkB;AACzB,UAAQ,MAAM,yBAAyB;AACvC,YAAU;GACR,MAAM;GACN,OAAO,kBAAkB;GACzB,QAAQ,mBAAmB;GAC3B,SAAS;GACT,OAAO,YAAY;;AAGrB,SAAO;GACL,SAAS;GACT,SAAS;GACT,OAAO,YAAY;;;;;;;;;AAUzB,eAAsB,0CACpB,SACA,eACA,WACA,YACA,cACA,2BACA,sBACA,SAMC;CACD,MAAM,EAAE,iBAAiB,eAAe;AAExC,KAAI;EAEF,MAAM,wBAAwB,MAAM,2BAClC,eACA,WACA;AAGF,MAAI,CAAC,sBAAsB,QACzB,OAAM,IAAI,MAAM,sBAAsB,SAAS;AAI3B,QAAM,iBAC1B,YACA,eACA,WACA,IACA;AAGF,YAAU;GACR,MAAM;GACN,OAAO,kBAAkB;GACzB,QAAQ,mBAAmB;GAC3B,SAAS;;EAIX,MAAM,6BAA6B,MAAM,gBAAgB,0BAA0B;GACjF,YAAY,QAAQ,QAAQ;GAChB;GACE;GACa;GACZ;GACf,kBAAkB;GACN;GACZ,cAAc;GACd,UAAU,aAAa;AACrB,cAAU;KACR,MAAM;KACN,OAAO,kBAAkB;KACzB,QAAQ,mBAAmB;KAC3B,SAAS,qBAAqB,SAAS;;;;AAK7C,MAAI,CAAC,2BAA2B,YAAY,CAAC,2BAA2B,kBACtE,OAAM,IAAI,MAAM;AAIlB,YAAU;GACR,MAAM;GACN,OAAO,kBAAkB;GACzB,QAAQ,mBAAmB;GAC3B,SAAS;;EAGX,MAAM,oBAAoB,MAAM,WAAW,gBAAgB,2BAA2B;EACtF,MAAM,gBAAgB,mBAAmB,qBAAqB;AAE9D,YAAU;GACR,MAAM;GACN,OAAO,kBAAkB;GACzB,QAAQ,mBAAmB;GAC3B,SAAS,gDAAgD;;AAG3D,SAAO;GACL,SAAS;GACM;GACf,4BAA4B,2BAA2B;;UAGlDC,OAAY;AACnB,UAAQ,MAAM,mCAAmC;AAEjD,YAAU;GACR,MAAM;GACN,OAAO,kBAAkB;GACzB,QAAQ,mBAAmB;GAC3B,SAAS,wBAAwB,MAAM;GACvC,OAAO,MAAM;;AAGf,SAAO;GACL,SAAS;GACT,OAAO,MAAM;GACb,4BAA4B;;;;;;;;AASlC,eAAe,iBACb,YACA,eACA,eACA,aAAqB,IACrB,UAAkB,KACM;AACxB,SAAQ,MAAM,8CAA8C,cAAc;AAC1E,MAAK,IAAI,UAAU,GAAG,WAAW,YAAY,UAC3C,KAAI;EACF,MAAM,gBAAgB,MAAM,WAAW,cACrC,eACA;AAGF,UAAQ,MAAM,+BAA+B;AAC7C,SAAO;UACAA,OAAY;AACnB,UAAQ,MAAM,yCAAyC,QAAQ,GAAG,WAAW,KAAK,MAAM;AAExF,MAAI,YAAY,YAAY;AAC1B,WAAQ,MAAM,wCAAwC,WAAW;AACjE,SAAM,IAAI,MAAM,kCAAkC,aAAa,QAAQ;;EAIzE,MAAM,QAAQ,UAAU,KAAK,IAAI,KAAK,UAAU;AAChD,UAAQ,MAAM,cAAc,MAAM;AAClC,QAAM,IAAI,SAAQ,YAAW,WAAW,SAAS;;AAGrD,OAAM,IAAI,MAAM"}