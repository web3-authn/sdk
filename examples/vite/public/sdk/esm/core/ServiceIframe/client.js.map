{"version":3,"file":"client.js","names":["full: ParentToChildEnvelope"],"sources":["../../../../src/core/ServiceIframe/client.ts"],"sourcesContent":["import {\n  type ParentToChildEnvelope,\n  type ChildToParentEnvelope,\n  type ServiceProtocolVersion,\n} from './messages';\nimport { sanitizeSdkBasePath, escapeHtmlAttribute } from './sanitization';\n\n// Simple, framework-agnostic service iframe client.\n\nexport interface ServiceIframeClientOptions {\n  walletOrigin?: string; // e.g., https://wallet.example.com (optional; empty => same-origin srcdoc)\n  servicePath?: string; // default '/service'\n  connectTimeoutMs?: number; // default 8000\n  requestTimeoutMs?: number; // default 20000\n  theme?: 'dark' | 'light';\n  // Optional config forwarded to wallet host\n  nearRpcUrl?: string;\n  nearNetwork?: 'testnet' | 'mainnet';\n  contractId?: string;\n  relayer?: { initialUseRelayer: boolean; accountId: string; url: string };\n  vrfWorkerConfigs?: Record<string, unknown>;\n  // SDK asset base path for embedded bundles when mounting same‑origin via srcdoc\n  // Must serve dist/esm under this base path. Defaults to '/sdk'.\n  sdkBasePath?: string;\n}\n\ntype Pending = {\n  resolve: (value: any) => void;\n  reject: (reason?: any) => void;\n  timer: number | undefined;\n};\n\nexport class ServiceIframeClient {\n  private opts: Required<ServiceIframeClientOptions>;\n  private iframeEl: HTMLIFrameElement | null = null;\n  private port: MessagePort | null = null;\n  private ready = false;\n  private pending = new Map<string, Pending>();\n  private reqCounter = 0;\n\n  constructor(options: ServiceIframeClientOptions) {\n    this.opts = {\n      connectTimeoutMs: 8000,\n      requestTimeoutMs: 20000,\n      servicePath: '/service',\n      sdkBasePath: '/sdk',\n      walletOrigin: '',\n      ...options,\n    } as Required<ServiceIframeClientOptions>;\n  }\n\n  async init(): Promise<void> {\n    if (this.ready) return;\n    this.mountHiddenIframe();\n    await this.handshake();\n    await this.post({\n      type: 'SET_CONFIG',\n      payload: {\n        theme: this.opts.theme,\n        nearRpcUrl: this.opts.nearRpcUrl,\n        nearNetwork: this.opts.nearNetwork,\n        contractId: this.opts.contractId,\n        relayer: this.opts.relayer,\n        vrfWorkerConfigs: this.opts.vrfWorkerConfigs,\n      }\n    });\n  }\n\n  isReady(): boolean { return this.ready; }\n\n  // ===== Public RPC helpers =====\n\n  async requestSign(payload: { nearAccountId: string; txSigningRequests: Array<{ receiverId: string; actions: unknown[] }>; options?: Record<string, unknown> }) {\n    return this.post({ type: 'REQUEST_SIGN', payload });\n  }\n\n  // Handler-aligned convenience method\n  async signTransactionsWithActions(payload: { nearAccountId: string; txSigningRequests: Array<{ receiverId: string; actions: unknown[] }>; rpcCall?: Record<string, unknown>; confirmationConfig?: Record<string, unknown>; options?: Record<string, unknown> }) {\n    return this.post({ type: 'REQUEST_signTransactionsWithActions', payload } as any);\n  }\n\n  async requestRegister(payload: { nearAccountId: string }) {\n    return this.post({ type: 'REQUEST_REGISTER', payload });\n  }\n\n  async getUser(nearAccountId: string) {\n    return this.post({ type: 'DB_GET_USER', payload: { nearAccountId } });\n  }\n\n  async getPreferences(nearAccountId: string) {\n    return this.post({ type: 'DB_GET_PREFERENCES', payload: { nearAccountId } });\n  }\n\n  async updatePreferences(nearAccountId: string, patch: Record<string, unknown>) {\n    return this.post({ type: 'DB_UPDATE_PREFERENCES', payload: { nearAccountId, patch } });\n  }\n\n  async getConfirmationConfig(nearAccountId: string) {\n    return this.post({ type: 'DB_GET_CONFIRMATION_CONFIG', payload: { nearAccountId } });\n  }\n\n  async getTheme(nearAccountId: string) {\n    return this.post({ type: 'DB_GET_THEME', payload: { nearAccountId } });\n  }\n\n  async setTheme(nearAccountId: string, theme: 'dark' | 'light') {\n    return this.post({ type: 'DB_SET_THEME', payload: { nearAccountId, theme } });\n  }\n\n  // ===== Internals =====\n\n  async signNep413Message(payload: { nearAccountId: string; message: string; recipient: string; state?: string }) {\n    return this.post({ type: 'REQUEST_signNep413Message', payload } as any);\n  }\n\n  async signVerifyAndRegisterUser(payload: {\n    contractId?: string;\n    credential: unknown;\n    vrfChallenge: unknown;\n    deterministicVrfPublicKey: string;\n    nearAccountId: string;\n    nearPublicKeyStr: string;\n    deviceNumber?: number;\n    authenticatorOptions?: Record<string, unknown>;\n  }) {\n    return this.post({ type: 'REQUEST_signVerifyAndRegisterUser', payload } as any);\n  }\n\n  async decryptPrivateKeyWithPrf(nearAccountId: string) {\n    return this.post({ type: 'REQUEST_decryptPrivateKeyWithPrf', payload: { nearAccountId } } as any);\n  }\n\n  async deriveNearKeypairAndEncrypt(payload: {\n    nearAccountId: string;\n    credential: unknown;\n    options?: {\n      vrfChallenge?: unknown;\n      deterministicVrfPublicKey?: string;\n      contractId?: string;\n      nonce?: string;\n      blockHash?: string;\n      authenticatorOptions?: Record<string, unknown>;\n    };\n  }) {\n    return this.post({ type: 'REQUEST_deriveNearKeypairAndEncrypt', payload } as any);\n  }\n\n  async recoverKeypairFromPasskey(payload: { authenticationCredential: unknown; accountIdHint?: string }) {\n    return this.post({ type: 'REQUEST_recoverKeypairFromPasskey', payload } as any);\n  }\n\n  async signTransactionWithKeyPair(payload: { nearPrivateKey: string; signerAccountId: string; receiverId: string; nonce: string; blockHash: string; actions: unknown[] }) {\n    return this.post({ type: 'REQUEST_signTransactionWithKeyPair', payload } as any);\n  }\n\n  private mountHiddenIframe(): void {\n    if (this.iframeEl) return;\n    const iframe = document.createElement('iframe');\n    iframe.style.position = 'fixed';\n    iframe.style.width = '0px';\n    iframe.style.height = '0px';\n    iframe.style.opacity = '0';\n    iframe.style.pointerEvents = 'none';\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.setAttribute('tabindex', '-1');\n    // Hidden service iframe does not perform WebAuthn; avoid exposing permissions.\n    // Keep same-origin for srcdoc so module imports and storage work as expected.\n    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');\n\n    if (this.opts.walletOrigin) {\n      // External (or explicit) origin provided: load service page by URL\n      const src = new URL(this.opts.servicePath, this.opts.walletOrigin).toString();\n      iframe.src = src;\n    } else {\n      // No external origin: mount same‑origin service via srcdoc and a module asset URL\n      // Resolve the embedded service host relative to this ESM module for zero‑config\n      let serviceHostUrl = '';\n      try {\n        serviceHostUrl = new URL('../../../embedded/service-host.js', import.meta.url).toString();\n      } catch {\n        // Fallback to sdkBasePath for non‑ESM environments\n        const sanitizedBasePath = sanitizeSdkBasePath(this.opts.sdkBasePath);\n        serviceHostUrl = `${sanitizedBasePath}/embedded/service-host.js`;\n      }\n      const escapedUrl = escapeHtmlAttribute(serviceHostUrl);\n      const html = `<!doctype html><html><head><meta charset=\"utf-8\"/><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/></head><body><script type=\"module\" src=\"${escapedUrl}\"></script></body></html>`;\n      iframe.srcdoc = html;\n    }\n    document.body.appendChild(iframe);\n    this.iframeEl = iframe;\n  }\n\n  private async handshake(): Promise<void> {\n    const { iframeEl } = this;\n    if (!iframeEl || !iframeEl.contentWindow) throw new Error('Service iframe not mounted');\n\n    // Create a dedicated MessageChannel and send one port to the iframe\n    const channel = new MessageChannel();\n    const port = channel.port1;\n    const childPort = channel.port2;\n\n    const cleanup = () => {\n      try { port.onmessage = null as any; } catch {}\n    };\n\n    const readyPromise = new Promise<void>((resolve, reject) => {\n      const timer = window.setTimeout(() => {\n        cleanup();\n        reject(new Error('Service iframe READY timeout'));\n      }, this.opts.connectTimeoutMs);\n\n      port.onmessage = (e: MessageEvent) => {\n        const data = e.data as ChildToParentEnvelope;\n        if (!data || typeof data !== 'object') return;\n        if (data.type === 'READY') {\n          window.clearTimeout(timer);\n          cleanup();\n          this.ready = true;\n          resolve();\n        }\n      };\n    });\n\n    // Kick off port adoption in child\n    const targetOrigin = this.opts.walletOrigin || '*';\n    iframeEl.contentWindow.postMessage({ type: 'CONNECT' }, targetOrigin, [childPort]);\n    this.port = port;\n    this.port.onmessage = (e) => this.onPortMessage(e);\n    this.port.start?.();\n    await readyPromise;\n  }\n\n  private onPortMessage(e: MessageEvent) {\n    const msg = e.data as ChildToParentEnvelope;\n    if (!msg || typeof msg !== 'object') return;\n\n    // Ready/Pong/Progress are fire-and-forget unless correlated\n    if (msg.type === 'PROGRESS') return;\n\n    const requestId = (msg as any).requestId as string | undefined;\n    if (!requestId) return;\n\n    const pending = this.pending.get(requestId);\n    if (!pending) return;\n    this.pending.delete(requestId);\n    if (pending.timer) window.clearTimeout(pending.timer);\n\n    if (msg.type === 'ERROR') {\n      const err = new Error((msg.payload as any)?.message || 'Service error');\n      (err as any).code = (msg.payload as any)?.code;\n      (err as any).details = (msg.payload as any)?.details;\n      pending.reject(err);\n      return;\n    }\n\n    pending.resolve(msg.payload);\n  }\n\n  private post<T = any>(envelope: Omit<ParentToChildEnvelope, 'requestId'>): Promise<T> {\n    if (!this.ready || !this.port) return Promise.reject(new Error('Service iframe not ready'));\n    const requestId = `${Date.now()}-${++this.reqCounter}`;\n    const full: ParentToChildEnvelope = { ...envelope, requestId } as any;\n\n    return new Promise<T>((resolve, reject) => {\n      const timer = window.setTimeout(() => {\n        this.pending.delete(requestId);\n        reject(new Error(`Service request timeout for ${envelope.type}`));\n      }, this.opts.requestTimeoutMs);\n\n      this.pending.set(requestId, { resolve, reject, timer });\n      try {\n        this.port!.postMessage(full);\n      } catch (err) {\n        this.pending.delete(requestId);\n        window.clearTimeout(timer);\n        reject(err);\n      }\n    });\n  }\n}\n"],"mappings":"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"}