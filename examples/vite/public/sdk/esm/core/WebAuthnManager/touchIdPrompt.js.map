{"version":3,"file":"touchIdPrompt.js","names":[],"sources":["../../../../src/core/WebAuthnManager/touchIdPrompt.ts"],"sourcesContent":["import { ClientAuthenticatorData } from '../IndexedDBManager';\nimport { base64Decode, base64UrlDecode } from '../../utils/encoders';\nimport { outputAs32Bytes, VRFChallenge } from '../types/vrf-worker';\n\nexport interface RegisterCredentialsArgs {\n  nearAccountId: string,    // NEAR account ID for PRF salts and keypair derivation (always base account)\n  challenge: VRFChallenge,\n  deviceNumber?: number, // Optional device number for device-specific user ID (0, 1, 2, etc.)\n}\n\nexport interface AuthenticateCredentialsArgs {\n  nearAccountId: string,\n  challenge: VRFChallenge,\n  authenticators: ClientAuthenticatorData[],\n}\n\n/**\n * Generate ChaCha20Poly1305 salt using account-specific HKDF for encryption key derivation\n * @param nearAccountId - NEAR account ID to scope the salt to\n * @returns 32-byte Uint8Array salt for ChaCha20Poly1305 key derivation\n */\nexport function generateChaCha20Salt(nearAccountId: string): Uint8Array {\n  const saltString = `chacha20-salt:${nearAccountId}`;\n  const salt = new Uint8Array(32);\n  const saltBytes = new TextEncoder().encode(saltString);\n  salt.set(saltBytes.slice(0, 32));\n  return salt;\n}\n\n/**\n * Generate Ed25519 salt using account-specific HKDF for signing key derivation\n * @param nearAccountId - NEAR account ID to scope the salt to\n * @returns 32-byte Uint8Array salt for Ed25519 key derivation\n */\nexport function generateEd25519Salt(nearAccountId: string): Uint8Array {\n  const saltString = `ed25519-salt:${nearAccountId}`;\n  const salt = new Uint8Array(32);\n  const saltBytes = new TextEncoder().encode(saltString);\n  salt.set(saltBytes.slice(0, 32));\n  return salt;\n}\n\n/**\n * TouchIdPrompt prompts for touchID,\n * creates credentials,\n * manages WebAuthn touchID prompts,\n * and generates credentials, and PRF Outputs\n */\nexport class TouchIdPrompt {\n\n  constructor() {}\n\n  /**\n   * Prompts for TouchID/biometric authentication and generates WebAuthn credentials with PRF output\n   * @param nearAccountId - NEAR account ID to authenticate\n   * @param challenge - VRF challenge bytes to use for WebAuthn authentication\n   * @param authenticators - List of stored authenticator data for the user\n   * @returns WebAuthn credential with PRF output (HKDF derivation done in WASM worker)\n   * ```ts\n   * const credential = await touchIdPrompt.getCredentials({\n   *   nearAccountId,\n   *   challenge,\n   *   authenticators,\n   * });\n   * ```\n   */\n  async getCredentials({\n    nearAccountId,\n    challenge,\n    authenticators\n  }: AuthenticateCredentialsArgs): Promise<PublicKeyCredential> {\n\n    const credential = await navigator.credentials.get({\n      publicKey: {\n        challenge: outputAs32Bytes(challenge),\n        rpId: window.location.hostname,\n        allowCredentials: authenticators.map(auth => ({\n          id: base64UrlDecode(auth.credentialId),\n          type: 'public-key' as const,\n          transports: auth.transports as AuthenticatorTransport[]\n        })),\n        userVerification: 'preferred' as UserVerificationRequirement,\n        timeout: 60000,\n        extensions: {\n          prf: {\n            eval: {\n              first: generateChaCha20Salt(nearAccountId),  // ChaCha20Poly1305 encryption keys\n              second: generateEd25519Salt(nearAccountId)   // Ed25519 signing keys\n            }\n          }\n        }\n      } as PublicKeyCredentialRequestOptions\n    }) as PublicKeyCredential;\n\n    if (!credential) {\n      throw new Error('WebAuthn authentication failed or was cancelled');\n    }\n    return credential;\n  }\n\n  /**\n   * Simplified authentication for account recovery\n   * Uses credential IDs from contract without needing full authenticator data\n   * @param nearAccountId - NEAR account ID to authenticate\n   * @param challenge - VRF challenge bytes\n   * @param credentialIds - Array of credential IDs from contract lookup\n   * @returns WebAuthn credential with PRF output\n   */\n  async getCredentialsForRecovery({ nearAccountId, challenge, credentialIds }: {\n    nearAccountId: string,\n    challenge: VRFChallenge,\n    credentialIds: string[]\n  }): Promise<PublicKeyCredential> {\n\n    const credential = await navigator.credentials.get({\n      publicKey: {\n        challenge: outputAs32Bytes(challenge),\n        rpId: window.location.hostname,\n        allowCredentials: credentialIds.map(credentialId => ({\n          id: base64UrlDecode(credentialId),\n          type: 'public-key' as const,\n          transports: ['internal', 'hybrid', 'usb', 'ble'] as AuthenticatorTransport[]\n          // Include all common transports\n        })),\n        userVerification: 'preferred' as UserVerificationRequirement,\n        timeout: 60000,\n        extensions: {\n          prf: {\n            eval: {\n              first: generateChaCha20Salt(nearAccountId),  // ChaCha20Poly1305 encryption keys\n              second: generateEd25519Salt(nearAccountId)   // Ed25519 signing keys\n            }\n          }\n        }\n      } as PublicKeyCredentialRequestOptions\n    }) as PublicKeyCredential;\n\n    if (!credential) {\n      throw new Error('WebAuthn authentication failed or was cancelled');\n    }\n    return credential;\n  }\n\n  /**\n   * Generate WebAuthn registration credentials for normal account registration\n   * @param nearAccountId - NEAR account ID (used for both WebAuthn user ID and PRF salts)\n   * @param challenge - Random challenge bytes for the registration ceremony\n   * @returns Credential with PRF output\n   */\n  async generateRegistrationCredentials({ nearAccountId, challenge }: {\n    nearAccountId: string,\n    challenge: VRFChallenge\n  }): Promise<PublicKeyCredential> {\n    return this.generateRegistrationCredentialsInternal({\n      nearAccountId: nearAccountId,\n      challenge\n    });\n  }\n\n  /**\n   * Generate WebAuthn registration credentials for device linking\n   * @param nearAccountId - NEAR account ID for PRF salts (always base account like alice.testnet)\n   * @param challenge - Random challenge bytes for the registration ceremony\n   * @param deviceNumber - Device number for device-specific user ID\n   * @returns Credential with PRF output\n   */\n  async generateRegistrationCredentialsForLinkDevice({\n    nearAccountId,\n    challenge,\n    deviceNumber\n  }: RegisterCredentialsArgs): Promise<PublicKeyCredential> {\n    return this.generateRegistrationCredentialsInternal({\n      nearAccountId,\n      challenge,\n      deviceNumber\n    });\n  }\n\n  /**\n   * Internal method for generating WebAuthn registration credentials with PRF output\n   * @param nearAccountId - NEAR account ID for PRF salts and keypair derivation (always base account)\n   * @param challenge - Random challenge bytes for the registration ceremony\n   * @param deviceNumber - Device number for device-specific user ID.\n   * @returns Credential with PRF output\n   */\n  private async generateRegistrationCredentialsInternal({\n    nearAccountId,\n    challenge,\n    deviceNumber\n  }: RegisterCredentialsArgs): Promise<PublicKeyCredential> {\n    const credential = await navigator.credentials.create({\n      publicKey: {\n        challenge: outputAs32Bytes(challenge),\n        rp: {\n          name: 'WebAuthn VRF Passkey',\n          id: window.location.hostname\n        },\n        user: {\n          // CRITICAL: user.id must be device-specific or\n          // Chrome passkey sync will overwrite credentials between devices\n          id: new TextEncoder().encode(generateDeviceSpecificUserId(nearAccountId, deviceNumber)),\n          name: generateDeviceSpecificUserId(nearAccountId, deviceNumber),\n          displayName: generateUserFriendlyDisplayName(nearAccountId, deviceNumber)\n        },\n        pubKeyCredParams: [\n          { alg: -7, type: 'public-key' }, // ES256\n          { alg: -257, type: 'public-key' } // RS256\n        ],\n        authenticatorSelection: {\n          residentKey: 'required',\n          userVerification: 'preferred'\n        },\n        timeout: 60000,\n        attestation: 'none',\n        extensions: {\n          prf: {\n            eval: {\n              // Always use NEAR account ID for PRF salts to ensure consistent keypair derivation across devices\n              first: generateChaCha20Salt(nearAccountId),  // ChaCha20Poly1305 encryption keys\n              second: generateEd25519Salt(nearAccountId)   // Ed25519 signing keys\n            }\n          }\n        }\n      } as PublicKeyCredentialCreationOptions\n    }) as PublicKeyCredential;\n\n    return credential;\n  }\n}\n\n/**\n * Generate device-specific user ID to prevent Chrome sync conflicts\n * Creates technical identifiers with full account context\n *\n * @param nearAccountId - The NEAR account ID (e.g., \"serp120.web3-authn-v5.testnet\")\n * @param deviceNumber - The device number (optional, undefined for device 1, 2 for device 2, etc.)\n * @returns Technical identifier:\n *   - Device 1: \"serp120.web3-authn.testnet\"\n *   - Device 2: \"serp120.web3-authn.testnet (2)\"\n *   - Device 3: \"serp120.web3-authn.testnet (3)\"\n */\nexport function generateDeviceSpecificUserId(nearAccountId: string, deviceNumber?: number): string {\n  // If no device number provided or device number is 1, this is the first device\n  if (deviceNumber === undefined || deviceNumber === 1) {\n    return nearAccountId;\n  }\n  // For additional devices, add device number in parentheses\n  return `${nearAccountId} (${deviceNumber})`;\n}\n\n/**\n * Generate user-friendly display name for passkey manager UI\n * Creates clean, intuitive names that users will see\n *\n * @param nearAccountId - The NEAR account ID (e.g., \"serp120.web3-authn-v5.testnet\")\n * @param deviceNumber - The device number (optional, undefined for device 1, 2 for device 2, etc.)\n * @returns User-friendly display name:\n *   - Device 1: \"serp120\"\n *   - Device 2: \"serp120 (device 2)\"\n *   - Device 3: \"serp120 (device 3)\"\n */\nfunction generateUserFriendlyDisplayName(nearAccountId: string, deviceNumber?: number): string {\n  // Extract the base username (everything before the first dot)\n  const baseUsername = nearAccountId.split('.')[0];\n  // If no device number provided or device number is 1, this is the first device\n  if (deviceNumber === undefined || deviceNumber === 1) {\n    return baseUsername;\n  }\n  // For additional devices, add device number with friendly label\n  return `${baseUsername} (device ${deviceNumber})`;\n}"],"mappings":";;;;;;;;;AAqBA,SAAgB,qBAAqB,eAAmC;CACtE,MAAM,aAAa,iBAAiB;CACpC,MAAM,OAAO,IAAI,WAAW;CAC5B,MAAM,YAAY,IAAI,cAAc,OAAO;AAC3C,MAAK,IAAI,UAAU,MAAM,GAAG;AAC5B,QAAO;;;;;;;AAQT,SAAgB,oBAAoB,eAAmC;CACrE,MAAM,aAAa,gBAAgB;CACnC,MAAM,OAAO,IAAI,WAAW;CAC5B,MAAM,YAAY,IAAI,cAAc,OAAO;AAC3C,MAAK,IAAI,UAAU,MAAM,GAAG;AAC5B,QAAO;;;;;;;;AAST,IAAa,gBAAb,MAA2B;CAEzB,cAAc;;;;;;;;;;;;;;;CAgBd,MAAM,eAAe,EACnB,eACA,WACA,kBAC4D;EAE5D,MAAM,aAAa,MAAM,UAAU,YAAY,IAAI,EACjD,WAAW;GACT,WAAW,gBAAgB;GAC3B,MAAM,OAAO,SAAS;GACtB,kBAAkB,eAAe,KAAI,UAAS;IAC5C,IAAI,gBAAgB,KAAK;IACzB,MAAM;IACN,YAAY,KAAK;;GAEnB,kBAAkB;GAClB,SAAS;GACT,YAAY,EACV,KAAK,EACH,MAAM;IACJ,OAAO,qBAAqB;IAC5B,QAAQ,oBAAoB;;;AAOtC,MAAI,CAAC,WACH,OAAM,IAAI,MAAM;AAElB,SAAO;;;;;;;;;;CAWT,MAAM,0BAA0B,EAAE,eAAe,WAAW,iBAI3B;EAE/B,MAAM,aAAa,MAAM,UAAU,YAAY,IAAI,EACjD,WAAW;GACT,WAAW,gBAAgB;GAC3B,MAAM,OAAO,SAAS;GACtB,kBAAkB,cAAc,KAAI,kBAAiB;IACnD,IAAI,gBAAgB;IACpB,MAAM;IACN,YAAY;KAAC;KAAY;KAAU;KAAO;;;GAG5C,kBAAkB;GAClB,SAAS;GACT,YAAY,EACV,KAAK,EACH,MAAM;IACJ,OAAO,qBAAqB;IAC5B,QAAQ,oBAAoB;;;AAOtC,MAAI,CAAC,WACH,OAAM,IAAI,MAAM;AAElB,SAAO;;;;;;;;CAST,MAAM,gCAAgC,EAAE,eAAe,aAGtB;AAC/B,SAAO,KAAK,wCAAwC;GACnC;GACf;;;;;;;;;;CAWJ,MAAM,6CAA6C,EACjD,eACA,WACA,gBACwD;AACxD,SAAO,KAAK,wCAAwC;GAClD;GACA;GACA;;;;;;;;;;CAWJ,MAAc,wCAAwC,EACpD,eACA,WACA,gBACwD;EACxD,MAAM,aAAa,MAAM,UAAU,YAAY,OAAO,EACpD,WAAW;GACT,WAAW,gBAAgB;GAC3B,IAAI;IACF,MAAM;IACN,IAAI,OAAO,SAAS;;GAEtB,MAAM;IAGJ,IAAI,IAAI,cAAc,OAAO,6BAA6B,eAAe;IACzE,MAAM,6BAA6B,eAAe;IAClD,aAAa,gCAAgC,eAAe;;GAE9D,kBAAkB,CAChB;IAAE,KAAK;IAAI,MAAM;MACjB;IAAE,KAAK;IAAM,MAAM;;GAErB,wBAAwB;IACtB,aAAa;IACb,kBAAkB;;GAEpB,SAAS;GACT,aAAa;GACb,YAAY,EACV,KAAK,EACH,MAAM;IAEJ,OAAO,qBAAqB;IAC5B,QAAQ,oBAAoB;;;AAOtC,SAAO;;;;;;;;;;;;;;AAeX,SAAgB,6BAA6B,eAAuB,cAA+B;AAEjG,KAAI,iBAAiB,UAAa,iBAAiB,EACjD,QAAO;AAGT,QAAO,GAAG,cAAc,IAAI,aAAa;;;;;;;;;;;;;AAc3C,SAAS,gCAAgC,eAAuB,cAA+B;CAE7F,MAAM,eAAe,cAAc,MAAM,KAAK;AAE9C,KAAI,iBAAiB,UAAa,iBAAiB,EACjD,QAAO;AAGT,QAAO,GAAG,aAAa,WAAW,aAAa"}