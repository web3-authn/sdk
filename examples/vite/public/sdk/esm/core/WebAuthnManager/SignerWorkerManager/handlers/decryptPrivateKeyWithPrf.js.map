{"version":3,"file":"decryptPrivateKeyWithPrf.js","names":["error: any"],"sources":["../../../../../../src/core/WebAuthnManager/SignerWorkerManager/handlers/decryptPrivateKeyWithPrf.ts"],"sourcesContent":["\nimport { ClientAuthenticatorData } from '../../../IndexedDBManager';\nimport { TouchIdPrompt } from \"../../touchIdPrompt\";\nimport {\n  WorkerRequestType,\n  isDecryptPrivateKeyWithPrfSuccess,\n} from '../../../types/signer-worker';\nimport { extractPrfFromCredential } from '../../credentialsHelpers';\nimport { AccountId, toAccountId } from \"../../../types/accountIds\";\n\nimport { SignerWorkerManagerContext } from '..';\nimport { base64UrlEncode } from '@/utils/encoders';\nimport { createRandomVRFChallenge, VRFChallenge } from '@/core/types/vrf-worker';\n\n\nexport async function decryptPrivateKeyWithPrf({\n  ctx,\n  nearAccountId,\n  authenticators,\n}: {\n  ctx: SignerWorkerManagerContext,\n  nearAccountId: AccountId,\n  authenticators: ClientAuthenticatorData[],\n}): Promise<{ decryptedPrivateKey: string; nearAccountId: AccountId }> {\n  try {\n    console.info('WebAuthnManager: Starting private key decryption with dual PRF (local operation)');\n    // Retrieve encrypted key data from IndexedDB in main thread\n    const encryptedKeyData = await ctx.indexedDB.nearKeysDB.getEncryptedKey(nearAccountId);\n    if (!encryptedKeyData) {\n      throw new Error(`No encrypted key found for account: ${nearAccountId}`);\n    }\n\n    // For private key export, no VRF challenge is needed.\n    // we can use local random challenge for WebAuthn authentication.\n    // Security comes from device possession + biometrics, not challenge validation\n    const challenge = createRandomVRFChallenge();\n    // TouchID prompt\n    const credential = await ctx.touchIdPrompt.getCredentials({\n      nearAccountId,\n      challenge: challenge as VRFChallenge,\n      authenticators,\n    });\n\n    // Extract dual PRF outputs and use the AES one for decryption\n    const dualPrfOutputs = extractPrfFromCredential({\n      credential,\n      firstPrfOutput: true,\n      secondPrfOutput: false,\n    });\n    console.debug('WebAuthnManager: Extracted ChaCha20 PRF output for decryption');\n\n    const response = await ctx.sendMessage({\n      message: {\n        type: WorkerRequestType.DecryptPrivateKeyWithPrf,\n        payload: {\n          nearAccountId: nearAccountId,\n          chacha20PrfOutput: dualPrfOutputs.chacha20PrfOutput, // Use ChaCha20 PRF output for decryption\n          encryptedPrivateKeyData: encryptedKeyData.encryptedData,\n          encryptedPrivateKeyIv: encryptedKeyData.iv\n        }\n      }\n    });\n\n    if (!isDecryptPrivateKeyWithPrfSuccess(response)) {\n      console.error('WebAuthnManager: Dual PRF private key decryption failed:', response);\n      throw new Error('Private key decryption failed');\n    }\n    return {\n      decryptedPrivateKey: response.payload.privateKey,\n      nearAccountId: toAccountId(response.payload.nearAccountId)\n    };\n  } catch (error: any) {\n    console.error('WebAuthnManager: Dual PRF private key decryption error:', error);\n    throw error;\n  }\n}"],"mappings":";;;;;;;AAeA,eAAsB,yBAAyB,EAC7C,KACA,eACA,kBAKqE;AACrE,KAAI;AACF,UAAQ,KAAK;EAEb,MAAM,mBAAmB,MAAM,IAAI,UAAU,WAAW,gBAAgB;AACxE,MAAI,CAAC,iBACH,OAAM,IAAI,MAAM,uCAAuC;EAMzD,MAAM,YAAY;EAElB,MAAM,aAAa,MAAM,IAAI,cAAc,eAAe;GACxD;GACW;GACX;;EAIF,MAAM,iBAAiB,yBAAyB;GAC9C;GACA,gBAAgB;GAChB,iBAAiB;;AAEnB,UAAQ,MAAM;EAEd,MAAM,WAAW,MAAM,IAAI,YAAY,EACrC,SAAS;GACP,MAAM,kBAAkB;GACxB,SAAS;IACQ;IACf,mBAAmB,eAAe;IAClC,yBAAyB,iBAAiB;IAC1C,uBAAuB,iBAAiB;;;AAK9C,MAAI,CAAC,kCAAkC,WAAW;AAChD,WAAQ,MAAM,4DAA4D;AAC1E,SAAM,IAAI,MAAM;;AAElB,SAAO;GACL,qBAAqB,SAAS,QAAQ;GACtC,eAAe,YAAY,SAAS,QAAQ;;UAEvCA,OAAY;AACnB,UAAQ,MAAM,2DAA2D;AACzE,QAAM"}