{"version":3,"file":"deriveNearKeypairAndEncrypt.js","names":["dualPrfOutputs: DualPrfOutputs","keyData: EncryptedKeyData","signedTransaction: SignedTransaction | undefined","error: any"],"sources":["../../../../../../src/core/WebAuthnManager/SignerWorkerManager/handlers/deriveNearKeypairAndEncrypt.ts"],"sourcesContent":["\nimport { SignedTransaction } from '../../../NearClient';\nimport type { EncryptedKeyData } from '../../../IndexedDBManager/passkeyNearKeysDB';\nimport type { AuthenticatorOptions } from '../../../types/authenticatorOptions';\nimport {\n  WorkerRequestType,\n  isDeriveNearKeypairAndEncryptSuccess,\n} from '../../../types/signer-worker';\nimport { toEnumUserVerificationPolicy } from '../../../types/authenticatorOptions';\nimport { serializeRegistrationCredentialWithPRF, type DualPrfOutputs } from '../../credentialsHelpers';\nimport { AccountId, toAccountId } from \"../../../types/accountIds\";\nimport { VRFChallenge } from '../../../types/vrf-worker';\nimport { SignerWorkerManagerContext } from '..';\n\n/**\n * Secure registration flow with dual PRF: WebAuthn + WASM worker encryption using dual PRF\n * Optionally signs a link_device_register_user transaction if VRF data is provided\n */\nexport async function deriveNearKeypairAndEncrypt({\n  ctx,\n  credential,\n  nearAccountId,\n  options,\n}: {\n  ctx: SignerWorkerManagerContext,\n  credential: PublicKeyCredential,\n  nearAccountId: AccountId,\n  options?: {\n    vrfChallenge: VRFChallenge;\n    deterministicVrfPublicKey: string; // Add VRF public key for registration transactions\n    contractId: string;\n    nonce: string;\n    blockHash: string;\n    authenticatorOptions?: AuthenticatorOptions; // Authenticator options for registration\n  }\n}): Promise<{\n  success: boolean;\n  nearAccountId: AccountId;\n  publicKey: string;\n  signedTransaction?: SignedTransaction;\n}> {\n  try {\n    console.info('WebAuthnManager: Starting secure registration with dual PRF using deterministic derivation');\n\n    const registrationCredential = serializeRegistrationCredentialWithPRF({\n      credential,\n      firstPrfOutput: true,\n      secondPrfOutput: true, // only for deriving NEAR keys\n    });\n\n    // Extract dual PRF outputs from credential (same as decryption phase)\n    if (!registrationCredential.clientExtensionResults?.prf?.results?.first) {\n      throw new Error('First PRF output missing from serialized credential');\n    }\n    if (!registrationCredential.clientExtensionResults?.prf?.results?.second) {\n      throw new Error('Second PRF output missing from serialized credential');\n    }\n\n    const dualPrfOutputs: DualPrfOutputs = {\n      chacha20PrfOutput: registrationCredential.clientExtensionResults.prf.results.first,\n      ed25519PrfOutput: registrationCredential.clientExtensionResults.prf.results.second,\n    };\n\n    // Use generic sendMessage with specific request type for better type safety\n    const response = await ctx.sendMessage<WorkerRequestType.DeriveNearKeypairAndEncrypt>({\n      message: {\n        type: WorkerRequestType.DeriveNearKeypairAndEncrypt,\n        payload: {\n          dualPrfOutputs: dualPrfOutputs,\n          nearAccountId: nearAccountId,\n          credential: registrationCredential,\n          // Optional device linking registration transaction\n          registrationTransaction: (options?.vrfChallenge && options?.contractId && options?.nonce && options?.blockHash) ? {\n            vrfChallenge: options.vrfChallenge,\n            contractId: options.contractId,\n            nonce: options.nonce,\n            blockHash: options.blockHash,\n            // Pass VRF public key to WASM worker (device number determined by contract)\n            deterministicVrfPublicKey: options.deterministicVrfPublicKey,\n          } : undefined,\n          authenticatorOptions: {\n            userVerification: toEnumUserVerificationPolicy(options?.authenticatorOptions?.userVerification),\n            originPolicy: options?.authenticatorOptions?.originPolicy,\n          }\n        }\n      }\n    });\n\n    // Response is specifically EncryptionSuccessResponse | EncryptionFailureResponse\n    if (!isDeriveNearKeypairAndEncryptSuccess(response)) {\n      throw new Error('Dual PRF registration failed');\n    }\n\n    // response.payload is a WasmEncryptionResult with proper WASM types\n    const wasmResult = response.payload;\n    // Store the encrypted key in IndexedDB using the manager\n    const keyData: EncryptedKeyData = {\n      nearAccountId: nearAccountId,\n      encryptedData: wasmResult.encryptedData,\n      iv: wasmResult.iv,\n      timestamp: Date.now()\n    };\n\n    await ctx.indexedDB.nearKeysDB.storeEncryptedKey(keyData);\n\n    // Verify storage\n    const verified = await ctx.indexedDB.nearKeysDB.verifyKeyStorage(nearAccountId);\n    if (!verified) {\n      throw new Error('Key storage verification failed');\n    }\n    console.info('WebAuthnManager: Encrypted key stored and verified in IndexedDB');\n\n    // Use WASM signed transaction directly - just map borshBytes to borsh_bytes\n    let signedTransaction: SignedTransaction | undefined = undefined;\n    if (wasmResult.signedTransaction) {\n      signedTransaction = new SignedTransaction({\n        transaction: wasmResult.signedTransaction.transaction,\n        signature: wasmResult.signedTransaction.signature,\n        borsh_bytes: Array.from(wasmResult.signedTransaction.borshBytes || [])\n      });\n    }\n\n    return {\n      success: true,\n      nearAccountId: toAccountId(wasmResult.nearAccountId),\n      publicKey: wasmResult.publicKey,\n      signedTransaction\n    };\n  } catch (error: any) {\n    console.error('WebAuthnManager: Dual PRF registration error:', error);\n    return {\n      success: false,\n      nearAccountId: nearAccountId,\n      publicKey: ''\n    };\n  }\n}\n"],"mappings":";;;;;;;;;;;;AAkBA,eAAsB,4BAA4B,EAChD,KACA,YACA,eACA,WAkBC;AACD,KAAI;AACF,UAAQ,KAAK;EAEb,MAAM,yBAAyB,uCAAuC;GACpE;GACA,gBAAgB;GAChB,iBAAiB;;AAInB,MAAI,CAAC,uBAAuB,wBAAwB,KAAK,SAAS,MAChE,OAAM,IAAI,MAAM;AAElB,MAAI,CAAC,uBAAuB,wBAAwB,KAAK,SAAS,OAChE,OAAM,IAAI,MAAM;EAGlB,MAAMA,iBAAiC;GACrC,mBAAmB,uBAAuB,uBAAuB,IAAI,QAAQ;GAC7E,kBAAkB,uBAAuB,uBAAuB,IAAI,QAAQ;;EAI9E,MAAM,WAAW,MAAM,IAAI,YAA2D,EACpF,SAAS;GACP,MAAM,kBAAkB;GACxB,SAAS;IACS;IACD;IACf,YAAY;IAEZ,yBAA0B,SAAS,gBAAgB,SAAS,cAAc,SAAS,SAAS,SAAS,YAAa;KAChH,cAAc,QAAQ;KACtB,YAAY,QAAQ;KACpB,OAAO,QAAQ;KACf,WAAW,QAAQ;KAEnB,2BAA2B,QAAQ;QACjC;IACJ,sBAAsB;KACpB,kBAAkB,6BAA6B,SAAS,sBAAsB;KAC9E,cAAc,SAAS,sBAAsB;;;;AAOrD,MAAI,CAAC,qCAAqC,UACxC,OAAM,IAAI,MAAM;EAIlB,MAAM,aAAa,SAAS;EAE5B,MAAMC,UAA4B;GACjB;GACf,eAAe,WAAW;GAC1B,IAAI,WAAW;GACf,WAAW,KAAK;;AAGlB,QAAM,IAAI,UAAU,WAAW,kBAAkB;EAGjD,MAAM,WAAW,MAAM,IAAI,UAAU,WAAW,iBAAiB;AACjE,MAAI,CAAC,SACH,OAAM,IAAI,MAAM;AAElB,UAAQ,KAAK;EAGb,IAAIC,oBAAmD;AACvD,MAAI,WAAW,kBACb,qBAAoB,IAAI,kBAAkB;GACxC,aAAa,WAAW,kBAAkB;GAC1C,WAAW,WAAW,kBAAkB;GACxC,aAAa,MAAM,KAAK,WAAW,kBAAkB,cAAc;;AAIvE,SAAO;GACL,SAAS;GACT,eAAe,YAAY,WAAW;GACtC,WAAW,WAAW;GACtB;;UAEKC,OAAY;AACnB,UAAQ,MAAM,iDAAiD;AAC/D,SAAO;GACL,SAAS;GACM;GACf,WAAW"}