{"version":3,"file":"index.js","names":["error: any","message: VRFWorkerMessage<WasmUnlockVrfKeypairRequest>","message: VRFWorkerMessage<WasmGenerateVrfChallengeRequest>","message: VRFWorkerMessage<WasmVrfWorkerRequestType>","message: VRFWorkerMessage<WasmGenerateVrfKeypairBootstrapRequest>","message: VRFWorkerMessage<WasmDeriveVrfKeypairFromPrfRequest>","result: {\n        vrfPublicKey: string;\n        vrfChallenge: VRFChallenge | null;\n        encryptedVrfKeypair: EncryptedVRFKeypair;\n        serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n      }","message: VRFWorkerMessage<WasmShamir3PassClientDecryptVrfKeypairRequest>"],"sources":["../../../../../src/core/WebAuthnManager/VrfWorkerManager/index.ts"],"sourcesContent":["/**\n * VRF Manager\n * Uses Web Workers for VRF keypair management with client-hosted worker files.\n */\n\nimport type {\n  VRFWorkerStatus,\n  VrfWorkerManagerConfig,\n  EncryptedVRFKeypair,\n  VRFInputData,\n  VRFWorkerMessage,\n  VRFWorkerResponse,\n  ServerEncryptedVrfKeypair,\n  WasmVrfWorkerRequestType,\n  WasmGenerateVrfChallengeRequest,\n  WasmGenerateVrfKeypairBootstrapRequest,\n  WasmShamir3PassConfigPRequest,\n  WasmShamir3PassConfigServerUrlsRequest,\n  WasmShamir3PassClientDecryptVrfKeypairRequest,\n  WasmUnlockVrfKeypairRequest,\n  WasmDeriveVrfKeypairFromPrfRequest,\n} from '../../types/vrf-worker';\nimport { VRFChallenge, validateVRFChallenge } from '../../types/vrf-worker';\nimport { BUILD_PATHS } from '../../../../build-paths.js';\nimport { AccountId, toAccountId } from '../../types/accountIds';\nimport { extractPrfFromCredential } from '../credentialsHelpers';\n\n/**\n * VRF Worker Manager\n *\n * This class manages VRF operations using Web Workers for:\n * - VRF keypair unlocking (login)\n * - VRF challenge generation (authentication)\n * - Session management (browser session only)\n * - Client-hosted worker files\n */\nexport class VrfWorkerManager {\n  private vrfWorker: Worker | null = null;\n  private initializationPromise: Promise<void> | null = null;\n  private messageId = 0;\n  private config: VrfWorkerManagerConfig;\n  private currentVrfAccountId: string | null = null;\n\n  constructor(config: VrfWorkerManagerConfig = {}) {\n    this.config = {\n      // Default to client-hosted worker file using centralized config\n      vrfWorkerUrl: BUILD_PATHS.RUNTIME.VRF_WORKER,\n      workerTimeout: 10000,\n      debug: false,\n      ...config\n    };\n  }\n\n  /**\n   * Ensure VRF worker is initialized and ready\n   */\n\n\n  /**\n   * Ensure VRF worker is ready for operations\n   * @param requireHealthCheck - Whether to perform health check after initialization\n   */\n  private async ensureWorkerReady(requireHealthCheck = false): Promise<void> {\n    if (this.initializationPromise) {\n      await this.initializationPromise;\n    } else if (!this.vrfWorker) {\n      await this.initialize();\n    }\n    if (!this.vrfWorker) {\n      throw new Error('VRF Worker failed to initialize');\n    }\n    // Optional health check for critical operations\n    if (requireHealthCheck) {\n      try {\n        const healthResponse = await this.sendMessage({\n          type: 'PING',\n          id: this.generateMessageId(),\n          payload: {} as WasmVrfWorkerRequestType\n        }, 3000);\n\n        if (!healthResponse.success) {\n          throw new Error('VRF Worker failed health check');\n        }\n      } catch (error) {\n        console.error('VRF Manager: Health check failed:', error);\n        throw new Error('VRF Worker failed health check');\n      }\n    }\n  }\n\n  /**\n   * Initialize VRF functionality using Web Workers\n   */\n  async initialize(): Promise<void> {\n    if (this.initializationPromise) {\n      return this.initializationPromise;\n    }\n    // =============================================================\n    // This improved error handling ensures that:\n    // 1. Initialization failures are properly logged with full details\n    // 2. Errors are re-thrown to callers (no silent swallowing)\n    // 3. Failed initialization promise is reset for retry\n    // 4. Debug logs actually appear in test output\n    this.initializationPromise = this.createVrfWorker().catch(error => {\n      console.error('VRF Manager: Initialization failed:', error);\n      console.error('VRF Manager: Error details:', {\n        message: error.message,\n        stack: error.stack,\n        name: error.name\n      });\n      // Reset promise so initialization can be retried\n      this.initializationPromise = null;\n      throw error; // Re-throw so callers know it failed\n    });\n\n    const result = await this.initializationPromise;\n    return result;\n  }\n\n  /**\n   * Initialize Web Worker with client-hosted VRF worker\n   */\n  private async createVrfWorker(): Promise<void> {\n    try {\n      console.debug('VRF Manager: Worker URL:', this.config.vrfWorkerUrl);\n      // Create Web Worker from client-hosted file\n      this.vrfWorker = new Worker(this.config.vrfWorkerUrl!, {\n        type: 'module',\n        name: 'Web3AuthnVRFWorker'\n      });\n      // Set up error handling\n      this.vrfWorker.onerror = (error) => {\n        console.error('VRF Manager: Web Worker error:', error);\n      };\n      // Test communication with the Web Worker\n      await this.testWebWorkerCommunication();\n\n      // Configure Shamir P if provided\n      if (this.config.shamirPB64u) {\n        const resp = await this.sendMessage<WasmShamir3PassConfigPRequest>({\n          type: 'SHAMIR3PASS_CONFIG_P',\n          id: this.generateMessageId(),\n          payload: { p_b64u: this.config.shamirPB64u }\n        });\n        if (!resp.success) {\n          throw new Error(`Failed to configure Shamir P: ${resp.error}`);\n        }\n      }\n\n      // Configure relay server URLs if provided\n      if (this.config.relayServerUrl && this.config.applyServerLockRoute && this.config.removeServerLockRoute) {\n        const resp2 = await this.sendMessage<WasmShamir3PassConfigServerUrlsRequest>({\n          type: 'SHAMIR3PASS_CONFIG_SERVER_URLS',\n          id: this.generateMessageId(),\n          payload: {\n            relayServerUrl: this.config.relayServerUrl,\n            applyLockRoute: this.config.applyServerLockRoute,\n            removeLockRoute: this.config.removeServerLockRoute,\n          }\n        });\n        if (!resp2.success) {\n          throw new Error(`Failed to configure Shamir server URLs: ${resp2.error}`);\n        }\n      }\n\n    } catch (error: any) {\n      throw new Error(`VRF Web Worker initialization failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Send message to Web Worker and wait for response\n   */\n  private async sendMessage<T extends WasmVrfWorkerRequestType>(\n    message: VRFWorkerMessage<T>,\n    customTimeout?: number\n  ): Promise<VRFWorkerResponse> {\n    return new Promise((resolve, reject) => {\n      if (!this.vrfWorker) {\n        reject(new Error('VRF Web Worker not available'));\n        return;\n      }\n\n      const timeoutMs = customTimeout || 30000;\n      const timeout = setTimeout(() => {\n        reject(new Error(`VRF Web Worker communication timeout (${timeoutMs}ms) for message type: ${message.type}`));\n      }, timeoutMs);\n\n      const handleMessage = (event: MessageEvent) => {\n        const response = event.data as VRFWorkerResponse;\n        if (response.id === message.id) {\n          clearTimeout(timeout);\n          this.vrfWorker!.removeEventListener('message', handleMessage);\n          resolve(response);\n        }\n      };\n\n      this.vrfWorker.addEventListener('message', handleMessage);\n      this.vrfWorker.postMessage(message);\n    });\n  }\n\n  /**\n   * Generate unique message ID\n   */\n  private generateMessageId(): string {\n    return `vrf_${Date.now()}_${++this.messageId}`;\n  }\n\n  /**\n   * Unlock VRF keypair in Web Worker memory using PRF output\n   * This is called during login to decrypt and load the VRF keypair in-memory\n   */\n  async unlockVrfKeypair({\n    credential,\n    nearAccountId,\n    encryptedVrfKeypair,\n    onEvent,\n  }: {\n    credential: PublicKeyCredential,\n    nearAccountId: AccountId,\n    encryptedVrfKeypair: EncryptedVRFKeypair,\n    onEvent?: (event: { type: string, data: { step: string, message: string } }) => void,\n  }): Promise<VRFWorkerResponse> {\n    await this.ensureWorkerReady(true);\n\n    const { chacha20PrfOutput } = extractPrfFromCredential({\n      credential,\n      firstPrfOutput: true,\n      secondPrfOutput: false,\n    });\n\n    if (!chacha20PrfOutput) {\n      throw new Error('ChaCha20 PRF output not found in WebAuthn credentials');\n    }\n\n    onEvent?.({\n      type: 'loginProgress',\n      data: {\n        step: 'verifying-server',\n        message: 'TouchId success! Unlocking VRF keypair...'\n      }\n    });\n\n    const message: VRFWorkerMessage<WasmUnlockVrfKeypairRequest> = {\n      type: 'UNLOCK_VRF_KEYPAIR',\n      id: this.generateMessageId(),\n      payload: {\n        nearAccountId,\n        encryptedVrfKeypair: encryptedVrfKeypair,\n        prfKey: chacha20PrfOutput // already a base64url string\n      }\n    };\n\n    const response = await this.sendMessage(message);\n    if (response.success) {\n      // Track the current VRF session account at TypeScript level\n      this.currentVrfAccountId = nearAccountId;\n      console.debug(`VRF Manager: VRF keypair unlocked for ${nearAccountId}`);\n    } else {\n      console.error('VRF Manager: Failed to unlock VRF keypair:', response.error);\n      console.error('VRF Manager: Full response:', JSON.stringify(response, null, 2));\n      console.error('VRF Manager: Message that was sent:', JSON.stringify(message, null, 2));\n    }\n\n    return response;\n  }\n\n  /**\n   * Generate VRF challenge using in-memory VRF keypair\n   * This is called during authentication to create WebAuthn challenges\n   */\n  async generateVrfChallenge(inputData: VRFInputData): Promise<VRFChallenge> {\n    await this.ensureWorkerReady(true);\n    const message: VRFWorkerMessage<WasmGenerateVrfChallengeRequest> = {\n      type: 'GENERATE_VRF_CHALLENGE',\n      id: this.generateMessageId(),\n      payload: {\n        vrfInputData: {\n          userId: inputData.userId,\n          rpId: inputData.rpId,\n          blockHeight: String(inputData.blockHeight),\n          blockHash: inputData.blockHash,\n        }\n      }\n    };\n\n    const response = await this.sendMessage(message);\n\n    if (!response.success || !response.data) {\n      throw new Error(`VRF challenge generation failed: ${response.error}`);\n    }\n\n    console.debug('VRF Manager: VRF challenge generated successfully');\n    return validateVRFChallenge(response.data);\n  }\n\n  /**\n   * Get current VRF session status\n   */\n  async checkVrfStatus(): Promise<VRFWorkerStatus> {\n    try {\n      await this.ensureWorkerReady();\n    } catch (error) {\n      // If initialization fails, return inactive status\n      return { active: false, nearAccountId: null };\n    }\n\n    try {\n      const message: VRFWorkerMessage<WasmVrfWorkerRequestType> = {\n        type: 'CHECK_VRF_STATUS',\n        id: this.generateMessageId(),\n        payload: {} as WasmVrfWorkerRequestType\n      };\n\n      const response = await this.sendMessage(message);\n\n      if (response.success && response.data) {\n        return {\n          active: response.data.active,\n          nearAccountId: this.currentVrfAccountId ? toAccountId(this.currentVrfAccountId) : null,\n          sessionDuration: response.data.sessionDuration\n        };\n      }\n\n      return { active: false, nearAccountId: null };\n    } catch (error) {\n      console.warn('VRF Manager: Failed to get VRF status:', error);\n      return { active: false, nearAccountId: null };\n    }\n  }\n\n  /**\n   * Logout and clear VRF session\n   */\n  async clearVrfSession(): Promise<void> {\n    console.debug('VRF Manager: Logging out...');\n\n    await this.ensureWorkerReady();\n\n    try {\n      const message: VRFWorkerMessage<WasmVrfWorkerRequestType> = {\n        type: 'LOGOUT',\n        id: this.generateMessageId(),\n        payload: {} as WasmVrfWorkerRequestType\n      };\n\n      const response = await this.sendMessage(message);\n\n      if (response.success) {\n        // Clear the TypeScript-tracked account ID\n        this.currentVrfAccountId = null;\n        console.debug('VRF Manager: Logged out: VRF keypair securely zeroized');\n      } else {\n        console.warn('️VRF Manager: Logout failed:', response.error);\n      }\n    } catch (error) {\n      console.warn('VRF Manager: Logout error:', error);\n    }\n  }\n\n  /**\n   * Generate VRF keypair for bootstrapping - stores in memory unencrypted temporarily\n   * This is used during registration to generate a VRF keypair that will be used for\n   * WebAuthn ceremony and later encrypted with the real PRF output\n   *\n   * @param saveInMemory - Always true for bootstrap (VRF keypair stored in memory)\n   * @param vrfInputParams - Optional parameters to generate VRF challenge/proof in same call\n   * @returns VRF public key and optionally VRF challenge data\n   */\n  async generateVrfKeypairBootstrap(\n    vrfInputData: VRFInputData,\n    saveInMemory: boolean,\n  ): Promise<{\n    vrfPublicKey: string;\n    vrfChallenge: VRFChallenge;\n  }> {\n    await this.ensureWorkerReady();\n    try {\n      const message: VRFWorkerMessage<WasmGenerateVrfKeypairBootstrapRequest> = {\n        type: 'GENERATE_VRF_KEYPAIR_BOOTSTRAP',\n        id: this.generateMessageId(),\n        payload: {\n          // Include VRF input data if provided for challenge generation\n          vrfInputData: vrfInputData ? {\n            userId: vrfInputData.userId,\n            rpId: vrfInputData.rpId,\n            blockHeight: String(vrfInputData.blockHeight),\n            blockHash: vrfInputData.blockHash,\n          } : undefined\n        }\n      };\n\n      const response = await this.sendMessage(message);\n\n      if (!response.success || !response.data) {\n        throw new Error(`VRF bootstrap keypair generation failed: ${response.error}`);\n      }\n      // If VRF challenge data was also generated, include it in the result\n      if (!response?.data?.vrf_challenge_data) {\n        throw new Error('VRF challenge data failed to be generated');\n      }\n      if (vrfInputData && saveInMemory) {\n        // Track the account ID for this VRF session if saving in memory\n        this.currentVrfAccountId = vrfInputData.userId;\n      }\n\n      // TODO: strong types generated by Rust wasm-bindgen\n      return {\n        vrfPublicKey: response.data.vrfPublicKey,\n        vrfChallenge: validateVRFChallenge({\n          vrfInput: response.data.vrf_challenge_data.vrfInput,\n          vrfOutput: response.data.vrf_challenge_data.vrfOutput,\n          vrfProof: response.data.vrf_challenge_data.vrfProof,\n          vrfPublicKey: response.data.vrf_challenge_data.vrfPublicKey,\n          userId: response.data.vrf_challenge_data.userId,\n          rpId: response.data.vrf_challenge_data.rpId,\n          blockHeight: response.data.vrf_challenge_data.blockHeight,\n          blockHash: response.data.vrf_challenge_data.blockHash,\n        })\n      }\n\n    } catch (error: any) {\n      console.error('VRF Manager: Bootstrap VRF keypair generation failed:', error);\n      throw new Error(`Failed to generate bootstrap VRF keypair: ${error.message}`);\n    }\n  }\n\n  /**\n   * Derive deterministic VRF keypair from PRF output for account recovery\n   * Optionally generates VRF challenge if input parameters are provided\n   * This enables deterministic VRF key derivation without needing stored VRF keypairs\n   *\n   * @param prfOutput - Base64url-encoded PRF output from WebAuthn credential (PRF Output 1)\n   * @param nearAccountId - NEAR account ID for key derivation salt\n   * @param vrfInputParams - Optional VRF input parameters for challenge generation\n   * @returns Deterministic VRF public key, optional VRF challenge, and encrypted VRF keypair for storage\n   */\n  async deriveVrfKeypairFromPrf({\n    credential,\n    nearAccountId,\n    vrfInputData,\n    saveInMemory = true,\n  }: {\n    credential: PublicKeyCredential;\n    nearAccountId: AccountId;\n    vrfInputData?: VRFInputData; // optional, for challenge generation\n    saveInMemory?: boolean; // optional, whether to save in worker memory\n  }): Promise<{\n    vrfPublicKey: string;\n    vrfChallenge: VRFChallenge | null;\n    encryptedVrfKeypair: EncryptedVRFKeypair;\n    serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n  }> {\n    console.debug('VRF Manager: Deriving deterministic VRF keypair from PRF output');\n    try {\n      await this.ensureWorkerReady();\n\n      // Extract ChaCha20 PRF output from credential\n      // This ensures deterministic derivation: same PRF + same account = same VRF keypair\n      const { chacha20PrfOutput } = extractPrfFromCredential({\n        credential,\n        firstPrfOutput: true,\n        secondPrfOutput: false,\n      });\n\n      // optional VRF Input data, only needed if generating VRF challenge simultaneously\n      const hasVrfInputData = vrfInputData?.blockHash\n        && vrfInputData?.blockHeight\n        && vrfInputData?.userId\n        && vrfInputData?.rpId;\n\n\n      const message: VRFWorkerMessage<WasmDeriveVrfKeypairFromPrfRequest> = {\n        type: 'DERIVE_VRF_KEYPAIR_FROM_PRF',\n        id: this.generateMessageId(),\n        payload: {\n          prfOutput: chacha20PrfOutput,\n          nearAccountId: nearAccountId,\n          saveInMemory: saveInMemory,\n          // Add VRF input parameters if provided for challenge generation\n          vrfInputData: hasVrfInputData ? {\n            userId: vrfInputData.userId,\n            rpId: vrfInputData.rpId,\n            blockHeight: String(vrfInputData.blockHeight),\n            blockHash: vrfInputData.blockHash,\n          } : undefined,\n        }\n      };\n\n      const response = await this.sendMessage(message);\n\n      if (!response.success || !response.data) {\n        throw new Error(`VRF keypair derivation failed: ${response.error}`);\n      }\n      if (!response.data.vrfPublicKey) {\n        throw new Error('VRF public key not found in response');\n      }\n      if (!response.data.encryptedVrfKeypair) {\n        throw new Error('Encrypted VRF keypair not found in response - this is required for registration');\n      }\n      console.debug('VRF Manager: Deterministic VRF keypair derivation successful');\n\n      // VRF challenge data is optional - only generated if vrfInputData was provided\n      const vrfChallenge = response.data.vrfChallengeData\n        ? validateVRFChallenge({\n            vrfInput: response.data.vrfChallengeData.vrfInput,\n            vrfOutput: response.data.vrfChallengeData.vrfOutput,\n            vrfProof: response.data.vrfChallengeData.vrfProof,\n            vrfPublicKey: response.data.vrfChallengeData.vrfPublicKey,\n            userId: response.data.vrfChallengeData.userId,\n            rpId: response.data.vrfChallengeData.rpId,\n            blockHeight: response.data.vrfChallengeData.blockHeight,\n            blockHash: response.data.vrfChallengeData.blockHash,\n          })\n        : null;\n\n      const result: {\n        vrfPublicKey: string;\n        vrfChallenge: VRFChallenge | null;\n        encryptedVrfKeypair: EncryptedVRFKeypair;\n        serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n      } = {\n        vrfPublicKey: response.data.vrfPublicKey,\n        vrfChallenge,\n        encryptedVrfKeypair: response.data.encryptedVrfKeypair,\n        serverEncryptedVrfKeypair: response.data.serverEncryptedVrfKeypair,\n      };\n\n      return result;\n\n    } catch (error: any) {\n      console.error('VRF Manager: VRF keypair derivation failed:', error);\n      throw new Error(`VRF keypair derivation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * This securely decrypts the shamir3Pass encrypted VRF keypair and loads it into memory\n   * It performs Shamir-3-Pass commutative decryption within WASM worker with the relay-server\n   */\n  async shamir3PassDecryptVrfKeypair({\n    nearAccountId,\n    kek_s_b64u,\n    ciphertextVrfB64u,\n  }: {\n    nearAccountId: AccountId;\n    kek_s_b64u: string;\n    ciphertextVrfB64u: string;\n  }): Promise<VRFWorkerResponse> {\n    await this.ensureWorkerReady(true);\n    const message: VRFWorkerMessage<WasmShamir3PassClientDecryptVrfKeypairRequest> = {\n      type: 'SHAMIR3PASS_CLIENT_DECRYPT_VRF_KEYPAIR',\n      id: this.generateMessageId(),\n      payload: {\n        nearAccountId,\n        kek_s_b64u,\n        ciphertextVrfB64u,\n      },\n    };\n    const response = await this.sendMessage(message);\n    if (response.success) {\n      this.currentVrfAccountId = nearAccountId;\n    }\n    return response;\n  }\n\n  /**\n   * Test Web Worker communication\n   */\n  private async testWebWorkerCommunication(): Promise<void> {\n    try {\n      const timeoutMs = 2000;\n      const pingResponse = await this.sendMessage({\n        type: 'PING',\n        id: this.generateMessageId(),\n        payload: {} as WasmVrfWorkerRequestType\n      }, timeoutMs);\n      if (!pingResponse.success) {\n        throw new Error(`VRF Web Worker PING failed: ${pingResponse.error}`);\n      }\n      return;\n    } catch (error: any) {\n      console.warn(`️VRF Manager: testWebWorkerCommunication failed:`, error.message);\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;AAoCA,IAAa,mBAAb,MAA8B;CAC5B,AAAQ,YAA2B;CACnC,AAAQ,wBAA8C;CACtD,AAAQ,YAAY;CACpB,AAAQ;CACR,AAAQ,sBAAqC;CAE7C,YAAY,SAAiC,IAAI;AAC/C,OAAK,SAAS;GAEZ,cAAc,YAAY,QAAQ;GAClC,eAAe;GACf,OAAO;GACP,GAAG;;;;;;;;;;CAaP,MAAc,kBAAkB,qBAAqB,OAAsB;AACzE,MAAI,KAAK,sBACP,OAAM,KAAK;WACF,CAAC,KAAK,UACf,OAAM,KAAK;AAEb,MAAI,CAAC,KAAK,UACR,OAAM,IAAI,MAAM;AAGlB,MAAI,mBACF,KAAI;GACF,MAAM,iBAAiB,MAAM,KAAK,YAAY;IAC5C,MAAM;IACN,IAAI,KAAK;IACT,SAAS;MACR;AAEH,OAAI,CAAC,eAAe,QAClB,OAAM,IAAI,MAAM;WAEX,OAAO;AACd,WAAQ,MAAM,qCAAqC;AACnD,SAAM,IAAI,MAAM;;;;;;CAQtB,MAAM,aAA4B;AAChC,MAAI,KAAK,sBACP,QAAO,KAAK;AAQd,OAAK,wBAAwB,KAAK,kBAAkB,OAAM,UAAS;AACjE,WAAQ,MAAM,uCAAuC;AACrD,WAAQ,MAAM,+BAA+B;IAC3C,SAAS,MAAM;IACf,OAAO,MAAM;IACb,MAAM,MAAM;;AAGd,QAAK,wBAAwB;AAC7B,SAAM;;EAGR,MAAM,SAAS,MAAM,KAAK;AAC1B,SAAO;;;;;CAMT,MAAc,kBAAiC;AAC7C,MAAI;AACF,WAAQ,MAAM,4BAA4B,KAAK,OAAO;AAEtD,QAAK,YAAY,IAAI,OAAO,KAAK,OAAO,cAAe;IACrD,MAAM;IACN,MAAM;;AAGR,QAAK,UAAU,WAAW,UAAU;AAClC,YAAQ,MAAM,kCAAkC;;AAGlD,SAAM,KAAK;AAGX,OAAI,KAAK,OAAO,aAAa;IAC3B,MAAM,OAAO,MAAM,KAAK,YAA2C;KACjE,MAAM;KACN,IAAI,KAAK;KACT,SAAS,EAAE,QAAQ,KAAK,OAAO;;AAEjC,QAAI,CAAC,KAAK,QACR,OAAM,IAAI,MAAM,iCAAiC,KAAK;;AAK1D,OAAI,KAAK,OAAO,kBAAkB,KAAK,OAAO,wBAAwB,KAAK,OAAO,uBAAuB;IACvG,MAAM,QAAQ,MAAM,KAAK,YAAoD;KAC3E,MAAM;KACN,IAAI,KAAK;KACT,SAAS;MACP,gBAAgB,KAAK,OAAO;MAC5B,gBAAgB,KAAK,OAAO;MAC5B,iBAAiB,KAAK,OAAO;;;AAGjC,QAAI,CAAC,MAAM,QACT,OAAM,IAAI,MAAM,2CAA2C,MAAM;;WAI9DA,OAAY;AACnB,SAAM,IAAI,MAAM,yCAAyC,MAAM;;;;;;CAOnE,MAAc,YACZ,SACA,eAC4B;AAC5B,SAAO,IAAI,SAAS,SAAS,WAAW;AACtC,OAAI,CAAC,KAAK,WAAW;AACnB,2BAAO,IAAI,MAAM;AACjB;;GAGF,MAAM,YAAY,iBAAiB;GACnC,MAAM,UAAU,iBAAiB;AAC/B,2BAAO,IAAI,MAAM,yCAAyC,UAAU,wBAAwB,QAAQ;MACnG;GAEH,MAAM,iBAAiB,UAAwB;IAC7C,MAAM,WAAW,MAAM;AACvB,QAAI,SAAS,OAAO,QAAQ,IAAI;AAC9B,kBAAa;AACb,UAAK,UAAW,oBAAoB,WAAW;AAC/C,aAAQ;;;AAIZ,QAAK,UAAU,iBAAiB,WAAW;AAC3C,QAAK,UAAU,YAAY;;;;;;CAO/B,AAAQ,oBAA4B;AAClC,SAAO,OAAO,KAAK,MAAM,GAAG,EAAE,KAAK;;;;;;CAOrC,MAAM,iBAAiB,EACrB,YACA,eACA,qBACA,WAM6B;AAC7B,QAAM,KAAK,kBAAkB;EAE7B,MAAM,EAAE,sBAAsB,yBAAyB;GACrD;GACA,gBAAgB;GAChB,iBAAiB;;AAGnB,MAAI,CAAC,kBACH,OAAM,IAAI,MAAM;AAGlB,YAAU;GACR,MAAM;GACN,MAAM;IACJ,MAAM;IACN,SAAS;;;EAIb,MAAMC,UAAyD;GAC7D,MAAM;GACN,IAAI,KAAK;GACT,SAAS;IACP;IACqB;IACrB,QAAQ;;;EAIZ,MAAM,WAAW,MAAM,KAAK,YAAY;AACxC,MAAI,SAAS,SAAS;AAEpB,QAAK,sBAAsB;AAC3B,WAAQ,MAAM,yCAAyC;SAClD;AACL,WAAQ,MAAM,8CAA8C,SAAS;AACrE,WAAQ,MAAM,+BAA+B,KAAK,UAAU,UAAU,MAAM;AAC5E,WAAQ,MAAM,uCAAuC,KAAK,UAAU,SAAS,MAAM;;AAGrF,SAAO;;;;;;CAOT,MAAM,qBAAqB,WAAgD;AACzE,QAAM,KAAK,kBAAkB;EAC7B,MAAMC,UAA6D;GACjE,MAAM;GACN,IAAI,KAAK;GACT,SAAS,EACP,cAAc;IACZ,QAAQ,UAAU;IAClB,MAAM,UAAU;IAChB,aAAa,OAAO,UAAU;IAC9B,WAAW,UAAU;;;EAK3B,MAAM,WAAW,MAAM,KAAK,YAAY;AAExC,MAAI,CAAC,SAAS,WAAW,CAAC,SAAS,KACjC,OAAM,IAAI,MAAM,oCAAoC,SAAS;AAG/D,UAAQ,MAAM;AACd,SAAO,qBAAqB,SAAS;;;;;CAMvC,MAAM,iBAA2C;AAC/C,MAAI;AACF,SAAM,KAAK;WACJ,OAAO;AAEd,UAAO;IAAE,QAAQ;IAAO,eAAe;;;AAGzC,MAAI;GACF,MAAMC,UAAsD;IAC1D,MAAM;IACN,IAAI,KAAK;IACT,SAAS;;GAGX,MAAM,WAAW,MAAM,KAAK,YAAY;AAExC,OAAI,SAAS,WAAW,SAAS,KAC/B,QAAO;IACL,QAAQ,SAAS,KAAK;IACtB,eAAe,KAAK,sBAAsB,YAAY,KAAK,uBAAuB;IAClF,iBAAiB,SAAS,KAAK;;AAInC,UAAO;IAAE,QAAQ;IAAO,eAAe;;WAChC,OAAO;AACd,WAAQ,KAAK,0CAA0C;AACvD,UAAO;IAAE,QAAQ;IAAO,eAAe;;;;;;;CAO3C,MAAM,kBAAiC;AACrC,UAAQ,MAAM;AAEd,QAAM,KAAK;AAEX,MAAI;GACF,MAAMA,UAAsD;IAC1D,MAAM;IACN,IAAI,KAAK;IACT,SAAS;;GAGX,MAAM,WAAW,MAAM,KAAK,YAAY;AAExC,OAAI,SAAS,SAAS;AAEpB,SAAK,sBAAsB;AAC3B,YAAQ,MAAM;SAEd,SAAQ,KAAK,gCAAgC,SAAS;WAEjD,OAAO;AACd,WAAQ,KAAK,8BAA8B;;;;;;;;;;;;CAa/C,MAAM,4BACJ,cACA,cAIC;AACD,QAAM,KAAK;AACX,MAAI;GACF,MAAMC,UAAoE;IACxE,MAAM;IACN,IAAI,KAAK;IACT,SAAS,EAEP,cAAc,eAAe;KAC3B,QAAQ,aAAa;KACrB,MAAM,aAAa;KACnB,aAAa,OAAO,aAAa;KACjC,WAAW,aAAa;QACtB;;GAIR,MAAM,WAAW,MAAM,KAAK,YAAY;AAExC,OAAI,CAAC,SAAS,WAAW,CAAC,SAAS,KACjC,OAAM,IAAI,MAAM,4CAA4C,SAAS;AAGvE,OAAI,CAAC,UAAU,MAAM,mBACnB,OAAM,IAAI,MAAM;AAElB,OAAI,gBAAgB,aAElB,MAAK,sBAAsB,aAAa;AAI1C,UAAO;IACL,cAAc,SAAS,KAAK;IAC5B,cAAc,qBAAqB;KACjC,UAAU,SAAS,KAAK,mBAAmB;KAC3C,WAAW,SAAS,KAAK,mBAAmB;KAC5C,UAAU,SAAS,KAAK,mBAAmB;KAC3C,cAAc,SAAS,KAAK,mBAAmB;KAC/C,QAAQ,SAAS,KAAK,mBAAmB;KACzC,MAAM,SAAS,KAAK,mBAAmB;KACvC,aAAa,SAAS,KAAK,mBAAmB;KAC9C,WAAW,SAAS,KAAK,mBAAmB;;;WAIzCJ,OAAY;AACnB,WAAQ,MAAM,yDAAyD;AACvE,SAAM,IAAI,MAAM,6CAA6C,MAAM;;;;;;;;;;;;;CAcvE,MAAM,wBAAwB,EAC5B,YACA,eACA,cACA,eAAe,QAWd;AACD,UAAQ,MAAM;AACd,MAAI;AACF,SAAM,KAAK;GAIX,MAAM,EAAE,sBAAsB,yBAAyB;IACrD;IACA,gBAAgB;IAChB,iBAAiB;;GAInB,MAAM,kBAAkB,cAAc,aACjC,cAAc,eACd,cAAc,UACd,cAAc;GAGnB,MAAMK,UAAgE;IACpE,MAAM;IACN,IAAI,KAAK;IACT,SAAS;KACP,WAAW;KACI;KACD;KAEd,cAAc,kBAAkB;MAC9B,QAAQ,aAAa;MACrB,MAAM,aAAa;MACnB,aAAa,OAAO,aAAa;MACjC,WAAW,aAAa;SACtB;;;GAIR,MAAM,WAAW,MAAM,KAAK,YAAY;AAExC,OAAI,CAAC,SAAS,WAAW,CAAC,SAAS,KACjC,OAAM,IAAI,MAAM,kCAAkC,SAAS;AAE7D,OAAI,CAAC,SAAS,KAAK,aACjB,OAAM,IAAI,MAAM;AAElB,OAAI,CAAC,SAAS,KAAK,oBACjB,OAAM,IAAI,MAAM;AAElB,WAAQ,MAAM;GAGd,MAAM,eAAe,SAAS,KAAK,mBAC/B,qBAAqB;IACnB,UAAU,SAAS,KAAK,iBAAiB;IACzC,WAAW,SAAS,KAAK,iBAAiB;IAC1C,UAAU,SAAS,KAAK,iBAAiB;IACzC,cAAc,SAAS,KAAK,iBAAiB;IAC7C,QAAQ,SAAS,KAAK,iBAAiB;IACvC,MAAM,SAAS,KAAK,iBAAiB;IACrC,aAAa,SAAS,KAAK,iBAAiB;IAC5C,WAAW,SAAS,KAAK,iBAAiB;QAE5C;GAEJ,MAAMC,SAKF;IACF,cAAc,SAAS,KAAK;IAC5B;IACA,qBAAqB,SAAS,KAAK;IACnC,2BAA2B,SAAS,KAAK;;AAG3C,UAAO;WAEAN,OAAY;AACnB,WAAQ,MAAM,+CAA+C;AAC7D,SAAM,IAAI,MAAM,kCAAkC,MAAM;;;;;;;CAQ5D,MAAM,6BAA6B,EACjC,eACA,YACA,qBAK6B;AAC7B,QAAM,KAAK,kBAAkB;EAC7B,MAAMO,UAA2E;GAC/E,MAAM;GACN,IAAI,KAAK;GACT,SAAS;IACP;IACA;IACA;;;EAGJ,MAAM,WAAW,MAAM,KAAK,YAAY;AACxC,MAAI,SAAS,QACX,MAAK,sBAAsB;AAE7B,SAAO;;;;;CAMT,MAAc,6BAA4C;AACxD,MAAI;GACF,MAAM,YAAY;GAClB,MAAM,eAAe,MAAM,KAAK,YAAY;IAC1C,MAAM;IACN,IAAI,KAAK;IACT,SAAS;MACR;AACH,OAAI,CAAC,aAAa,QAChB,OAAM,IAAI,MAAM,+BAA+B,aAAa;AAE9D;WACOP,OAAY;AACnB,WAAQ,KAAK,oDAAoD,MAAM"}