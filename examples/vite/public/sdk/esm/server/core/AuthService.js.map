{"version":3,"file":"AuthService.js","names":["result: FinalExecutionOutcome","error: any","failure: NearExecutionFailure","parseError: any","body: VerifyAuthenticationRequest","e: any"],"sources":["../../../../src/server/core/AuthService.ts"],"sourcesContent":["import { Account } from '@near-js/accounts';\nimport { getSignerFromKeystore } from '@near-js/client';\nimport { KeyPairEd25519, PublicKey } from '@near-js/crypto';\nimport { InMemoryKeyStore, type KeyStore } from '@near-js/keystores';\nimport { JsonRpcProvider, type Provider } from '@near-js/providers';\nimport type { Signer } from '@near-js/signers';\nimport { actionCreators } from '@near-js/transactions';\nimport type { FinalExecutionOutcome } from '@near-js/types';\nimport { validateConfigs } from './config';\nimport {\n  Shamir3PassUtils,\n} from './shamirWorker';\nimport type {\n  AuthServiceConfig,\n  AccountCreationRequest,\n  AccountCreationResult,\n  CreateAccountAndRegisterRequest,\n  CreateAccountAndRegisterResult,\n  NearExecutionFailure,\n  NearReceiptOutcomeWithId,\n  VerifyAuthenticationRequest,\n  VerifyAuthenticationResponse,\n  ShamirApplyServerLockRequest,\n  ShamirRemoveServerLockRequest,\n  ShamirApplyServerLockResponse,\n  ShamirRemoveServerLockResponse,\n} from './types';\n\n/**\n * Framework-agnostic NEAR account service\n * Core business logic for account creation and registration operations\n */\nexport class AuthService {\n  private config: AuthServiceConfig;\n  private keyStore: KeyStore;\n  private isInitialized = false;\n  private rpcProvider: Provider;\n  private relayerAccount: Account = null!;\n  private signer: Signer = null!;\n\n  // Transaction queue to prevent nonce conflicts\n  private transactionQueue: Promise<any> = Promise.resolve();\n  private queueStats = { pending: 0, completed: 0, failed: 0 };\n\n  // Shamir 3-pass key management\n  private shamir3pass: Shamir3PassUtils | null = null;\n\n  constructor(config: AuthServiceConfig) {\n    validateConfigs(config);\n    this.config = {\n      // Use defaults if not set\n      relayerAccountId: config.relayerAccountId,\n      relayerPrivateKey: config.relayerPrivateKey,\n      webAuthnContractId: config.webAuthnContractId,\n      nearRpcUrl: config.nearRpcUrl\n        || 'https://rpc.testnet.near.org',\n      networkId: config.networkId\n        || 'testnet',\n      accountInitialBalance: config.accountInitialBalance\n        || '50000000000000000000000', // 0.05 NEAR\n      createAccountAndRegisterGas: config.createAccountAndRegisterGas\n        || '120000000000000', // 120 TGas\n      shamir_p_b64u: config.shamir_p_b64u,\n      shamir_e_s_b64u: config.shamir_e_s_b64u,\n      shamir_d_s_b64u: config.shamir_d_s_b64u,\n    };\n    this.keyStore = new InMemoryKeyStore();\n    this.rpcProvider = new JsonRpcProvider({ url: config.nearRpcUrl }) as Provider;\n  }\n\n  async getRelayerAccount(): Promise<Account> {\n    await this._ensureSignerAndRelayerAccount();\n    return this.relayerAccount;\n  }\n\n  private async _ensureSignerAndRelayerAccount(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    // Initialize Shamir3Pass WASM module (loads same worker wasm)\n    if (!this.shamir3pass) {\n      this.shamir3pass = new Shamir3PassUtils({\n        p_b64u: this.config.shamir_p_b64u,\n        e_s_b64u: this.config.shamir_e_s_b64u,\n        d_s_b64u: this.config.shamir_d_s_b64u,\n      });\n    }\n\n    const privateKeyString = this.config.relayerPrivateKey.substring(8);\n    const keyPair = new KeyPairEd25519(privateKeyString);\n    await this.keyStore.setKey(this.config.networkId, this.config.relayerAccountId, keyPair);\n\n    this.signer = await getSignerFromKeystore(this.config.relayerAccountId, this.config.networkId, this.keyStore);\n    this.relayerAccount = new Account(this.config.relayerAccountId, this.rpcProvider, this.signer);\n    this.isInitialized = true;\n    console.log(`\n    AuthService initialized with:\n    • networkId: ${this.config.networkId}\n    • nearRpcUrl: ${this.config.nearRpcUrl}\n    • relayerAccountId: ${this.config.relayerAccountId}\n    • webAuthnContractId: ${this.config.webAuthnContractId}\n    • accountInitialBalance: ${this.config.accountInitialBalance} (${this.formatYoctoToNear(this.config.accountInitialBalance)} NEAR)\n    • createAccountAndRegisterGas: ${this.config.createAccountAndRegisterGas} (${this.formatGasToTGas(this.config.createAccountAndRegisterGas)})\n    • shamir_p_b64u: ${this.config.shamir_p_b64u.slice(0, 10)}...\n    • shamir_e_s_b64u: ${this.config.shamir_e_s_b64u.slice(0, 10)}...\n    • shamir_d_s_b64u: ${this.config.shamir_d_s_b64u.slice(0, 10)}...\n    `);\n  }\n  /**\n   * Shamir 3-pass: apply server exponent (registration step)\n   * @param kek_c_b64u - base64url-encoded KEK_c (client locked key encryption key)\n   * @returns base64url-encoded KEK_cs (server locked key encryption key)\n   */\n  async applyServerLock(kek_c_b64u: string): Promise<ShamirApplyServerLockResponse> {\n    if (!this.shamir3pass) throw new Error('Shamir3Pass not initialized');\n    return await this.shamir3pass.applyServerLock({ kek_c_b64u } as ShamirApplyServerLockRequest);\n  }\n\n  /**\n   * Shamir 3-pass: remove server exponent (login step)\n   */\n  async removeServerLock(kek_cs_b64u: string): Promise<ShamirRemoveServerLockResponse> {\n    if (!this.shamir3pass) throw new Error('Shamir3Pass not initialized');\n    return await this.shamir3pass.removeServerLock({ kek_cs_b64u } as ShamirRemoveServerLockRequest);\n  }\n\n  // Format NEAR gas (string) to TGas for display\n  private formatGasToTGas(gasString: string): string {\n    const gasAmount = BigInt(gasString);\n    const tGas = Number(gasAmount) / 1e12;\n    return `${tGas.toFixed(0)} TGas`;\n  }\n\n  // Convert yoctoNEAR to NEAR for display\n  private formatYoctoToNear(yoctoAmount: string | bigint): string {\n    const amount = typeof yoctoAmount === 'string' ? BigInt(yoctoAmount) : yoctoAmount;\n    const nearAmount = Number(amount) / 1e24;\n    return nearAmount.toFixed(3);\n  }\n\n  /**\n   * Create a new account with the specified balance\n   */\n  async createAccount(request: AccountCreationRequest): Promise<AccountCreationResult> {\n    await this._ensureSignerAndRelayerAccount();\n\n    return this.queueTransaction(async () => {\n      try {\n        if (!this.isValidAccountId(request.accountId)) {\n          throw new Error(`Invalid account ID format: ${request.accountId}`);\n        }\n\n        // Check if account already exists\n        console.log(`Checking if account ${request.accountId} already exists...`);\n        const accountExists = await this.checkAccountExists(request.accountId);\n        if (accountExists) {\n          throw new Error(`Account ${request.accountId} already exists. Cannot create duplicate account.`);\n        }\n        console.log(`Account ${request.accountId} is available for creation`);\n\n        const initialBalance = BigInt(this.config.accountInitialBalance);\n        const publicKey = PublicKey.fromString(request.publicKey);\n\n        console.log(`Creating account: ${request.accountId}`);\n        console.log(`Initial balance: ${initialBalance.toString()} yoctoNEAR`);\n\n        // Create account using actionCreators\n        const result: FinalExecutionOutcome = await this.relayerAccount.signAndSendTransaction({\n          receiverId: request.accountId,\n          actions: [\n            actionCreators.createAccount(),\n            actionCreators.transfer(initialBalance),\n            actionCreators.addKey(publicKey, actionCreators.fullAccessKey()),\n          ]\n        });\n\n        console.log(`Account creation completed: ${result.transaction.hash}`);\n        const nearAmount = (Number(initialBalance) / 1e24).toFixed(6);\n        return {\n          success: true,\n          transactionHash: result.transaction.hash,\n          accountId: request.accountId,\n          message: `Account ${request.accountId} created with ${nearAmount} NEAR initial balance`\n        };\n\n      } catch (error: any) {\n        console.error(`Account creation failed for ${request.accountId}:`, error);\n        return {\n          success: false,\n          error: error.message || 'Unknown account creation error',\n          message: `Failed to create account ${request.accountId}: ${error.message}`\n        };\n      }\n    }, `create account ${request.accountId}`);\n  }\n\n  /**\n   * Create account and register user with WebAuthn in a single atomic transaction\n   */\n  async createAccountAndRegisterUser(request: CreateAccountAndRegisterRequest): Promise<CreateAccountAndRegisterResult> {\n    await this._ensureSignerAndRelayerAccount();\n\n    return this.queueTransaction(async () => {\n      try {\n        if (!this.isValidAccountId(request.new_account_id)) {\n          throw new Error(`Invalid account ID format: ${request.new_account_id}`);\n        }\n\n        // Check if account already exists\n        console.log(`Checking if account ${request.new_account_id} already exists...`);\n        const accountExists = await this.checkAccountExists(request.new_account_id);\n        if (accountExists) {\n          throw new Error(`Account ${request.new_account_id} already exists. Cannot create duplicate account.`);\n        }\n        console.log(`Account ${request.new_account_id} is available for atomic creation and registration`);\n        console.log(`Atomic registration for account: ${request.new_account_id}`);\n        console.log(`Contract: ${this.config.webAuthnContractId}`);\n\n        // Prepare contract arguments\n        const contractArgs = {\n          new_account_id: request.new_account_id,\n          new_public_key: request.new_public_key,\n          vrf_data: request.vrf_data,\n          webauthn_registration: request.webauthn_registration,\n          deterministic_vrf_public_key: request.deterministic_vrf_public_key,\n          authenticator_options: request.authenticator_options,\n        };\n\n        // Call the contract's atomic function\n        const result: FinalExecutionOutcome = await this.relayerAccount.signAndSendTransaction({\n          receiverId: this.config.webAuthnContractId,\n          actions: [\n            actionCreators.functionCall(\n              'create_account_and_register_user',\n              contractArgs,\n              BigInt(this.config.createAccountAndRegisterGas),\n              BigInt(this.config.accountInitialBalance) // Initial balance\n            )\n          ]\n        });\n\n        // Parse contract execution results to detect failures\n        const contractError = this.parseContractExecutionError(result, request.new_account_id);\n        if (contractError) {\n          console.error(`Contract execution failed for ${request.new_account_id}:`, contractError);\n          throw new Error(contractError);\n        }\n\n        console.log(`Atomic registration completed: ${result.transaction.hash}`);\n        return {\n          success: true,\n          transactionHash: result.transaction.hash,\n          message: `Account ${request.new_account_id} created and registered successfully`,\n          contractResult: result,\n        };\n\n      } catch (error: any) {\n        console.error(`Atomic registration failed for ${request.new_account_id}:`, error);\n        return {\n          success: false,\n          error: error.message || 'Unknown atomic registration error',\n          message: `Failed to create and register account ${request.new_account_id}: ${error.message}`\n        };\n      }\n    }, `atomic create and register ${request.new_account_id}`);\n  }\n\n  /**\n   * Verify authentication response and issue JWT\n   * Calls the web3authn contract's verify_authentication_response method\n   * and issues a JWT or session credential upon successful verification\n   */\n  async verifyAuthenticationResponse(\n    request: VerifyAuthenticationRequest\n  ): Promise<VerifyAuthenticationResponse> {\n    try {\n      await this._ensureSignerAndRelayerAccount();\n\n      // Call the contract's verify_authentication_response method\n      const result = await this.relayerAccount.functionCall({\n        contractId: this.config.webAuthnContractId,\n        methodName: 'verify_authentication_response',\n        args: {\n          vrf_data: request.vrf_data,\n          webauthn_authentication: request.webauthn_authentication,\n        },\n        gas: BigInt('30000000000000'), // 30 TGas\n        attachedDeposit: BigInt('0'),\n      });\n\n      // Parse the contract response\n      const contractResponse = this.parseContractResponse(result);\n\n      if (contractResponse.verified) {\n        // Generate JWT or session credential\n        const jwt = this.generateJWT(request.vrf_data.user_id);\n\n        return {\n          success: true,\n          verified: true,\n          jwt,\n          sessionCredential: {\n            userId: request.vrf_data.user_id,\n            issuedAt: new Date().toISOString(),\n            expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24 hours\n          },\n          contractResponse,\n        };\n      } else {\n        return {\n          success: false,\n          verified: false,\n          error: 'Authentication verification failed',\n          contractResponse,\n        };\n      }\n    } catch (error: any) {\n      const errorMessage = this.parseContractExecutionError(error, 'verification');\n      return {\n        success: false,\n        verified: false,\n        error: errorMessage || error.message || 'Verification failed',\n      };\n    }\n  }\n\n  /**\n   * Generate a simple JWT token\n   * In production, you'd want to use a proper JWT library with signing\n   */\n  private generateJWT(userId: string): string {\n    const header = {\n      alg: 'HS256',\n      typ: 'JWT',\n    };\n\n    const payload = {\n      sub: userId,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24 hours\n      iss: 'web3authn-sdk',\n    };\n\n    // Simple base64 encoding (in production, use proper JWT signing)\n    const encodedHeader = btoa(JSON.stringify(header));\n    const encodedPayload = btoa(JSON.stringify(payload));\n\n    // For demo purposes, using a simple signature\n    // In production, use a proper JWT library with HMAC or RSA signing\n    const signature = btoa(`signature-${userId}-${Date.now()}`);\n\n    return `${encodedHeader}.${encodedPayload}.${signature}`;\n  }\n\n  /**\n   * Parse contract response from execution outcome\n   */\n  private parseContractResponse(result: FinalExecutionOutcome): any {\n    try {\n      // For now, return a basic success response\n      // In a real implementation, you'd parse the actual contract response\n      return {\n        verified: true,\n        success: true,\n      };\n    } catch (error) {\n      return {\n        verified: false,\n        error: 'Failed to parse contract response',\n      };\n    }\n  }\n\n  /**\n   * Parse contract execution results to detect specific failure types\n   */\n  private parseContractExecutionError(result: FinalExecutionOutcome, accountId: string): string | null {\n    try {\n      // Check main transaction status\n      if (result.status && typeof result.status === 'object' && 'Failure' in result.status) {\n        console.log(`Transaction failed:`, result.status.Failure);\n        return `Transaction failed: ${JSON.stringify(result.status.Failure)}`;\n      }\n\n      // Check receipts for failures\n      const receipts = (result.receipts_outcome || []) as NearReceiptOutcomeWithId[];\n      for (const receipt of receipts) {\n        const status = receipt.outcome?.status;\n\n        if (status?.Failure) {\n          const failure: NearExecutionFailure = status.Failure;\n          console.log(`Receipt failure detected:`, failure);\n\n          if (failure.ActionError?.kind) {\n            const actionKind = failure.ActionError.kind;\n\n            if (actionKind.AccountAlreadyExists) {\n              return `Account ${actionKind.AccountAlreadyExists.accountId} already exists on NEAR network`;\n            }\n\n            if (actionKind.AccountDoesNotExist) {\n              return `Referenced account ${actionKind.AccountDoesNotExist.account_id} does not exist`;\n            }\n\n            if (actionKind.InsufficientStake) {\n              const stakeInfo = actionKind.InsufficientStake;\n              return `Insufficient stake for account creation: ${stakeInfo.account_id}`;\n            }\n\n            if (actionKind.LackBalanceForState) {\n              const balanceInfo = actionKind.LackBalanceForState;\n              return `Insufficient balance for account state: ${balanceInfo.account_id}`;\n            }\n\n            return `Account creation failed: ${JSON.stringify(actionKind)}`;\n          }\n\n          return `Contract execution failed: ${JSON.stringify(failure)}`;\n        }\n\n        // Check logs for error keywords\n        const logs = receipt.outcome?.logs || [];\n        for (const log of logs) {\n          if (typeof log === 'string') {\n            if (log.includes('AccountAlreadyExists') || log.includes('account already exists')) {\n              return `Account ${accountId} already exists`;\n            }\n            if (log.includes('AccountDoesNotExist')) {\n              return `Referenced account does not exist`;\n            }\n            if (log.includes('Cannot deserialize the contract state')) {\n              return `Contract state deserialization failed. This may be due to a contract upgrade. Please try again or contact support.`;\n            }\n            if (log.includes('GuestPanic')) {\n              return `Contract execution panic: ${log}`;\n            }\n          }\n        }\n      }\n\n      return null;\n\n    } catch (parseError: any) {\n      console.warn(`Error parsing contract execution results:`, parseError);\n      return null;\n    }\n  }\n\n  private isValidAccountId(accountId: string): boolean {\n    if (!accountId || accountId.length < 2 || accountId.length > 64) {\n      return false;\n    }\n    const validPattern = /^[a-z0-9_.-]+$/;\n    return validPattern.test(accountId);\n  }\n\n  /**\n   * Framework-agnostic: handle verify-authentication request\n   * Converts a generic ServerRequest to ServerResponse using this service\n   */\n  async handleVerifyAuthenticationResponse(request: VerifyAuthenticationRequest): Promise<VerifyAuthenticationResponse> {\n    return this.verifyAuthenticationResponse(request);\n  }\n\n  /**\n   * Express-style middleware factory for verify-authentication\n   */\n  verifyAuthenticationMiddleware() {\n    return async (req: any, res: any) => {\n      try {\n        if (!req?.body) {\n          res.status(400).json({ error: 'Request body is required' });\n          return;\n        }\n        const body: VerifyAuthenticationRequest = req.body;\n        if (!body.vrf_data || !body.webauthn_authentication) {\n          res.status(400).json({ error: 'vrf_data and webauthn_authentication are required' });\n          return;\n        }\n        const result = await this.verifyAuthenticationResponse(body);\n        res.status(result.success ? 200 : 400).json(result);\n      } catch (error: any) {\n        console.error('Error in verify authentication middleware:', error);\n        res.status(500).json({ success: false, error: 'Internal server error', details: error?.message });\n      }\n    };\n  }\n\n  /**\n   * Framework-agnostic Shamir 3-pass: apply server lock\n   */\n  async handleApplyServerLock(request: {\n    body: { kek_c_b64u: string }\n  }): Promise<{ status: number; headers: Record<string, string>; body: string }> {\n    try {\n      if (!request.body) {\n        return {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ error: 'Missing body' })\n        };\n      }\n      if (typeof request.body.kek_c_b64u !== 'string' || !request.body.kek_c_b64u) {\n        return {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ error: 'kek_c_b64u required and must be a non-empty string' })\n        };\n      }\n      const out = await this.applyServerLock(request.body.kek_c_b64u);\n      return {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(out)\n      };\n    } catch (e: any) {\n      return {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ error: 'internal', details: e?.message })\n      };\n    }\n  }\n\n  /**\n   * Framework-agnostic Shamir 3-pass: remove server lock\n   */\n  async handleRemoveServerLock(request: {\n    body: { kek_cs_b64u: string }\n  }): Promise<{ status: number; headers: Record<string, string>; body: string }> {\n    try {\n      if (!request.body) {\n        return {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ error: 'Missing body' })\n        };\n      }\n      if (typeof request.body.kek_cs_b64u !== 'string' || !request.body.kek_cs_b64u) {\n        return {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ error: 'kek_cs_b64u required and must be a non-empty string' })\n        };\n      }\n      const out = await this.removeServerLock(request.body.kek_cs_b64u);\n      return {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(out)\n      };\n    } catch (e: any) {\n      return {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ error: 'internal', details: e?.message })\n      };\n    }\n  }\n\n  async checkAccountExists(accountId: string): Promise<boolean> {\n    await this._ensureSignerAndRelayerAccount();\n    try {\n      await this.rpcProvider.query({\n        request_type: 'view_account',\n        finality: 'final',\n        account_id: accountId,\n      });\n      return true;\n    } catch (error: any) {\n      if (error.type === 'AccountDoesNotExist' ||\n          (error.cause && error.cause.name === 'UNKNOWN_ACCOUNT')) {\n        return false;\n      }\n      console.error(`Error checking account existence for ${accountId}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Queue transactions to prevent nonce conflicts\n   */\n  private async queueTransaction<T>(operation: () => Promise<T>, description: string): Promise<T> {\n    this.queueStats.pending++;\n    console.log(`[AuthService] Queueing: ${description} (pending: ${this.queueStats.pending})`);\n\n    this.transactionQueue = this.transactionQueue\n      .then(async () => {\n        try {\n          console.log(`[AuthService] Executing: ${description}`);\n          const result = await operation();\n          this.queueStats.completed++;\n          this.queueStats.pending--;\n          console.log(`[AuthService] Completed: ${description} (pending: ${this.queueStats.pending})`);\n          return result;\n        } catch (error: any) {\n          this.queueStats.failed++;\n          this.queueStats.pending--;\n          console.error(`[AuthService] Failed: ${description} (failed: ${this.queueStats.failed}):`, error?.message);\n          throw error;\n        }\n      })\n      .catch((error) => {\n        throw error;\n      });\n\n    return this.transactionQueue;\n  }\n}"],"mappings":";;;;;;;;;;;;;;AAgCA,IAAa,cAAb,MAAyB;CACvB,AAAQ;CACR,AAAQ;CACR,AAAQ,gBAAgB;CACxB,AAAQ;CACR,AAAQ,iBAA0B;CAClC,AAAQ,SAAiB;CAGzB,AAAQ,mBAAiC,QAAQ;CACjD,AAAQ,aAAa;EAAE,SAAS;EAAG,WAAW;EAAG,QAAQ;;CAGzD,AAAQ,cAAuC;CAE/C,YAAY,QAA2B;AACrC,kBAAgB;AAChB,OAAK,SAAS;GAEZ,kBAAkB,OAAO;GACzB,mBAAmB,OAAO;GAC1B,oBAAoB,OAAO;GAC3B,YAAY,OAAO,cACd;GACL,WAAW,OAAO,aACb;GACL,uBAAuB,OAAO,yBACzB;GACL,6BAA6B,OAAO,+BAC/B;GACL,eAAe,OAAO;GACtB,iBAAiB,OAAO;GACxB,iBAAiB,OAAO;;AAE1B,OAAK,WAAW,IAAI;AACpB,OAAK,cAAc,IAAI,gBAAgB,EAAE,KAAK,OAAO;;CAGvD,MAAM,oBAAsC;AAC1C,QAAM,KAAK;AACX,SAAO,KAAK;;CAGd,MAAc,iCAAgD;AAC5D,MAAI,KAAK,cACP;AAIF,MAAI,CAAC,KAAK,YACR,MAAK,cAAc,IAAI,iBAAiB;GACtC,QAAQ,KAAK,OAAO;GACpB,UAAU,KAAK,OAAO;GACtB,UAAU,KAAK,OAAO;;EAI1B,MAAM,mBAAmB,KAAK,OAAO,kBAAkB,UAAU;EACjE,MAAM,UAAU,IAAI,eAAe;AACnC,QAAM,KAAK,SAAS,OAAO,KAAK,OAAO,WAAW,KAAK,OAAO,kBAAkB;AAEhF,OAAK,SAAS,MAAM,sBAAsB,KAAK,OAAO,kBAAkB,KAAK,OAAO,WAAW,KAAK;AACpG,OAAK,iBAAiB,IAAI,QAAQ,KAAK,OAAO,kBAAkB,KAAK,aAAa,KAAK;AACvF,OAAK,gBAAgB;AACrB,UAAQ,IAAI;;mBAEG,KAAK,OAAO,UAAU;oBACrB,KAAK,OAAO,WAAW;0BACjB,KAAK,OAAO,iBAAiB;4BAC3B,KAAK,OAAO,mBAAmB;+BAC5B,KAAK,OAAO,sBAAsB,IAAI,KAAK,kBAAkB,KAAK,OAAO,uBAAuB;qCAC1F,KAAK,OAAO,4BAA4B,IAAI,KAAK,gBAAgB,KAAK,OAAO,6BAA6B;uBACxH,KAAK,OAAO,cAAc,MAAM,GAAG,IAAI;yBACrC,KAAK,OAAO,gBAAgB,MAAM,GAAG,IAAI;yBACzC,KAAK,OAAO,gBAAgB,MAAM,GAAG,IAAI;;;;;;;;CAQhE,MAAM,gBAAgB,YAA4D;AAChF,MAAI,CAAC,KAAK,YAAa,OAAM,IAAI,MAAM;AACvC,SAAO,MAAM,KAAK,YAAY,gBAAgB,EAAE;;;;;CAMlD,MAAM,iBAAiB,aAA8D;AACnF,MAAI,CAAC,KAAK,YAAa,OAAM,IAAI,MAAM;AACvC,SAAO,MAAM,KAAK,YAAY,iBAAiB,EAAE;;CAInD,AAAQ,gBAAgB,WAA2B;EACjD,MAAM,YAAY,OAAO;EACzB,MAAM,OAAO,OAAO,aAAa;AACjC,SAAO,GAAG,KAAK,QAAQ,GAAG;;CAI5B,AAAQ,kBAAkB,aAAsC;EAC9D,MAAM,SAAS,OAAO,gBAAgB,WAAW,OAAO,eAAe;EACvE,MAAM,aAAa,OAAO,UAAU;AACpC,SAAO,WAAW,QAAQ;;;;;CAM5B,MAAM,cAAc,SAAiE;AACnF,QAAM,KAAK;AAEX,SAAO,KAAK,iBAAiB,YAAY;AACvC,OAAI;AACF,QAAI,CAAC,KAAK,iBAAiB,QAAQ,WACjC,OAAM,IAAI,MAAM,8BAA8B,QAAQ;AAIxD,YAAQ,IAAI,uBAAuB,QAAQ,UAAU;IACrD,MAAM,gBAAgB,MAAM,KAAK,mBAAmB,QAAQ;AAC5D,QAAI,cACF,OAAM,IAAI,MAAM,WAAW,QAAQ,UAAU;AAE/C,YAAQ,IAAI,WAAW,QAAQ,UAAU;IAEzC,MAAM,iBAAiB,OAAO,KAAK,OAAO;IAC1C,MAAM,YAAY,UAAU,WAAW,QAAQ;AAE/C,YAAQ,IAAI,qBAAqB,QAAQ;AACzC,YAAQ,IAAI,oBAAoB,eAAe,WAAW;IAG1D,MAAMA,SAAgC,MAAM,KAAK,eAAe,uBAAuB;KACrF,YAAY,QAAQ;KACpB,SAAS;MACP,eAAe;MACf,eAAe,SAAS;MACxB,eAAe,OAAO,WAAW,eAAe;;;AAIpD,YAAQ,IAAI,+BAA+B,OAAO,YAAY;IAC9D,MAAM,cAAc,OAAO,kBAAkB,MAAM,QAAQ;AAC3D,WAAO;KACL,SAAS;KACT,iBAAiB,OAAO,YAAY;KACpC,WAAW,QAAQ;KACnB,SAAS,WAAW,QAAQ,UAAU,gBAAgB,WAAW;;YAG5DC,OAAY;AACnB,YAAQ,MAAM,+BAA+B,QAAQ,UAAU,IAAI;AACnE,WAAO;KACL,SAAS;KACT,OAAO,MAAM,WAAW;KACxB,SAAS,4BAA4B,QAAQ,UAAU,IAAI,MAAM;;;KAGpE,kBAAkB,QAAQ;;;;;CAM/B,MAAM,6BAA6B,SAAmF;AACpH,QAAM,KAAK;AAEX,SAAO,KAAK,iBAAiB,YAAY;AACvC,OAAI;AACF,QAAI,CAAC,KAAK,iBAAiB,QAAQ,gBACjC,OAAM,IAAI,MAAM,8BAA8B,QAAQ;AAIxD,YAAQ,IAAI,uBAAuB,QAAQ,eAAe;IAC1D,MAAM,gBAAgB,MAAM,KAAK,mBAAmB,QAAQ;AAC5D,QAAI,cACF,OAAM,IAAI,MAAM,WAAW,QAAQ,eAAe;AAEpD,YAAQ,IAAI,WAAW,QAAQ,eAAe;AAC9C,YAAQ,IAAI,oCAAoC,QAAQ;AACxD,YAAQ,IAAI,aAAa,KAAK,OAAO;IAGrC,MAAM,eAAe;KACnB,gBAAgB,QAAQ;KACxB,gBAAgB,QAAQ;KACxB,UAAU,QAAQ;KAClB,uBAAuB,QAAQ;KAC/B,8BAA8B,QAAQ;KACtC,uBAAuB,QAAQ;;IAIjC,MAAMD,SAAgC,MAAM,KAAK,eAAe,uBAAuB;KACrF,YAAY,KAAK,OAAO;KACxB,SAAS,CACP,eAAe,aACb,oCACA,cACA,OAAO,KAAK,OAAO,8BACnB,OAAO,KAAK,OAAO;;IAMzB,MAAM,gBAAgB,KAAK,4BAA4B,QAAQ,QAAQ;AACvE,QAAI,eAAe;AACjB,aAAQ,MAAM,iCAAiC,QAAQ,eAAe,IAAI;AAC1E,WAAM,IAAI,MAAM;;AAGlB,YAAQ,IAAI,kCAAkC,OAAO,YAAY;AACjE,WAAO;KACL,SAAS;KACT,iBAAiB,OAAO,YAAY;KACpC,SAAS,WAAW,QAAQ,eAAe;KAC3C,gBAAgB;;YAGXC,OAAY;AACnB,YAAQ,MAAM,kCAAkC,QAAQ,eAAe,IAAI;AAC3E,WAAO;KACL,SAAS;KACT,OAAO,MAAM,WAAW;KACxB,SAAS,yCAAyC,QAAQ,eAAe,IAAI,MAAM;;;KAGtF,8BAA8B,QAAQ;;;;;;;CAQ3C,MAAM,6BACJ,SACuC;AACvC,MAAI;AACF,SAAM,KAAK;GAGX,MAAM,SAAS,MAAM,KAAK,eAAe,aAAa;IACpD,YAAY,KAAK,OAAO;IACxB,YAAY;IACZ,MAAM;KACJ,UAAU,QAAQ;KAClB,yBAAyB,QAAQ;;IAEnC,KAAK,OAAO;IACZ,iBAAiB,OAAO;;GAI1B,MAAM,mBAAmB,KAAK,sBAAsB;AAEpD,OAAI,iBAAiB,UAAU;IAE7B,MAAM,MAAM,KAAK,YAAY,QAAQ,SAAS;AAE9C,WAAO;KACL,SAAS;KACT,UAAU;KACV;KACA,mBAAmB;MACjB,QAAQ,QAAQ,SAAS;MACzB,2BAAU,IAAI,QAAO;MACrB,WAAW,IAAI,KAAK,KAAK,QAAQ,OAAU,KAAK,KAAM;;KAExD;;SAGF,QAAO;IACL,SAAS;IACT,UAAU;IACV,OAAO;IACP;;WAGGA,OAAY;GACnB,MAAM,eAAe,KAAK,4BAA4B,OAAO;AAC7D,UAAO;IACL,SAAS;IACT,UAAU;IACV,OAAO,gBAAgB,MAAM,WAAW;;;;;;;;CAS9C,AAAQ,YAAY,QAAwB;EAC1C,MAAM,SAAS;GACb,KAAK;GACL,KAAK;;EAGP,MAAM,UAAU;GACd,KAAK;GACL,KAAK,KAAK,MAAM,KAAK,QAAQ;GAC7B,KAAK,KAAK,MAAM,KAAK,QAAQ,OAAS,OAAU;GAChD,KAAK;;EAIP,MAAM,gBAAgB,KAAK,KAAK,UAAU;EAC1C,MAAM,iBAAiB,KAAK,KAAK,UAAU;EAI3C,MAAM,YAAY,KAAK,aAAa,OAAO,GAAG,KAAK;AAEnD,SAAO,GAAG,cAAc,GAAG,eAAe,GAAG;;;;;CAM/C,AAAQ,sBAAsB,QAAoC;AAChE,MAAI;AAGF,UAAO;IACL,UAAU;IACV,SAAS;;WAEJ,OAAO;AACd,UAAO;IACL,UAAU;IACV,OAAO;;;;;;;CAQb,AAAQ,4BAA4B,QAA+B,WAAkC;AACnG,MAAI;AAEF,OAAI,OAAO,UAAU,OAAO,OAAO,WAAW,YAAY,aAAa,OAAO,QAAQ;AACpF,YAAQ,IAAI,uBAAuB,OAAO,OAAO;AACjD,WAAO,uBAAuB,KAAK,UAAU,OAAO,OAAO;;GAI7D,MAAM,WAAY,OAAO,oBAAoB;AAC7C,QAAK,MAAM,WAAW,UAAU;IAC9B,MAAM,SAAS,QAAQ,SAAS;AAEhC,QAAI,QAAQ,SAAS;KACnB,MAAMC,UAAgC,OAAO;AAC7C,aAAQ,IAAI,6BAA6B;AAEzC,SAAI,QAAQ,aAAa,MAAM;MAC7B,MAAM,aAAa,QAAQ,YAAY;AAEvC,UAAI,WAAW,qBACb,QAAO,WAAW,WAAW,qBAAqB,UAAU;AAG9D,UAAI,WAAW,oBACb,QAAO,sBAAsB,WAAW,oBAAoB,WAAW;AAGzE,UAAI,WAAW,mBAAmB;OAChC,MAAM,YAAY,WAAW;AAC7B,cAAO,4CAA4C,UAAU;;AAG/D,UAAI,WAAW,qBAAqB;OAClC,MAAM,cAAc,WAAW;AAC/B,cAAO,2CAA2C,YAAY;;AAGhE,aAAO,4BAA4B,KAAK,UAAU;;AAGpD,YAAO,8BAA8B,KAAK,UAAU;;IAItD,MAAM,OAAO,QAAQ,SAAS,QAAQ;AACtC,SAAK,MAAM,OAAO,KAChB,KAAI,OAAO,QAAQ,UAAU;AAC3B,SAAI,IAAI,SAAS,2BAA2B,IAAI,SAAS,0BACvD,QAAO,WAAW,UAAU;AAE9B,SAAI,IAAI,SAAS,uBACf,QAAO;AAET,SAAI,IAAI,SAAS,yCACf,QAAO;AAET,SAAI,IAAI,SAAS,cACf,QAAO,6BAA6B;;;AAM5C,UAAO;WAEAC,YAAiB;AACxB,WAAQ,KAAK,6CAA6C;AAC1D,UAAO;;;CAIX,AAAQ,iBAAiB,WAA4B;AACnD,MAAI,CAAC,aAAa,UAAU,SAAS,KAAK,UAAU,SAAS,GAC3D,QAAO;EAET,MAAM,eAAe;AACrB,SAAO,aAAa,KAAK;;;;;;CAO3B,MAAM,mCAAmC,SAA6E;AACpH,SAAO,KAAK,6BAA6B;;;;;CAM3C,iCAAiC;AAC/B,SAAO,OAAO,KAAU,QAAa;AACnC,OAAI;AACF,QAAI,CAAC,KAAK,MAAM;AACd,SAAI,OAAO,KAAK,KAAK,EAAE,OAAO;AAC9B;;IAEF,MAAMC,OAAoC,IAAI;AAC9C,QAAI,CAAC,KAAK,YAAY,CAAC,KAAK,yBAAyB;AACnD,SAAI,OAAO,KAAK,KAAK,EAAE,OAAO;AAC9B;;IAEF,MAAM,SAAS,MAAM,KAAK,6BAA6B;AACvD,QAAI,OAAO,OAAO,UAAU,MAAM,KAAK,KAAK;YACrCH,OAAY;AACnB,YAAQ,MAAM,8CAA8C;AAC5D,QAAI,OAAO,KAAK,KAAK;KAAE,SAAS;KAAO,OAAO;KAAyB,SAAS,OAAO;;;;;;;;CAQ7F,MAAM,sBAAsB,SAEmD;AAC7E,MAAI;AACF,OAAI,CAAC,QAAQ,KACX,QAAO;IACL,QAAQ;IACR,SAAS,EAAE,gBAAgB;IAC3B,MAAM,KAAK,UAAU,EAAE,OAAO;;AAGlC,OAAI,OAAO,QAAQ,KAAK,eAAe,YAAY,CAAC,QAAQ,KAAK,WAC/D,QAAO;IACL,QAAQ;IACR,SAAS,EAAE,gBAAgB;IAC3B,MAAM,KAAK,UAAU,EAAE,OAAO;;GAGlC,MAAM,MAAM,MAAM,KAAK,gBAAgB,QAAQ,KAAK;AACpD,UAAO;IACL,QAAQ;IACR,SAAS,EAAE,gBAAgB;IAC3B,MAAM,KAAK,UAAU;;WAEhBI,GAAQ;AACf,UAAO;IACL,QAAQ;IACR,SAAS,EAAE,gBAAgB;IAC3B,MAAM,KAAK,UAAU;KAAE,OAAO;KAAY,SAAS,GAAG;;;;;;;;CAQ5D,MAAM,uBAAuB,SAEkD;AAC7E,MAAI;AACF,OAAI,CAAC,QAAQ,KACX,QAAO;IACL,QAAQ;IACR,SAAS,EAAE,gBAAgB;IAC3B,MAAM,KAAK,UAAU,EAAE,OAAO;;AAGlC,OAAI,OAAO,QAAQ,KAAK,gBAAgB,YAAY,CAAC,QAAQ,KAAK,YAChE,QAAO;IACL,QAAQ;IACR,SAAS,EAAE,gBAAgB;IAC3B,MAAM,KAAK,UAAU,EAAE,OAAO;;GAGlC,MAAM,MAAM,MAAM,KAAK,iBAAiB,QAAQ,KAAK;AACrD,UAAO;IACL,QAAQ;IACR,SAAS,EAAE,gBAAgB;IAC3B,MAAM,KAAK,UAAU;;WAEhBA,GAAQ;AACf,UAAO;IACL,QAAQ;IACR,SAAS,EAAE,gBAAgB;IAC3B,MAAM,KAAK,UAAU;KAAE,OAAO;KAAY,SAAS,GAAG;;;;;CAK5D,MAAM,mBAAmB,WAAqC;AAC5D,QAAM,KAAK;AACX,MAAI;AACF,SAAM,KAAK,YAAY,MAAM;IAC3B,cAAc;IACd,UAAU;IACV,YAAY;;AAEd,UAAO;WACAJ,OAAY;AACnB,OAAI,MAAM,SAAS,yBACd,MAAM,SAAS,MAAM,MAAM,SAAS,kBACvC,QAAO;AAET,WAAQ,MAAM,wCAAwC,UAAU,IAAI;AACpE,SAAM;;;;;;CAOV,MAAc,iBAAoB,WAA6B,aAAiC;AAC9F,OAAK,WAAW;AAChB,UAAQ,IAAI,2BAA2B,YAAY,aAAa,KAAK,WAAW,QAAQ;AAExF,OAAK,mBAAmB,KAAK,iBAC1B,KAAK,YAAY;AAChB,OAAI;AACF,YAAQ,IAAI,4BAA4B;IACxC,MAAM,SAAS,MAAM;AACrB,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,YAAQ,IAAI,4BAA4B,YAAY,aAAa,KAAK,WAAW,QAAQ;AACzF,WAAO;YACAA,OAAY;AACnB,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,YAAQ,MAAM,yBAAyB,YAAY,YAAY,KAAK,WAAW,OAAO,KAAK,OAAO;AAClG,UAAM;;KAGT,OAAO,UAAU;AAChB,SAAM;;AAGV,SAAO,KAAK"}