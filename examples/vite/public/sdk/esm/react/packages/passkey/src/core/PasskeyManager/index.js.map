{"version":3,"file":"index.js","names":[],"sources":["../../../../../../../../src/core/PasskeyManager/index.ts"],"sourcesContent":["import { WebAuthnManager } from '../WebAuthnManager';\nimport { registerPasskey } from './registration';\nimport { loginPasskey, getLoginState, getRecentLogins, logoutAndClearVrfSession } from './login';\nimport {\n  executeAction,\n  signTransactionsWithActions,\n  sendTransaction,\n  signAndSendTransactions,\n} from './actions';\nimport { recoverAccount, AccountRecoveryFlow, type RecoveryResult } from './recoverAccount';\nimport {\n  MinimalNearClient,\n  type NearClient,\n  type SignedTransaction,\n  type AccessKeyList,\n} from '../NearClient';\nimport type {\n  PasskeyManagerConfigs,\n  RegistrationResult,\n  LoginResult,\n  BaseHooksOptions,\n  RegistrationHooksOptions,\n  LoginHooksOptions,\n  ActionHooksOptions,\n  ActionResult,\n  LoginState,\n  AccountRecoveryHooksOptions,\n  VerifyAndSignTransactionResult,\n  SignAndSendTransactionHooksOptions,\n  SendTransactionHooksOptions,\n} from '../types/passkeyManager';\nimport { ActionPhase, ActionStatus } from '../types/passkeyManager';\nimport { ConfirmationConfig } from '../types/signer-worker';\nimport { DEFAULT_AUTHENTICATOR_OPTIONS } from '../types/authenticatorOptions';\nimport { toAccountId, type AccountId } from '../types/accountIds';\nimport {\n  ActionType,\n  type ActionArgs,\n  type TransactionInput\n} from '../types/actions';\nimport type {\n  DeviceLinkingQRData,\n  LinkDeviceResult,\n  StartDeviceLinkingOptionsDevice2,\n  ScanAndLinkDeviceOptionsDevice1\n} from '../types/linkDevice';\nimport { LinkDeviceFlow } from './linkDevice';\nimport { linkDeviceWithQRCode } from './scanDevice';\nimport {\n  ScanQRCodeFlow,\n  type ScanQRCodeFlowOptions,\n  type ScanQRCodeFlowEvents,\n} from '../../utils/qrScanner';\nimport {\n  signNEP413Message,\n  type SignNEP413MessageParams,\n  type SignNEP413MessageResult\n} from './signNEP413';\nimport { getOptimalCameraFacingMode } from '@/utils';\nimport type { UserPreferencesManager } from '../WebAuthnManager/userPreferences';\nimport { ServiceIframeClient } from '../ServiceIframe/client';\n\n///////////////////////////////////////\n// PASSKEY MANAGER\n///////////////////////////////////////\n\nexport interface PasskeyManagerContext {\n  webAuthnManager: WebAuthnManager;\n  nearClient: NearClient;\n  configs: PasskeyManagerConfigs;\n}\n\n/**\n * Main PasskeyManager class that provides framework-agnostic passkey operations\n * with flexible event-based callbacks for custom UX implementation\n */\nexport class PasskeyManager {\n  private readonly webAuthnManager: WebAuthnManager;\n  private readonly nearClient: NearClient;\n  readonly configs: PasskeyManagerConfigs;\n  private serviceClient: ServiceIframeClient | null = null;\n\n  constructor(\n    configs: PasskeyManagerConfigs,\n    nearClient?: NearClient\n  ) {\n    this.configs = configs;\n    // Use provided client or create default one\n    this.nearClient = nearClient || new MinimalNearClient(configs.nearRpcUrl);\n    this.webAuthnManager = new WebAuthnManager(configs, this.nearClient);\n    // VRF worker initializes automatically in the constructor\n\n    // Defer service iframe init to an explicit call to avoid async in constructor.\n  }\n\n  /**\n   * Direct access to user preferences manager for convenience\n   * Example: passkeyManager.userPreferences.onThemeChange(cb)\n   */\n  get userPreferences(): UserPreferencesManager {\n    return this.webAuthnManager.getUserPreferences();\n  }\n\n  /**\n   * Initialize the hidden wallet service iframe client (optional).\n   * If `walletOrigin` is not provided in configs, this is a noâ€‘op.\n   */\n  async initServiceIframe(): Promise<void> {\n    if (!this.configs.walletOrigin) return;\n    if (this.serviceClient) return;\n    this.serviceClient = new ServiceIframeClient({\n      walletOrigin: this.configs.walletOrigin,\n      servicePath: this.configs.walletServicePath || '/service',\n      theme: this.configs.walletTheme,\n      nearRpcUrl: this.configs.nearRpcUrl,\n      nearNetwork: this.configs.nearNetwork,\n      contractId: this.configs.contractId,\n      relayer: this.configs.relayer,\n      vrfWorkerConfigs: this.configs.vrfWorkerConfigs as any,\n    });\n    await this.serviceClient.init();\n  }\n\n  /** Get the service iframe client if initialized. */\n  getServiceClient(): ServiceIframeClient | null { return this.serviceClient; }\n\n  getContext(): PasskeyManagerContext {\n    return {\n      webAuthnManager: this.webAuthnManager,\n      nearClient: this.nearClient,\n      configs: this.configs\n    }\n  }\n\n  getNearClient(): NearClient {\n    return this.nearClient;\n  }\n\n  /**\n   * View all access keys for a given account\n   * @param accountId - NEAR account ID to view access keys for\n   * @returns Promise resolving to access key list\n   */\n  async viewAccessKeyList(accountId: string): Promise<AccessKeyList> {\n    return this.nearClient.viewAccessKeyList(accountId);\n  }\n\n  ///////////////////////////////////////\n  // === Registration and Login ===\n  ///////////////////////////////////////\n\n  /**\n   * Register a new passkey for the given NEAR account ID\n   * Uses AccountId for on-chain operations and PRF salt derivation\n   */\n  async registerPasskey(\n    nearAccountId: string,\n    options: RegistrationHooksOptions\n  ): Promise<RegistrationResult> {\n    return registerPasskey(\n      this.getContext(),\n      toAccountId(nearAccountId),\n      options,\n      this.configs.authenticatorOptions || DEFAULT_AUTHENTICATOR_OPTIONS,\n      // Use config-based authenticator options with fallback to defaults\n    );\n  }\n\n  /**\n   * Login with an existing passkey\n   * Uses AccountId for on-chain operations and VRF operations\n   */\n  async loginPasskey(\n    nearAccountId: string,\n    options?: LoginHooksOptions\n  ): Promise<LoginResult> {\n    // Set current user for settings persistence\n    await this.webAuthnManager.setCurrentUser(toAccountId(nearAccountId));\n    // Set as last user for future sessions\n    await this.webAuthnManager.setLastUser(toAccountId(nearAccountId));\n    return loginPasskey(this.getContext(), toAccountId(nearAccountId), options);\n  }\n\n  /**\n   * Logout: Clear VRF session (clear VRF keypair in worker)\n   */\n  async logoutAndClearVrfSession(): Promise<void> {\n    return logoutAndClearVrfSession(this.getContext());\n  }\n\n  /**\n   * Get comprehensive login state information\n   * Uses AccountId for core account login state\n   */\n  async getLoginState(nearAccountId?: string): Promise<LoginState> {\n    return getLoginState(\n      this.getContext(),\n      nearAccountId ? toAccountId(nearAccountId) : undefined\n    );\n  }\n\n  /**\n   * Get check if accountId has a passkey from IndexedDB\n   */\n  async hasPasskeyCredential(nearAccountId: AccountId): Promise<boolean> {\n    // Convert device-specific ID to base account ID for IndexedDB lookup\n    const baseAccountId = toAccountId(nearAccountId);\n    return await this.webAuthnManager.hasPasskeyCredential(baseAccountId);\n  }\n\n  ///////////////////////////////////////\n  // === User Settings ===\n  ///////////////////////////////////////\n\n  /**\n   * Set confirmation behavior setting for the current user\n   */\n  setConfirmBehavior(behavior: 'requireClick' | 'autoProceed'): void {\n    this.webAuthnManager.getUserPreferences().setConfirmBehavior(behavior);\n  }\n\n  /**\n   * Set the unified confirmation configuration\n   */\n  setConfirmationConfig(config: ConfirmationConfig): void {\n    this.webAuthnManager.getUserPreferences().setConfirmationConfig(config);\n  }\n\n  setUserTheme(theme: 'dark' | 'light'): void {\n    this.webAuthnManager.getUserPreferences().setUserTheme(theme);\n  }\n\n  /**\n   * Get the current confirmation configuration\n   */\n  getConfirmationConfig(): ConfirmationConfig {\n    return this.webAuthnManager.getUserPreferences().getConfirmationConfig();\n  }\n\n  /**\n   * Prefetch latest block height/hash (and nonce if context missing) to reduce\n   * perceived latency when the user initiates a signing flow.\n   */\n  async prefetchBlockheight(): Promise<void> {\n    try {\n      await this.webAuthnManager.getNonceManager().prefetchBlockheight(this.nearClient);\n    } catch {}\n  }\n\n  async getRecentLogins(): Promise<{\n    accountIds: string[],\n    lastUsedAccountId: {\n      nearAccountId: AccountId,\n      deviceNumber: number,\n    } | null\n  }> {\n    return getRecentLogins(this.getContext());\n  }\n\n  ///////////////////////////////////////\n  // === Transactions ===\n  ///////////////////////////////////////\n\n  /**\n   * Execute a NEAR blockchain action using passkey-derived credentials\n   * Supports all NEAR action types: Transfer, FunctionCall, AddKey, etc.\n   *\n   * @param nearAccountId - NEAR account ID to execute action with\n   * @param actionArgs - Action to execute (single action or array for batched transactions)\n   * @param options - Action options for event handling\n   * - onEvent: EventCallback<ActionSSEEvent> - Optional event callback\n   * - onError: (error: Error) => void - Optional error callback\n   * - hooks: OperationHooks - Optional operation hooks\n   * - waitUntil: TxExecutionStatus - Optional waitUntil status\n   * @returns Promise resolving to action result\n   *\n   * @example\n   * ```typescript\n   * // Basic transfer\n   * const result = await passkeyManager.executeAction('alice.near', {\n   *   type: ActionType.Transfer,\n   *   receiverId: 'bob.near',\n   *   amount: '1000000000000000000000000' // 1 NEAR\n   * });\n   *\n   * // Function call with gas and deposit (already available in ActionArgs)\n   * const result = await passkeyManager.executeAction('alice.near', {\n   *   type: ActionType.FunctionCall,\n   *   receiverId: 'contract.near',\n   *   methodName: 'set_value',\n   *   args: { value: 42 },\n   *   gas: '50000000000000', // 50 TGas\n   *   deposit: '100000000000000000000000' // 0.1 NEAR\n   * });\n   *\n   * // Batched transaction\n   * const result = await passkeyManager.executeAction('alice.near', [\n   *   {\n   *     type: ActionType.Transfer,\n   *     receiverId: 'bob.near',\n   *     amount: '1000000000000000000000000'\n   *   },\n   *   {\n   *     type: ActionType.FunctionCall,\n   *     receiverId: 'contract.near',\n   *     methodName: 'log_transfer',\n   *     args: { recipient: 'bob.near' }\n   *   }\n   * ], {\n   *   onEvent: (event) => console.log('Action progress:', event)\n   * });\n   * ```\n   */\n  async executeAction(args: {\n    nearAccountId: string,\n    receiverId: string,\n    actionArgs: ActionArgs | ActionArgs[],\n    options?: ActionHooksOptions\n  }): Promise<ActionResult> {\n    return executeAction({\n      context: this.getContext(),\n      nearAccountId: toAccountId(args.nearAccountId),\n      receiverId: toAccountId(args.receiverId),\n      actionArgs: args.actionArgs,\n      options: args.options\n    });\n  }\n\n  /**\n   * Sign and send multiple transactions with actions\n   * This method signs transactions with actions and sends them to the network\n   *\n   * @param nearAccountId - NEAR account ID to sign and send transactions with\n   * @param transactionInputs - Transaction inputs to sign and send\n   * @param options - Sign and send transaction options\n   * - onEvent: EventCallback<ActionSSEEvent> - Optional event callback\n   * - onError: (error: Error) => void - Optional error callback\n   * - hooks: OperationHooks - Optional operation hooks\n   * - waitUntil: TxExecutionStatus - Optional waitUntil status\n   * - executeSequentially: boolean - Wait for each transaction to finish before sending the next (default: true)\n   * @returns Promise resolving to action results\n   *\n   * @example\n   * ```typescript\n   * // Sign and send multiple transactions in a batch\n   * const results = await passkeyManager.signAndSendTransactions('alice.near', {\n   *   transactions: [\n   *     {\n   *       receiverId: 'bob.near',\n   *       actions: [{\n   *         action_type: ActionType.Transfer,\n   *         deposit: '1000000000000000000000000'\n   *       }],\n   *     },\n   *     {\n   *       receiverId: 'contract.near',\n   *       actions: [{\n   *         action_type: ActionType.FunctionCall,\n   *         method_name: 'log_transfer',\n   *         args: JSON.stringify({ recipient: 'bob.near' }),\n   *         gas: '30000000000000',\n   *         deposit: '0'\n   *       }],\n   *     }\n   *   ],\n   *   options: {\n   *     onEvent: (event) => console.log('Signing and sending progress:', event)\n   *     executeSequentially: true\n   *   }\n   * });\n   * ```\n   */\n  async signAndSendTransactions({\n    nearAccountId,\n    transactions,\n    options = { executeSequentially: true }\n  }: {\n    nearAccountId: string,\n    transactions: TransactionInput[],\n    options?: SignAndSendTransactionHooksOptions,\n  }): Promise<ActionResult[]> {\n    return signAndSendTransactions({\n      context: this.getContext(),\n      nearAccountId: toAccountId(nearAccountId),\n      transactionInputs: transactions,\n      options\n    }).then(txResults => {\n      const txIds = txResults.map(txResult => txResult.transactionId).join(', ');\n      options?.onEvent?.({\n        step: 9,\n        phase: ActionPhase.STEP_9_ACTION_COMPLETE,\n        status: ActionStatus.SUCCESS,\n        message: `All transactions sent: ${txIds}`\n      });\n      return txResults;\n    });\n  }\n\n  /**\n   * Batch sign transactions (with actions), allows you to sign transactions\n   * to different receivers with a single TouchID prompt.\n   * This method does not broadcast transactions, use sendTransaction() to do that.\n   *\n   * This method fetches the current nonce and increments it for the next N transactions,\n   * so you do not need to manually increment the nonce for each transaction.\n   *\n   * @param nearAccountId - NEAR account ID to sign transactions with\n   * @param params - Transaction signing parameters\n   * - @param params.transactions: Array of transaction objects with nearAccountId, receiverId, actions, and nonce\n   * - @param params.onEvent: Optional progress event callback\n   * @returns Promise resolving to signed transaction results\n   *\n   * @example\n   * ```typescript\n   * // Sign a single transaction\n   * const signedTransactions = await passkeyManager.signTransactionsWithActions('alice.near', {\n   *   transactions: [{\n   *     receiverId: 'bob.near',\n   *     actions: [{\n   *       action_type: ActionType.Transfer,\n   *       deposit: '1000000000000000000000000'\n   *     }],\n   *   }],\n   *   onEvent: (event) => console.log('Signing progress:', event)\n   * });\n   *\n   * // Sign multiple transactions in a batch\n   * const signedTransactions = await passkeyManager.signTransactionsWithActions('alice.near', {\n   *   transactions: [\n   *     {\n   *       receiverId: 'bob.near',\n   *       actions: [{\n   *         action_type: ActionType.Transfer,\n   *         deposit: '1000000000000000000000000'\n   *       }],\n   *     },\n   *     {\n   *       receiverId: 'contract.near',\n   *       actions: [{\n   *         action_type: ActionType.FunctionCall,\n   *         method_name: 'log_transfer',\n   *         args: JSON.stringify({ recipient: 'bob.near' }),\n   *         gas: '30000000000000',\n   *         deposit: '0'\n   *       }],\n   *     }\n   *   ]\n   * });\n   * ```\n   */\n  async signTransactionsWithActions({ nearAccountId, transactions, options }: {\n    nearAccountId: string,\n    transactions: TransactionInput[],\n    options?: ActionHooksOptions\n  }): Promise<VerifyAndSignTransactionResult[]> {\n    // If a service iframe is initialized, route signing via wallet origin\n    if (this.serviceClient) {\n      const txs = transactions.map((t) => ({ receiverId: t.receiverId, actions: t.actions }));\n      const result = await this.serviceClient.signTransactionsWithActions({\n        nearAccountId,\n        txSigningRequests: txs,\n        // Optional: we could forward confirmation config overrides here later\n      });\n      // Expect the wallet to return an array compatible with VerifyAndSignTransactionResult[]\n      return (result?.signedTransactions || result || []) as VerifyAndSignTransactionResult[];\n    }\n    return signTransactionsWithActions({\n      context: this.getContext(),\n      nearAccountId: toAccountId(nearAccountId),\n      transactionInputs: transactions,\n      options\n    });\n  }\n\n  /**\n   * Send a signed transaction to the NEAR network\n   * This method broadcasts a previously signed transaction and waits for execution\n   *\n   * @param signedTransaction - The signed transaction to broadcast\n   * @param waitUntil - The execution status to wait for (defaults to FINAL)\n   * @returns Promise resolving to the transaction execution outcome\n   *\n   * @example\n   * ```typescript\n   * // Sign a transaction first\n   * const signedTransactions = await passkeyManager.signTransactionsWithActions('alice.near', {\n   *   transactions: [{\n   *     receiverId: 'bob.near',\n   *     actions: [{\n   *       action_type: ActionType.Transfer,\n   *       deposit: '1000000000000000000000000'\n   *     }],\n   *   }]\n   * });\n   *\n   * // Then broadcast it\n   * const result = await passkeyManager.sendTransaction(\n   *   signedTransactions[0].signedTransaction,\n   *   TxExecutionStatus.FINAL\n   * );\n   * console.log('Transaction ID:', result.transaction_outcome?.id);\n   * ```\n   */\n  async sendTransaction({ signedTransaction, options }: {\n    signedTransaction: SignedTransaction,\n    options?: SendTransactionHooksOptions\n  }): Promise<ActionResult> {\n    return sendTransaction({ context: this.getContext(), signedTransaction, options })\n    .then(txResult => {\n      options?.onEvent?.({\n        step: 9,\n        phase: ActionPhase.STEP_9_ACTION_COMPLETE,\n        status: ActionStatus.SUCCESS,\n        message: `Transaction ${txResult.transactionId} broadcasted`\n      });\n      return txResult;\n    });\n  }\n\n  ///////////////////////////////////////\n  // === NEP-413 MESSAGE SIGNING ===\n  ///////////////////////////////////////\n\n  /**\n   * Sign a NEP-413 message using the user's passkey-derived private key\n   *\n   * This function implements the NEP-413 standard for off-chain message signing:\n   * - Creates a payload with message, recipient, nonce, and state\n   * - Serializes using Borsh\n   * - Adds NEP-413 prefix (2^31 + 413)\n   * - Hashes with SHA-256\n   * - Signs with Ed25519\n   * - Returns base64-encoded signature\n   *\n   * @param nearAccountId - NEAR account ID to sign with\n   * @param params - NEP-413 signing parameters\n   * - message: string - The message to sign\n   * - recipient: string - The recipient of the message\n   * - state: string - Optional state parameter\n   * @param options - Action options for event handling\n   * - onEvent: EventCallback<ActionSSEEvent> - Optional event callback\n   * - onError: (error: Error) => void - Optional error callback\n   * - hooks: OperationHooks - Optional operation hooks\n   * - waitUntil: TxExecutionStatus - Optional waitUntil status\n   * @returns Promise resolving to signing result\n   *\n   * @example\n   * ```typescript\n   * const result = await passkeyManager.signNEP413Message('alice.near', {\n   *   message: 'Hello World',\n   *   recipient: 'app.example.com',\n   *   state: 'optional-state'\n   * });\n   *\n   * if (result.success) {\n   *   console.log('Signature:', result.signature);\n   *   console.log('Public key:', result.publicKey);\n   * }\n   * ```\n   */\n  async signNEP413Message(args: {\n    nearAccountId: string,\n    params: SignNEP413MessageParams,\n    options?: BaseHooksOptions\n  }): Promise<SignNEP413MessageResult> {\n    // Route via wallet service if available for stronger isolation\n    if (this.serviceClient) {\n      const payload = {\n        nearAccountId: args.nearAccountId,\n        message: args.params.message,\n        recipient: args.params.recipient,\n        state: args.params.state,\n      };\n      const result = await this.serviceClient.signNep413Message(payload);\n      // Expect wallet to return the same shape as WebAuthnManager.signNEP413Message\n      return result as SignNEP413MessageResult;\n    }\n    return signNEP413Message({\n      context: this.getContext(),\n      nearAccountId: toAccountId(args.nearAccountId),\n      params: args.params,\n      options: args.options\n    });\n  }\n\n  ///////////////////////////////////////\n  // === KEY MANAGEMENT ===\n  ///////////////////////////////////////\n\n  /**\n   * Export key pair (both private and public keys)\n   * Uses AccountId for consistent PRF salt derivation\n   */\n  async exportNearKeypairWithTouchId(nearAccountId: string): Promise<{\n    accountId: string;\n    privateKey: string;\n    publicKey: string\n  }> {\n    // Export private key using the method above\n    return await this.webAuthnManager.exportNearKeypairWithTouchId(toAccountId(nearAccountId))\n  }\n\n  ///////////////////////////////////////\n  // === Account Recovery Flow ===\n  ///////////////////////////////////////\n\n  /**\n   * Creates an AccountRecoveryFlow instance, for step-by-step account recovery UX\n   *\n   * @example\n   * ```typescript\n   * const flow = passkeyManager.startAccountRecoveryFlow();\n   *\n   * // Phase 1: Discover available accounts\n   * const options = await flow.discover(); // Returns PasskeyOptionWithoutCredential[]\n   *\n   * // Phase 2: User selects account in UI\n   * const selectedOption = await waitForUserSelection(options);\n   *\n   * // Phase 3: Execute recovery with secure credential lookup\n   * const result = await flow.recover({\n   *   credentialId: selectedOption.credentialId,\n   *   accountId: selectedOption.accountId\n   * });\n   * console.log('Recovery state:', flow.getState());\n   * ```\n   */\n  startAccountRecoveryFlow(options?: AccountRecoveryHooksOptions): AccountRecoveryFlow {\n    return new AccountRecoveryFlow(this.getContext(), options);\n  }\n\n  ///////////////////////////////////////\n  // === Link Device ===\n  ///////////////////////////////////////\n\n  /**\n   * Creates a LinkDeviceFlow instance for step-by-step device linking UX\n   * for Device2 (the companion device is the one that generates the QR code)\n   * Device1 (the original device) scans the QR code and executes the AddKey\n   * and `store_device_linking_mapping` contract calls.\n   *\n   * @example\n   * ```typescript\n   *\n   * // Device2: First generates a QR code and start polling\n   * const device2Flow = passkeyManager.startDeviceLinkingFlow({ onEvent: ... });\n   * const { qrData, qrCodeDataURL } = await device2Flow.generateQR('alice.near');\n   *\n   * // Device1: Scan QR and automatically link device\n   * const device1Flow = passkeyManager.createScanQRCodeFlow({\n   *   deviceLinkingOptions: {\n   *     fundingAmount: '5000000000000000000000',\n   *     onEvent: (event) => console.log('Device linking:', event)\n   *   }\n   * });\n   * device1Flow.attachVideoElement(videoRef.current);\n   * await device1Flow.start(); // Automatically links when QR is detected\n   *\n   * // Device2: Flow automatically completes when AddKey is detected\n   * // it polls the chain for `store_device_linking_mapping` contract events\n   * const state = device2Flow.getState();\n   * ```\n   */\n  startDeviceLinkingFlow(options: StartDeviceLinkingOptionsDevice2): LinkDeviceFlow {\n    return new LinkDeviceFlow(this.getContext(), options);\n  }\n\n    /**\n   * Device1: Create a ScanQRCodeFlow for QR scanning with custom QR detection handling\n   * Provides a flexible flow that scans for QR codes and calls your custom handler when detected\n   *\n   * @param options Configuration for device linking and QR scanning\n   * @param options.deviceLinkingOptions Options for the device linking process (funding, callbacks)\n   * @param options.scanQRCodeFlowOptions Optional QR scanning configuration (camera, timeout)\n   * @param options.scanQRCodeFlowEvents Optional event handlers for scanning progress and QR detection\n   *\n   * @example\n   * ```typescript\n   * const flow = passkeyManager.createScanQRCodeFlow({\n   *   deviceLinkingOptions: {\n   *     fundingAmount: '5000000000000000000000', // 0.005 NEAR\n   *     onEvent: (event) => console.log('Device linking event:', event),\n   *     onError: (error) => console.error('Device linking error:', error)\n   *   },\n   *   scanQRCodeFlowOptions: {\n   *     cameraId: 'camera1',\n   *     timeout: 30000\n   *   },\n   *   scanQRCodeFlowEvents: {\n   *     onQRDetected: async (qrData) => {\n   *       // Handle QR detection - automatically link the device\n   *       console.log('QR detected:', qrData);\n   *       const result = await passkeyManager.linkDeviceWithQRCode(qrData, {\n   *         fundingAmount: '5000000000000000000000',\n   *         onEvent: (event) => console.log('Device linking:', event),\n   *         onError: (error) => console.error('Linking error:', error)\n   *       });\n   *       console.log('Device linked successfully:', result);\n   *     },\n   *     onScanProgress: (duration) => console.log('Scanning for', duration, 'ms'),\n   *     onCameraReady: (stream) => console.log('Camera ready')\n   *   }\n   * });\n   *\n   * // Attach to video element and start scanning\n   * flow.attachVideoElement(videoRef.current);\n   * await flow.start();\n   *\n   * // QR detection and device linking is handled by your onQRDetected callback\n   * ```\n   */\n  createScanQRCodeFlow(\n    options: {\n      deviceLinkingOptions: ScanAndLinkDeviceOptionsDevice1;\n      scanQRCodeFlowOptions?: ScanQRCodeFlowOptions;\n      scanQRCodeFlowEvents?: ScanQRCodeFlowEvents;\n      cameraConfigs?: {\n        facingMode?: 'user' | 'environment';\n        width?: number;\n        height?: number;\n      };\n      timeout?: number;\n    }\n  ): ScanQRCodeFlow {\n    return new ScanQRCodeFlow(\n      {\n        cameraId: options?.scanQRCodeFlowOptions?.cameraId,\n        cameraConfigs: {\n          facingMode: getOptimalCameraFacingMode(),\n          ...options?.cameraConfigs\n        },\n        timeout: 20000 // 20 seconds waiting for QR camera\n      },\n      {\n        onQRDetected: (qrData) => {\n          options?.scanQRCodeFlowEvents?.onQRDetected?.(qrData);\n        },\n        onError: (err) => {\n          console.error('useQRCamera: QR scan error -', err);\n          options?.scanQRCodeFlowEvents?.onError?.(err);\n        },\n        onCameraReady: (stream) => {\n          // Camera stream is ready, but video element attachment is handled separately\n          options?.scanQRCodeFlowEvents?.onCameraReady?.(stream);\n        },\n        onScanProgress: (duration) => {\n          options?.scanQRCodeFlowEvents?.onScanProgress?.(duration);\n        }\n      }\n    );\n  }\n\n  /**\n   * Device1: Link device using pre-scanned QR data.\n   * Either use a QR scanning library, or call this function in\n   * the onQRDetected(qrData) => {} callback of createScanQRCodeFlow.\n   *\n   * @param qrData The QR data obtained from scanning Device2's QR code\n   * @param options Device linking options including funding amount and event callbacks\n   * @returns Promise that resolves to the linking result\n   *\n   * @example\n   * ```typescript\n   * // If you have QR data from somewhere else (not from createScanQRCodeFlow)\n   * const qrData = await passkeyManager.scanQRCodeWithCamera();\n   * const result = await passkeyManager.linkDeviceWithQRCode(qrData, {\n   *   fundingAmount: '5000000000000000000000', // 0.005 NEAR\n   *   onEvent: (event) => console.log('Device linking event:', event),\n   *   onError: (error) => console.error('Device linking error:', error)\n   * });\n   * console.log('Device linked:', result);\n   * ```\n   *\n   * Or with createScanQRCodeFlow:\n   *\n   * @example\n   * ```typescript\n   * const flow = passkeyManager.createScanQRCodeFlow({\n   *   ...\n   *   scanQRCodeFlowEvents: {\n   *     onQRDetected: async (qrData) => {\n   *       const result = await passkeyManager.linkDeviceWithQRCode(qrData, {\n   *         fundingAmount: '5000000000000000000000',\n   *         onEvent: (event) => console.log('Device linking:', event),\n   *         onError: (error) => console.error('Linking error:', error)\n   *       });\n   *     },\n   *     ...\n   *   }\n   * });\n   * ```\n   */\n  async linkDeviceWithQRCode(\n    qrData: DeviceLinkingQRData,\n    options: ScanAndLinkDeviceOptionsDevice1\n  ): Promise<LinkDeviceResult> {\n    return linkDeviceWithQRCode(this.getContext(), qrData, options);\n  }\n\n  /**\n   * Delete a device key from an account\n   */\n  async deleteDeviceKey(\n    accountId: string,\n    publicKeyToDelete: string,\n    options?: ActionHooksOptions\n  ): Promise<ActionResult> {\n    // Validate that we're not deleting the last key\n    const keysView = await this.nearClient.viewAccessKeyList(toAccountId(accountId));\n    if (keysView.keys.length <= 1) {\n      throw new Error('Cannot delete the last access key from an account');\n    }\n\n    // Find the key to delete\n    const keyToDelete = keysView.keys.find(k => k.public_key === publicKeyToDelete);\n    if (!keyToDelete) {\n      throw new Error(`Access key ${publicKeyToDelete} not found on account ${accountId}`);\n    }\n\n    // Use the executeAction method with DeleteKey action\n    return this.executeAction({\n      nearAccountId: accountId,\n      receiverId: accountId,\n      actionArgs: {\n        type: ActionType.DeleteKey,\n        publicKey: publicKeyToDelete\n      },\n      options: options\n    });\n  }\n\n}\n\n// Re-export types for convenience\nexport type {\n  PasskeyManagerConfigs,\n  RegistrationHooksOptions,\n  RegistrationResult,\n  RegistrationSSEEvent,\n  LoginHooksOptions,\n  LoginResult,\n  LoginSSEvent,\n  BaseHooksOptions,\n  ActionHooksOptions,\n  ActionResult,\n  EventCallback,\n  OperationHooks,\n} from '../types/passkeyManager';\n\nexport type {\n  DeviceLinkingQRData,\n  DeviceLinkingSession,\n  LinkDeviceResult\n} from '../types/linkDevice';\n\n// Re-export device linking error types and classes\nexport {\n  DeviceLinkingPhase,\n  DeviceLinkingError,\n  DeviceLinkingErrorCode\n} from '../types/linkDevice';\n\n// Re-export device linking flow class\nexport {\n  LinkDeviceFlow\n} from './linkDevice';\n\n// Re-export account recovery types and classes\nexport type {\n  RecoveryResult,\n  AccountLookupResult,\n  PasskeyOption,\n  PasskeyOptionWithoutCredential,\n  PasskeySelection\n} from './recoverAccount';\n\nexport {\n  AccountRecoveryFlow\n} from './recoverAccount';\n\n// Re-export NEP-413 types\nexport type {\n  SignNEP413MessageParams,\n  SignNEP413MessageResult\n} from './signNEP413';\n\n// Re-export QR scanning flow\nexport {\n  ScanQRCodeFlow,\n  type ScanQRCodeFlowOptions,\n  type ScanQRCodeFlowEvents,\n  ScanQRCodeFlowState\n} from '../../utils/qrScanner';\n"],"mappings":"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"}