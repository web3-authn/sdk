{"version":3,"file":"registration.js","names":["vrfChallenge","deterministicVrfKeyResult","nearKeyResult","canRegisterUserResult","error: any","viewError: any","deleteError: any","rollbackError: any"],"sources":["../../../../../../../../src/core/PasskeyManager/registration.ts"],"sourcesContent":["import type { NearClient, SignedTransaction } from '../NearClient';\nimport { MinimalNearClient } from '../NearClient';\nimport { validateNearAccountId } from '../../utils/validation';\nimport type {\n  RegistrationHooksOptions,\n  RegistrationResult,\n  RegistrationSSEEvent,\n} from '../types/passkeyManager';\nimport type { AuthenticatorOptions } from '../types/authenticatorOptions';\nimport { RegistrationPhase, RegistrationStatus } from '../types/passkeyManager';\nimport { createAccountAndRegisterWithRelayServer } from './faucets/createAccountRelayServer';\nimport { createAccountAndRegisterWithTestnetFaucet } from './faucets/createAccountTestnetFaucet';\nimport { WebAuthnManager } from '../WebAuthnManager';\nimport { VRFChallenge } from '../types/vrf-worker';\nimport type { PasskeyManagerContext } from './index';\nimport type { AccountId } from '../types/accountIds';\nimport { base64UrlEncode } from '../../utils/encoders';\nimport { getUserFriendlyErrorMessage } from '../../utils/errors';\n\n/**\n * Core registration function that handles passkey registration\n *\n * VRF Registration Flow (Single VRF Keypair):\n * 1. Generate VRF keypair (ed25519) using crypto.randomUUID() + persist in worker memory\n * 2. Generate VRF proof + output using the VRF keypair\n *    - VRF input with domain separator + NEAR block height + hash\n * 3. Use VRF output as WebAuthn challenge in registration ceremony\n * 4. Derive AES key from WebAuthn PRF output and encrypt the SAME VRF keypair\n * 5. Store encrypted VRF keypair in IndexedDB\n * 6. Call contract verify_registration_response with VRF proof + WebAuthn registration payload\n * 7. Contract verifies VRF proof and WebAuthn registration (challenges match!)\n * 8. Contract stores VRF pubkey + authenticator credentials on-chain for\n *    future stateless authentication\n */\nexport async function registerPasskey(\n  context: PasskeyManagerContext,\n  nearAccountId: AccountId,\n  options: RegistrationHooksOptions,\n  authenticatorOptions: AuthenticatorOptions\n): Promise<RegistrationResult> {\n\n  const { onEvent, onError, hooks, useRelayer } = options;\n  const { webAuthnManager, configs } = context;\n\n  // Track registration progress for rollback\n  const registrationState = {\n    accountCreated: false,\n    contractRegistered: false,\n    databaseStored: false,\n    contractTransactionId: null as string | null,\n    preSignedDeleteTransaction: null as SignedTransaction | null,\n  };\n\n  console.log('⚡ Registration: Passkey registration with VRF WebAuthn ceremony');\n  // Emit started event\n  onEvent?.({\n    step: 1,\n    phase: RegistrationPhase.STEP_1_WEBAUTHN_VERIFICATION,\n    status: RegistrationStatus.PROGRESS,\n    message: `Starting registration for ${nearAccountId}`\n  } as RegistrationSSEEvent);\n\n  try {\n    // Run beforeCall hook\n    await hooks?.beforeCall?.();\n\n    // Validate registration inputs\n    await validateRegistrationInputs(context, nearAccountId, onEvent, onError);\n\n    onEvent?.({\n      step: 1,\n      phase: RegistrationPhase.STEP_1_WEBAUTHN_VERIFICATION,\n      status: RegistrationStatus.PROGRESS,\n      message: 'Account available - generating VRF credentials...'\n    });\n\n    // Step 1: Generate bootstrap VRF challenge for WebAuthn ceremony\n    // (temporary, replaced later with determinisitic VRF keypair)\n    const { vrfChallenge } = await Promise.all([\n      validateRegistrationInputs(context, nearAccountId, onEvent, onError),\n      generateBootstrapVrfChallenge(context, nearAccountId),\n    ]).then(([_, vrfChallenge]) => ({ vrfChallenge }));\n\n    // Step 2: WebAuthn registration ceremony with PRF (TouchID)\n    onEvent?.({\n      step: 1,\n      phase: RegistrationPhase.STEP_1_WEBAUTHN_VERIFICATION,\n      status: RegistrationStatus.PROGRESS,\n      message: 'Performing WebAuthn registration with VRF challenge...'\n    });\n\n    const credential = await webAuthnManager.generateRegistrationCredentials({\n      nearAccountId: nearAccountId,\n      challenge: vrfChallenge,\n    });\n\n    onEvent?.({\n      step: 1,\n      phase: RegistrationPhase.STEP_1_WEBAUTHN_VERIFICATION,\n      status: RegistrationStatus.SUCCESS,\n      message: 'WebAuthn ceremony successful, PRF output obtained'\n    });\n\n    // Steps 3-4: Encrypt VRF keypair, derive NEAR keypair, and check registration in parallel\n    const {\n      deterministicVrfKeyResult,\n      nearKeyResult,\n      canRegisterUserResult,\n    } = await Promise.all([\n      // Generate deterministic VRF keypair from PRF output for recovery\n      webAuthnManager.deriveVrfKeypair({\n        credential,\n        nearAccountId,\n        saveInMemory: true, // Save in worker memory so it can be used for challenge generation\n      }),\n      webAuthnManager.deriveNearKeypairAndEncrypt({\n        credential,\n        nearAccountId\n      }),\n      webAuthnManager.checkCanRegisterUser({\n        contractId: context.configs.contractId,\n        credential: credential,\n        vrfChallenge: vrfChallenge,\n        onEvent: (progress) => {\n          console.debug(`Registration progress: ${progress.step} - ${progress.message}`);\n          onEvent?.({\n            step: 4,\n            phase: RegistrationPhase.STEP_4_ACCOUNT_VERIFICATION,\n            status: RegistrationStatus.PROGRESS,\n            message: `Checking registration: ${progress.message}`\n          });\n        },\n      }),\n    ]).then(([deterministicVrfKeyResult, nearKeyResult, canRegisterUserResult]) => {\n      if (!deterministicVrfKeyResult.success || !deterministicVrfKeyResult.vrfPublicKey) {\n        throw new Error('Failed to derive deterministic VRF keypair from PRF');\n      }\n      if (!nearKeyResult.success || !nearKeyResult.publicKey) {\n        throw new Error('Failed to generate NEAR keypair with PRF');\n      }\n      if (!canRegisterUserResult.verified) {\n        console.error(canRegisterUserResult);\n        const errorMessage = canRegisterUserResult.error || 'User verification failed - account may already exist or contract is unreachable';\n        throw new Error(`Web3Authn contract registration check failed: ${errorMessage}`);\n      }\n      return {\n        deterministicVrfKeyResult,\n        nearKeyResult,\n        canRegisterUserResult\n      };\n    });\n\n    // Step 5: Create account and register with contract using appropriate flow\n    onEvent?.({\n      step: 2,\n      phase: RegistrationPhase.STEP_2_KEY_GENERATION,\n      status: RegistrationStatus.SUCCESS,\n      message: 'Wallet keys derived successfully from TouchId',\n      verified: true,\n      nearAccountId: nearAccountId,\n      nearPublicKey: nearKeyResult.publicKey,\n      vrfPublicKey: vrfChallenge.vrfPublicKey,\n    });\n\n    let accountAndRegistrationResult;\n    if (useRelayer) {\n      console.debug('Using relay-server registration flow');\n      accountAndRegistrationResult = await createAccountAndRegisterWithRelayServer(\n        context,\n        nearAccountId,\n        nearKeyResult.publicKey,\n        credential,\n        vrfChallenge,\n        deterministicVrfKeyResult.vrfPublicKey,\n        authenticatorOptions,\n        onEvent,\n      );\n    } else {\n      console.debug('Using testnet faucet registration flow');\n      accountAndRegistrationResult = await createAccountAndRegisterWithTestnetFaucet(\n        context,\n        nearAccountId,\n        nearKeyResult.publicKey,\n        credential,\n        vrfChallenge,\n        deterministicVrfKeyResult.vrfPublicKey,\n        authenticatorOptions,\n        onEvent,\n      );\n    }\n\n    if (!accountAndRegistrationResult.success) {\n      throw new Error(accountAndRegistrationResult.error || 'Account creation and registration failed');\n    }\n\n    // Update registration state based on results\n    registrationState.accountCreated = true;\n    registrationState.contractRegistered = true;\n    registrationState.contractTransactionId = accountAndRegistrationResult.transactionId || null;\n    // Handle preSignedDeleteTransaction based on flow type\n    // => Relayer: no delete transaction is needed via relay (atomic tx)\n    // => Testnet Faucet: delete transaction is needed for rollback\n    registrationState.preSignedDeleteTransaction = null;\n\n    if (!useRelayer) {\n      // For sequential flow, store the delete transaction for rollback\n      registrationState.preSignedDeleteTransaction = accountAndRegistrationResult.preSignedDeleteTransaction;\n      console.debug('Pre-signed delete transaction captured for rollback');\n      // Generate hash for verification/testing\n      if (registrationState.preSignedDeleteTransaction) {\n        const preSignedDeleteTransactionHash = generateTransactionHash(registrationState.preSignedDeleteTransaction);\n        onEvent?.({\n          step: 6,\n          phase: RegistrationPhase.STEP_6_CONTRACT_REGISTRATION,\n          status: RegistrationStatus.PROGRESS,\n          message: `Presigned delete transaction created for rollback (hash: ${preSignedDeleteTransactionHash})`\n        });\n      }\n    }\n\n    // Step 6: Store user data with VRF credentials atomically\n    onEvent?.({\n      step: 5,\n      phase: RegistrationPhase.STEP_5_DATABASE_STORAGE,\n      status: RegistrationStatus.PROGRESS,\n      message: 'Storing VRF registration data'\n    });\n\n    await webAuthnManager.atomicStoreRegistrationData({\n      nearAccountId,\n      credential,\n      publicKey: nearKeyResult.publicKey,\n      encryptedVrfKeypair: deterministicVrfKeyResult.encryptedVrfKeypair,\n      vrfPublicKey: deterministicVrfKeyResult.vrfPublicKey,\n      serverEncryptedVrfKeypair: deterministicVrfKeyResult.serverEncryptedVrfKeypair,\n      onEvent\n    });\n\n    // Mark database as stored for rollback tracking\n    registrationState.databaseStored = true;\n\n    onEvent?.({\n      step: 5,\n      phase: RegistrationPhase.STEP_5_DATABASE_STORAGE,\n      status: RegistrationStatus.SUCCESS,\n      message: 'VRF registration data stored successfully'\n    });\n\n    // Step 7: Unlock VRF keypair in memory for login\n    const unlockResult = await webAuthnManager.unlockVRFKeypair({\n      nearAccountId: nearAccountId,\n      // encryptedVrfKeypair: encryptedVrfResult.encryptedVrfKeypair,\n      encryptedVrfKeypair: deterministicVrfKeyResult.encryptedVrfKeypair,\n      credential: credential,\n    }).catch((unlockError: any) => {\n      console.warn('VRF keypair unlock failed:', unlockError);\n      return { success: false, error: unlockError.message };\n    });\n\n    if (!unlockResult.success) {\n      console.warn('VRF keypair unlock failed:', unlockResult.error);\n      throw new Error(unlockResult.error);\n    }\n\n    onEvent?.({\n      step: 7,\n      phase: RegistrationPhase.STEP_7_REGISTRATION_COMPLETE,\n      status: RegistrationStatus.SUCCESS,\n      message: 'Registration completed successfully'\n    });\n\n    const successResult = {\n      success: true,\n      nearAccountId: nearAccountId,\n      clientNearPublicKey: nearKeyResult.publicKey,\n      transactionId: registrationState.contractTransactionId,\n      vrfRegistration: {\n        success: true,\n        vrfPublicKey: vrfChallenge.vrfPublicKey,\n        // encryptedVrfKeypair: encryptedVrfResult.encryptedVrfKeypair,\n        encryptedVrfKeypair: deterministicVrfKeyResult.encryptedVrfKeypair,\n        contractVerified: accountAndRegistrationResult.success,\n      }\n    };\n\n    hooks?.afterCall?.(true, successResult);\n    return successResult;\n\n  } catch (error: any) {\n    console.error('Registration failed:', error.message, error.stack);\n\n    // Perform rollback based on registration state\n    await performRegistrationRollback(\n      registrationState,\n      nearAccountId,\n      webAuthnManager,\n      configs.nearRpcUrl,\n      onEvent\n    );\n\n    // Use centralized error handling\n    const errorMessage = getUserFriendlyErrorMessage(error, 'registration', nearAccountId);\n\n    const errorObject = new Error(errorMessage);\n    onError?.(errorObject);\n\n    onEvent?.({\n      step: 0,\n      phase: RegistrationPhase.REGISTRATION_ERROR,\n      status: RegistrationStatus.ERROR,\n      message: errorMessage,\n      error: errorMessage\n    } as RegistrationSSEEvent);\n\n    const result = { success: false, error: errorMessage };\n    hooks?.afterCall?.(false, result);\n    return result;\n  }\n}\n\n//////////////////////////////////////\n// HELPER FUNCTIONS\n//////////////////////////////////////\n\n/**\n * Generate a VRF keypair + challenge in VRF wasm worker for WebAuthn registration ceremony bootstrapping\n *\n * ARCHITECTURE: This function solves the chicken-and-egg problem with a single VRF keypair:\n * 1. Generate VRF keypair + challenge (no PRF needed)\n * 2. Persist VRF keypair in worker memory (NOT encrypted yet)\n * 3. Use VRF challenge for WebAuthn ceremony → get PRF output\n * 4. Encrypt the SAME VRF keypair (still in memory) with PRF\n *\n * @param webAuthnManager - WebAuthn manager instance\n * @param nearAccountId - NEAR account ID for VRF input\n * @param blockHeight - Current NEAR block height for freshness\n * @param blockHashBytes - Current NEAR block hash bytes for entropy\n * @returns VRF challenge data (VRF keypair persisted in worker memory)\n */\nexport async function generateBootstrapVrfChallenge(\n  context: PasskeyManagerContext,\n  nearAccountId: AccountId,\n): Promise<VRFChallenge> {\n\n  const { webAuthnManager, nearClient } = context;\n\n  const blockInfo = await nearClient.viewBlock({ finality: 'final' });\n\n  console.log('Generating VRF keypair for registration');\n  // Generate VRF keypair and persist in worker memory\n  const vrfResult = await webAuthnManager.generateVrfKeypairBootstrap(\n    true, // saveInMemory: true - this VRF keypair is persisted in worker memory until PRF encryption\n    {\n      userId: nearAccountId,\n      rpId: window.location.hostname,\n      blockHeight: String(blockInfo.header.height),\n      blockHash: blockInfo.header.hash,\n    }\n  );\n\n  if (!vrfResult.vrfChallenge) {\n    throw new Error('Registration VRF keypair generation failed');\n  }\n  console.log('bootstrap VRF keypair generated and persisted in worker memory');\n  return vrfResult.vrfChallenge;\n}\n\n/**\n * Validates registration inputs and throws errors if invalid\n * @param nearAccountId - NEAR account ID to validate\n * @param onEvent - Optional callback for registration progress events\n * @param onError - Optional callback for error handling\n */\nconst validateRegistrationInputs = async (\n  context: PasskeyManagerContext,\n  nearAccountId: AccountId,\n  onEvent?: (event: RegistrationSSEEvent) => void,\n  onError?: (error: Error) => void,\n) => {\n\n  onEvent?.({\n    step: 1,\n    phase: RegistrationPhase.STEP_1_WEBAUTHN_VERIFICATION,\n    status: RegistrationStatus.PROGRESS,\n    message: 'Validating registration inputs...'\n  } as RegistrationSSEEvent);\n\n  // Validation\n  if (!nearAccountId) {\n    const error = new Error('NEAR account ID is required for registration.');\n    onError?.(error);\n    throw error;\n  }\n  // Validate the account ID format\n  const validation = validateNearAccountId(nearAccountId);\n  if (!validation.valid) {\n    const error = new Error(`Invalid NEAR account ID: ${validation.error}`);\n    onError?.(error);\n    throw error;\n  }\n  if (!window.isSecureContext) {\n    const error = new Error('Passkey operations require a secure context (HTTPS or localhost).');\n    onError?.(error);\n    throw error;\n  }\n\n  // Check if account already exists on-chain\n  onEvent?.({\n    step: 1,\n    phase: RegistrationPhase.STEP_1_WEBAUTHN_VERIFICATION,\n    status: RegistrationStatus.PROGRESS,\n    message: `Checking if account ${nearAccountId} is available...`\n  } as RegistrationSSEEvent);\n\n  try {\n    const accountInfo = await context.nearClient.viewAccount(nearAccountId);\n    // If we get here without an error, the account already exists\n    const error = new Error(`Account ${nearAccountId} already exists. Please choose a different account ID.`);\n    onError?.(error);\n    throw error;\n  } catch (viewError: any) {\n    // If viewAccount throws any error, assume the account doesn't exist\n    // This is more reliable than parsing specific error formats that vary between RPC servers\n    console.log(`Account ${nearAccountId} is available for registration (viewAccount failed: ${viewError.message})`);\n    onEvent?.({\n      step: 1,\n      phase: RegistrationPhase.STEP_1_WEBAUTHN_VERIFICATION,\n      status: RegistrationStatus.PROGRESS,\n      message: `Account ${nearAccountId} is available for registration`\n    } as RegistrationSSEEvent);\n    return; // Continue with registration\n  }\n}\n\n/**\n * Rollback registration data in case of errors\n */\nasync function performRegistrationRollback(\n  registrationState: {\n    accountCreated: boolean;\n    contractRegistered: boolean;\n    databaseStored: boolean;\n    contractTransactionId: string | null;\n    preSignedDeleteTransaction: SignedTransaction | null;\n  },\n  nearAccountId: AccountId,\n  webAuthnManager: WebAuthnManager,\n  rpcNodeUrl: string,\n  onEvent?: (event: RegistrationSSEEvent) => void\n): Promise<void> {\n  console.debug('Starting registration rollback...', registrationState);\n\n  // Rollback in reverse order\n  try {\n    // 3. Rollback database storage\n    if (registrationState.databaseStored) {\n      console.debug('Rolling back database storage...');\n      onEvent?.({\n        step: 0,\n        phase: RegistrationPhase.REGISTRATION_ERROR,\n        status: RegistrationStatus.ERROR,\n        message: 'Rolling back database storage...',\n        error: 'Registration failed - rolling back database storage'\n      } as RegistrationSSEEvent);\n\n      await webAuthnManager.rollbackUserRegistration(nearAccountId);\n      console.debug('Database rollback completed');\n    }\n\n     // 2. Rollback NEAR account (if created)\n    if (registrationState.accountCreated) {\n      console.debug('Rolling back NEAR account...');\n      onEvent?.({\n        step: 0,\n        phase: RegistrationPhase.REGISTRATION_ERROR,\n        status: RegistrationStatus.ERROR,\n        message: `Rolling back NEAR account ${nearAccountId}...`,\n        error: 'Registration failed - attempting account deletion'\n      } as RegistrationSSEEvent);\n\n      if (registrationState.preSignedDeleteTransaction) {\n        console.debug('Broadcasting pre-signed delete transaction for account rollback...');\n        try {\n          // Note: We need to create a new NearClient here since we only have rpcNodeUrl\n          const tempNearClient = new MinimalNearClient(rpcNodeUrl);\n          const deletionResult = await tempNearClient.sendTransaction(registrationState.preSignedDeleteTransaction);\n          const deleteTransactionId = deletionResult?.transaction_outcome?.id;\n          console.debug(`NEAR account ${nearAccountId} deleted successfully via pre-signed transaction`);\n          console.debug(`   Delete transaction ID: ${deleteTransactionId}`);\n\n          onEvent?.({\n            step: 0,\n            phase: RegistrationPhase.REGISTRATION_ERROR,\n            status: RegistrationStatus.ERROR,\n            message: `NEAR account ${nearAccountId} deleted successfully (rollback completed)`,\n            error: 'Registration failed but account rollback completed'\n          } as RegistrationSSEEvent);\n        } catch (deleteError: any) {\n          console.error(`NEAR account deletion failed:`, deleteError);\n          onEvent?.({\n            step: 0,\n            phase: RegistrationPhase.REGISTRATION_ERROR,\n            status: RegistrationStatus.ERROR,\n            message: `️NEAR account ${nearAccountId} could not be deleted: ${deleteError.message}. Account will remain on testnet.`,\n            error: 'Registration failed - account deletion failed'\n          } as RegistrationSSEEvent);\n        }\n      } else {\n        console.debug(`No pre-signed delete transaction available for ${nearAccountId}. Account will remain on testnet.`);\n        onEvent?.({\n          step: 0,\n          phase: RegistrationPhase.REGISTRATION_ERROR,\n          status: RegistrationStatus.ERROR,\n          message: `️NEAR account ${nearAccountId} could not be deleted: No pre-signed transaction available. Account will remain on testnet.`,\n          error: 'Registration failed - no rollback transaction available'\n        } as RegistrationSSEEvent);\n      }\n    }\n\n    // 1. Contract rollback on the Web3Authn contract is not possible at the moment. No authenticator deletion functions exposed yet.\n    // However if a user retries with the same accountID, they can overwrite the old authenticator entry linked to the accountID\n    if (registrationState.contractRegistered) {\n      console.debug('Contract registration cannot be rolled back (immutable blockchain state)');\n      onEvent?.({\n        step: 0,\n        phase: RegistrationPhase.REGISTRATION_ERROR,\n        status: RegistrationStatus.ERROR,\n        message: `Contract registration (tx: ${registrationState.contractTransactionId}) cannot be rolled back`,\n        error: 'Registration failed - contract state is immutable'\n      } as RegistrationSSEEvent);\n    }\n\n    console.debug('Registration rollback completed');\n\n  } catch (rollbackError: any) {\n    console.error('Rollback failed:', rollbackError);\n    onEvent?.({\n      step: 0,\n      phase: RegistrationPhase.REGISTRATION_ERROR,\n      status: RegistrationStatus.ERROR,\n      message: `Rollback failed: ${rollbackError.message}`,\n      error: 'Both registration and rollback failed'\n    } as RegistrationSSEEvent);\n  }\n}\n\n/**\n * Generate a hash of a signed transaction for verification purposes\n * Uses the borsh bytes of the transaction to create a consistent hash\n */\nfunction generateTransactionHash(signedTransaction: SignedTransaction): string {\n  try {\n    // Use the borsh_bytes which contain the serialized transaction data\n    const transactionBytes = new Uint8Array(signedTransaction.borsh_bytes);\n\n    // Create a simple hash using crypto.subtle (available in secure contexts)\n    // For testing purposes, we'll use a truncated hash of the borsh bytes\n    const hashInput = Array.from(transactionBytes).join(',');\n\n    // Create a deterministic hash by taking first 16 chars of base64 encoding\n    const hash = base64UrlEncode(new TextEncoder().encode(hashInput).buffer).substring(0, 16);\n\n    return hash;\n  } catch (error) {\n    console.warn('Failed to generate transaction hash:', error);\n    return 'hash-generation-failed';\n  }\n}"],"mappings":"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"}