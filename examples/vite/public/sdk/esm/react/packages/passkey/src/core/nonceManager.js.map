{"version":3,"file":"nonceManager.js","names":["transactionContext: TransactionContext","now","planned: string[]","newLast: bigint | null"],"sources":["../../../../../../../src/core/nonceManager.ts"],"sourcesContent":["import type { NearClient } from './NearClient';\nimport type { AccountId } from './types/accountIds';\nimport { fetchNonceBlockHashAndHeight } from './rpcCalls';\nimport type { TransactionContext } from './types/rpc';\n\n/**\n * NonceManager - Singleton for managing NEAR transaction context\n *\n * This class pre-fetches nonce and block height asynchronously at the start\n * of executeAction calls to avoid blocking renderUserConfirmUI().\n *\n * The manager is cleared on logout and instantiated with new user on login.\n */\nexport class NonceManager {\n  private static instance: NonceManager | null = null;\n\n  public lastNonceUpdate: number | null = null;\n  public lastBlockHeightUpdate: number | null = null;\n  public nearAccountId: AccountId | null = null;\n  public nearPublicKeyStr: string | null = null;\n  public transactionContext: TransactionContext | null = null;\n  private inflightFetch: Promise<TransactionContext> | null = null;\n  private refreshTimer: ReturnType<typeof setTimeout> | null = null;\n  private prefetchTimer: ReturnType<typeof setTimeout> | null = null;\n\n  // Nonce reservation system for batch transactions\n  private reservedNonces: Set<string> = new Set();\n  private lastReservedNonce: string | null = null;\n\n  // Freshness thresholds (ms)\n  private readonly NONCE_FRESHNESS_THRESHOLD = 20 * 1000; // 20 seconds\n  private readonly BLOCK_FRESHNESS_THRESHOLD = 10 * 1000; // 10 seconds\n  private readonly PREFETCH_DEBOUNCE_MS = 150; // small debounce to avoid hover spam\n\n  // Private constructor for singleton pattern\n  private constructor() {}\n\n  /**\n   * Get singleton instance\n   */\n  public static getInstance(): NonceManager {\n    if (!NonceManager.instance) {\n      NonceManager.instance = new NonceManager();\n    }\n    return NonceManager.instance;\n  }\n\n  /**\n   * Prefetch block height/hash (and nonce if missing) in the background.\n   * - If block info is stale or context missing, triggers a non-blocking refresh.\n   * - Safe to call frequently (coalesces concurrent fetches).\n   */\n  public async prefetchBlockheight(nearClient: NearClient): Promise<void> {\n    if (!this.nearAccountId || !this.nearPublicKeyStr) return;\n    // Debounce prefetch to avoid repeated calls on quick hover/focus toggles\n    this.clearPrefetchTimer();\n    this.prefetchTimer = setTimeout(async () => {\n      this.prefetchTimer = null;\n      if (this.inflightFetch) return; // already fetching\n\n      const now = Date.now();\n      const isBlockStale = !this.lastBlockHeightUpdate || (now - this.lastBlockHeightUpdate) >= this.BLOCK_FRESHNESS_THRESHOLD;\n      const missingContext = !this.transactionContext;\n      if (!isBlockStale && !missingContext) return;\n\n      try {\n        await this.fetchFreshData(nearClient);\n      } catch (e) {\n        // Swallow errors during prefetch; runtime path will retry as needed\n        console.debug('[NonceManager]: prefetchBlockheight ignored error:', e);\n      }\n    }, this.PREFETCH_DEBOUNCE_MS);\n  }\n\n  /**\n   * Initialize or update the manager with user information\n   */\n  public initializeUser(nearAccountId: AccountId, nearPublicKeyStr: string): void {\n    this.nearAccountId = nearAccountId;\n    this.nearPublicKeyStr = nearPublicKeyStr;\n    this.clearTransactionContext();\n  }\n\n  /**\n   * Clear all data when user logs out\n   */\n  public clear(): void {\n    this.lastNonceUpdate = null;\n    this.lastBlockHeightUpdate = null;\n    this.nearAccountId = null;\n    this.nearPublicKeyStr = null;\n    this.transactionContext = null;\n    this.clearRefreshTimer();\n    this.clearPrefetchTimer();\n    this.inflightFetch = null;\n    this.reservedNonces.clear();\n    this.lastReservedNonce = null;\n  }\n\n  /**\n   * Smart caching method for nonce and block height data\n   * Returns cached data if fresh, otherwise fetches synchronously\n   */\n  public async getNonceBlockHashAndHeight(nearClient: NearClient): Promise<TransactionContext> {\n    if (!this.nearAccountId || !this.nearPublicKeyStr) {\n      throw new Error('NonceManager not initialized with user data');\n    }\n\n    const now = Date.now();\n    // Check if both nonce and block height data are fresh\n    const isNonceFresh = !!this.lastNonceUpdate && (now - this.lastNonceUpdate) < this.NONCE_FRESHNESS_THRESHOLD;\n    const isBlockHeightFresh = !!this.lastBlockHeightUpdate && (now - this.lastBlockHeightUpdate) < this.BLOCK_FRESHNESS_THRESHOLD;\n\n    // If both are fresh, return cached data and schedule async refresh\n    if (isNonceFresh && isBlockHeightFresh && this.transactionContext) {\n      // Gate background refresh: only schedule if approaching staleness and no inflight fetch\n      this.maybeScheduleBackgroundRefresh(nearClient);\n      return this.transactionContext;\n    }\n\n    // If either is stale, fetch synchronously and return fresh data\n    console.debug('[NonceManager]: Data is stale, fetching synchronously');\n    return await this.fetchFreshData(nearClient);\n  }\n\n  /**\n   * Schedule an asynchronous refresh of the transaction context\n   */\n  private maybeScheduleBackgroundRefresh(nearClient: NearClient): void {\n    if (!this.lastNonceUpdate || !this.lastBlockHeightUpdate) return;\n    if (this.inflightFetch) return; // already fetching\n\n    const now = Date.now();\n    const nonceAge = now - this.lastNonceUpdate;\n    const blockAge = now - this.lastBlockHeightUpdate;\n\n    const halfNonceTtl = this.NONCE_FRESHNESS_THRESHOLD / 2;\n    const halfBlockTtl = this.BLOCK_FRESHNESS_THRESHOLD / 2;\n\n    // If we're past the half-life for either value, refresh NOW in background\n    if (nonceAge >= halfNonceTtl || blockAge >= halfBlockTtl) {\n      this.clearRefreshTimer();\n      // Fire-and-forget refresh to keep cache warm\n      void this.fetchFreshData(nearClient)\n        .then(() => console.debug('[NonceManager]: Background refresh completed'))\n        .catch((error) => console.warn('[NonceManager]: Background refresh failed:', error));\n      return;\n    }\n\n    // Otherwise, schedule a refresh for when the earliest metric hits half-life\n    const delayToHalfNonce = Math.max(0, halfNonceTtl - nonceAge);\n    const delayToHalfBlock = Math.max(0, halfBlockTtl - blockAge);\n    const delay = Math.min(delayToHalfNonce, delayToHalfBlock);\n\n    // Avoid multiple timers\n    this.clearRefreshTimer();\n    this.refreshTimer = setTimeout(() => {\n      this.refreshTimer = null;\n      if (this.inflightFetch) return;\n      void this.fetchFreshData(nearClient)\n        .then(() => console.debug('[NonceManager]: Background refresh completed'))\n        .catch((error) => console.warn('[NonceManager]: Background refresh failed:', error));\n    }, delay);\n  }\n\n  /**\n   * Fetch fresh transaction context data from NEAR RPC\n   */\n  private async fetchFreshData(nearClient: NearClient): Promise<TransactionContext> {\n    // Coalesce concurrent fetches\n    if (this.inflightFetch) return this.inflightFetch;\n\n    const capturedAccountId = this.nearAccountId;\n    const capturedPublicKey = this.nearPublicKeyStr;\n\n    this.inflightFetch = (async () => {\n      try {\n        // Determine what is actually stale so we only fetch what we need\n        const now = Date.now();\n        const isNonceStale = !this.lastNonceUpdate || (now - this.lastNonceUpdate) >= this.NONCE_FRESHNESS_THRESHOLD;\n        const isBlockStale = !this.lastBlockHeightUpdate || (now - this.lastBlockHeightUpdate) >= this.BLOCK_FRESHNESS_THRESHOLD;\n\n        let accessKeyInfo = this.transactionContext?.accessKeyInfo;\n        let txBlockHeight = this.transactionContext?.txBlockHeight;\n        let txBlockHash = this.transactionContext?.txBlockHash;\n\n        const fetchAccessKey = isNonceStale || !accessKeyInfo;\n        const fetchBlock = isBlockStale || !txBlockHeight || !txBlockHash;\n\n        // Fetch required parts in parallel\n        const [maybeAccessKey, maybeBlock] = await Promise.all([\n          fetchAccessKey ? nearClient.viewAccessKey(capturedAccountId!, capturedPublicKey!) : Promise.resolve(null),\n          fetchBlock ? nearClient.viewBlock({ finality: 'final' }) : Promise.resolve(null)\n        ]);\n\n        if (fetchAccessKey) {\n          if (!maybeAccessKey || (maybeAccessKey as any).nonce === undefined) {\n            throw new Error(`Access key not found or invalid for account ${capturedAccountId} with public key ${capturedPublicKey}.`);\n          }\n          accessKeyInfo = maybeAccessKey!;\n        }\n\n        if (fetchBlock) {\n          const blockInfo = maybeBlock as any;\n          if (!blockInfo?.header?.hash || blockInfo?.header?.height === undefined) {\n            throw new Error('Failed to fetch Block Info');\n          }\n          txBlockHeight = String(blockInfo.header.height);\n          txBlockHash = blockInfo.header.hash;\n        }\n\n        // Derive nextNonce from access key info + current context + reservations\n        const nextNonce = this.maxBigInt(\n          BigInt(accessKeyInfo!.nonce) + 1n,\n          this.transactionContext?.nextNonce ? BigInt(this.transactionContext.nextNonce) : 0n,\n          this.lastReservedNonce ? BigInt(this.lastReservedNonce) + 1n : 0n\n        ).toString();\n\n        const transactionContext: TransactionContext = {\n          nearPublicKeyStr: capturedPublicKey!,\n          accessKeyInfo: accessKeyInfo!,\n          nextNonce,\n          txBlockHeight: txBlockHeight!,\n          txBlockHash: txBlockHash!,\n        };\n\n        // Only commit if identity did not change during fetch\n        if (\n          capturedAccountId === this.nearAccountId &&\n          capturedPublicKey === this.nearPublicKeyStr\n        ) {\n          this.transactionContext = transactionContext;\n          const now = Date.now();\n          if (fetchAccessKey) this.lastNonceUpdate = now;\n          if (fetchBlock) this.lastBlockHeightUpdate = now;\n        } else {\n          console.debug('[NonceManager]: Discarded fetch result due to identity change');\n        }\n\n        return transactionContext;\n      } catch (error) {\n        console.error('[NonceManager]: Failed to fetch fresh transaction context:', error);\n        throw error;\n      } finally {\n        this.inflightFetch = null;\n      }\n    })();\n\n    return this.inflightFetch;\n  }\n\n  /**\n   * Get the current transaction context\n   * Throws if data is not available or stale\n   */\n  public getTransactionContext(): TransactionContext {\n    if (!this.transactionContext) {\n      throw new Error('Transaction context not available - call getNonceBlockHashAndHeight() first');\n    }\n\n    // Check if data is stale (more than 30 seconds old)\n    const now = Date.now();\n    const maxAge = 30 * 1000; // 30 seconds\n\n    if (this.lastNonceUpdate && (now - this.lastNonceUpdate) > maxAge) {\n      console.warn('[NonceManager]: Transaction context is stale, consider refreshing');\n    }\n\n    return this.transactionContext;\n  }\n\n  /**\n   * Check if transaction context is available and not stale\n   */\n  public isTransactionContextAvailable(maxAgeMs: number = 30000): boolean {\n    if (!this.transactionContext || !this.lastNonceUpdate) {\n      return false;\n    }\n\n    const now = Date.now();\n    return (now - this.lastNonceUpdate) <= maxAgeMs;\n  }\n\n  /**\n   * Clear transaction context (useful when nonce might be invalidated)\n   */\n  public clearTransactionContext(): void {\n    this.transactionContext = null;\n    this.lastNonceUpdate = null;\n    this.lastBlockHeightUpdate = null;\n    this.clearRefreshTimer();\n    this.clearPrefetchTimer();\n    this.inflightFetch = null;\n    this.reservedNonces.clear();\n    this.lastReservedNonce = null;\n  }\n\n  /**\n   * Reserve a nonce for batch transactions\n   * This increments the nonce locally to prevent conflicts in batch operations\n   * @param count - Number of nonces to reserve (default: 1)\n   * @returns Array of reserved nonces\n   */\n  public reserveNonces(count: number = 1): string[] {\n    if (!this.transactionContext) {\n      throw new Error('Transaction context not available - call getNonceBlockHashAndHeight() first');\n    }\n\n    if (count <= 0) return [];\n\n    const start = this.lastReservedNonce\n      ? BigInt(this.lastReservedNonce) + 1n\n      : BigInt(this.transactionContext.nextNonce);\n\n    // Plan reservations first (pure), then commit atomically\n    const planned: string[] = [];\n    for (let i = 0; i < count; i++) {\n      const candidate = (start + BigInt(i)).toString();\n      if (this.reservedNonces.has(candidate)) {\n        throw new Error(`Nonce ${candidate} is already reserved`);\n      }\n      planned.push(candidate);\n    }\n\n    // Commit: extend set and bump lastReservedNonce\n    const newSet = new Set(this.reservedNonces);\n    for (const n of planned) newSet.add(n);\n    this.reservedNonces = newSet;\n    this.lastReservedNonce = planned[planned.length - 1];\n\n    console.debug(`[NonceManager]: Reserved ${count} nonces:`, planned);\n    return planned;\n  }\n\n  /**\n   * Release a reserved nonce (call when transaction is completed or failed)\n   * @param nonce - The nonce to release\n   */\n  public releaseNonce(nonce: string): void {\n    if (this.reservedNonces.has(nonce)) {\n      this.reservedNonces.delete(nonce);\n      console.debug(`[NonceManager]: Released nonce ${nonce}`);\n    }\n  }\n\n  /**\n   * Release all reserved nonces\n   */\n  public releaseAllNonces(): void {\n    const count = this.reservedNonces.size;\n    this.reservedNonces.clear();\n    this.lastReservedNonce = null;\n    console.debug(`[NonceManager]: Released all ${count} reserved nonces`);\n  }\n\n  /**\n   * Update nonce from blockchain after transaction completion\n   * This should be called after a transaction is successfully broadcasted\n   * @param nearClient - NEAR client for RPC calls\n   * @param actualNonce - The actual nonce used in the completed transaction\n   */\n  public async updateNonceFromBlockchain(nearClient: NearClient, actualNonce: string): Promise<void> {\n    if (!this.nearAccountId || !this.nearPublicKeyStr) {\n      throw new Error('NonceManager not initialized with user data');\n    }\n\n    try {\n      // Fetch fresh access key info to get the latest nonce\n      const accessKeyInfo = await nearClient.viewAccessKey(this.nearAccountId, this.nearPublicKeyStr);\n\n      if (!accessKeyInfo || accessKeyInfo.nonce === undefined) {\n        throw new Error(`Access key not found or invalid for account ${this.nearAccountId}`);\n      }\n\n      const chainNonceBigInt = BigInt(accessKeyInfo.nonce);\n      const actualNonceBigInt = BigInt(actualNonce);\n\n      // Tolerate both pre- and post-final states:\n      // - pre-final: chainNonce == actualNonce - 1\n      // - post-final: chainNonce >= actualNonce\n      if (chainNonceBigInt < actualNonceBigInt - BigInt(1)) {\n        console.warn(\n          `[NonceManager]: Chain nonce (${chainNonceBigInt}) behind expected (${actualNonceBigInt - BigInt(1)}). Proceeding with tolerant update.`\n        );\n      }\n\n      // Compute next usable nonce using maxBigInt for clarity\n      const candidateNext = this.maxBigInt(\n        chainNonceBigInt + 1n,\n        this.transactionContext?.nextNonce ? BigInt(this.transactionContext.nextNonce) : 0n,\n        this.lastReservedNonce ? BigInt(this.lastReservedNonce) + 1n : 0n,\n      );\n\n      // Update cached context with fresh access key info and computed next nonce\n      if (this.transactionContext) {\n        this.transactionContext.accessKeyInfo = accessKeyInfo;\n        this.transactionContext.nextNonce = candidateNext.toString();\n      } else {\n        // If no context exists (should be rare here), construct a minimal one\n        this.transactionContext = {\n          nearPublicKeyStr: this.nearPublicKeyStr,\n          accessKeyInfo: accessKeyInfo,\n          nextNonce: candidateNext.toString(),\n          // Block values are unknown here; leave stale ones to be refreshed later\n          txBlockHeight: '0',\n          txBlockHash: '',\n        } as any; // We'll refresh these via fetchFreshData when needed\n      }\n      this.lastNonceUpdate = Date.now();\n\n      // Release the used nonce (idempotent)\n      this.releaseNonce(actualNonce);\n\n      // Prune any reserved nonces that are now <= chain nonce (already used or invalid)\n      if (this.reservedNonces.size > 0) {\n        const { set: prunedSet, lastReserved } = this.pruneReserved(chainNonceBigInt, this.reservedNonces);\n        this.reservedNonces = prunedSet;\n        this.lastReservedNonce = lastReserved;\n      }\n\n      console.debug(\n        `[NonceManager]: Updated from chain nonce=${chainNonceBigInt} actual=${actualNonceBigInt} next=${this.transactionContext!.nextNonce}`\n      );\n\n    } catch (error) {\n      console.error('[NonceManager]: Failed to update nonce from blockchain:', error);\n      // Don't throw - this is a best-effort update\n    }\n  }\n\n  /**\n   * Get the next available nonce for a single transaction\n   * This is a convenience method that reserves exactly one nonce\n   * @returns The next nonce to use\n   */\n  public getNextNonce(): string {\n    const nonces = this.reserveNonces(1);\n    return nonces[0];\n  }\n\n  private clearRefreshTimer(): void {\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = null;\n    }\n  }\n  private clearPrefetchTimer(): void {\n    if (this.prefetchTimer) {\n      clearTimeout(this.prefetchTimer);\n      this.prefetchTimer = null;\n    }\n  }\n\n  // Small helper to get max of BigInt values elegantly\n  private maxBigInt(...values: bigint[]): bigint {\n    if (values.length === 0) return 0n;\n    return values.reduce((a, b) => (a > b ? a : b));\n  }\n\n  // Return a new reserved set that excludes entries <= chain nonce, and compute new lastReserved\n  private pruneReserved(chainNonceBigInt: bigint, reserved: Set<string>): { set: Set<string>, lastReserved: string | null } {\n    const newSet = new Set<string>();\n    let newLast: bigint | null = null;\n    for (const r of reserved) {\n      try {\n        const rb = BigInt(r);\n        if (rb > chainNonceBigInt) {\n          newSet.add(r);\n          if (newLast === null || rb > newLast) newLast = rb;\n        }\n      } catch {\n        // skip malformed entries\n      }\n    }\n    return {\n      set: newSet,\n      lastReserved: newLast ? newLast.toString() : null\n    };\n  }\n\n}\n\n// Create and export singleton instance\nconst NonceManagerInstance = NonceManager.getInstance();\nexport default NonceManagerInstance;\n"],"mappings":"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"}