{"version":3,"file":"NearClient.js","names":["params: any","fullAccessKeys: FullAccessKey[]","functionCallAccessKeys: FunctionCallAccessKey[]"],"sources":["../../../../../../../src/core/NearClient.ts"],"sourcesContent":["/**\n * Minimal NEAR RPC client that replaces @near-js/providers\n * Only includes the methods actually used by PasskeyManager\n *\n * If needed, we can just wrap @near-js if we require more complex\n * functionality and type definitions\n */\n\nimport {\n  FinalExecutionOutcome,\n  QueryResponseKind,\n  TxExecutionStatus,\n  AccessKeyView,\n  AccessKeyInfoView,\n  AccessKeyList,\n  FunctionCallPermissionView,\n  AccountView,\n  BlockResult,\n  BlockReference,\n  RpcQueryRequest,\n  FinalityReference,\n} from \"@near-js/types\";\nimport { PublicKey } from \"@near-js/crypto\";\nimport { base64Encode } from \"../utils\";\nimport { DEFAULT_WAIT_STATUS } from \"./types/rpc\";\nimport {\n  WasmTransaction,\n  WasmSignature,\n} from \"../wasm_signer_worker/wasm_signer_worker.js\";\n// import { Provider } from \"@near-js/providers\";\n\n// re-export near-js types\nexport type { AccessKeyList } from \"@near-js/types\";\n\n// Type definitions for getAccessKeys function\nexport interface ViewAccountParams {\n  account: string;\n  block_id?: string;\n}\n\nexport type FullAccessKey = Omit<AccessKeyInfoView, 'access_key'>\n  & { access_key: Omit<AccessKeyView, 'permission'> & { permission: 'FullAccess' } }\n\nexport type FunctionCallAccessKey = Omit<AccessKeyInfoView, 'access_key'>\n  & { access_key: Omit<AccessKeyView, 'permission'> & { permission: FunctionCallPermissionView } }\n\nexport interface ContractResult<T> extends QueryResponseKind {\n  result?: T | string | number | any;\n  logs: string[];\n}\n\nexport enum RpcCallType {\n  Query = \"query\",\n  View = \"view\",\n  Send = \"send_tx\",\n  Block = \"block\",\n  Call = \"call_function\",\n}\n\nexport class SignedTransaction {\n  transaction: WasmTransaction;\n  signature: WasmSignature;\n  borsh_bytes: number[];\n\n  constructor(data: {\n    transaction: WasmTransaction;\n    signature: WasmSignature;\n    borsh_bytes: number[]\n  }) {\n    this.transaction = data.transaction;\n    this.signature = data.signature;\n    this.borsh_bytes = data.borsh_bytes;\n  }\n\n  encode(): ArrayBuffer {\n    // If borsh_bytes are already available, use them\n    return (new Uint8Array(this.borsh_bytes)).buffer;\n  }\n\n  base64Encode(): string {\n    return base64Encode(this.encode());\n  }\n\n  static decode(bytes: Uint8Array): SignedTransaction {\n    // This would need borsh deserialization\n    throw new Error('SignedTransaction.decode(): borsh deserialization not implemented');\n  }\n}\n\n/**\n * MinimalNearClient provides a simplified interface for NEAR protocol interactions\n */\nexport interface NearClient {\n  viewAccessKey(accountId: string, publicKey: PublicKey | string, finalityQuery?: FinalityReference): Promise<AccessKeyView>;\n  viewAccessKeyList(accountId: string, finalityQuery?: FinalityReference): Promise<AccessKeyList>;\n  viewAccount(accountId: string): Promise<AccountView>;\n  viewBlock(params: BlockReference): Promise<BlockResult>;\n  sendTransaction(\n    signedTransaction: SignedTransaction,\n    waitUntil?: TxExecutionStatus\n  ): Promise<FinalExecutionOutcome>;\n  query<T extends QueryResponseKind>(params: RpcQueryRequest): Promise<T>;\n  callFunction<A, T>(\n    contractId: string,\n    method: string,\n    args: A,\n    blockQuery?: BlockReference\n  ): Promise<T>;\n  view<A, T>(params: { account: string; method: string; args: A }): Promise<T>;\n  getAccessKeys(params: ViewAccountParams): Promise<{\n    fullAccessKeys: FullAccessKey[];\n    functionCallAccessKeys: FunctionCallAccessKey[];\n  }>;\n}\n\nexport class MinimalNearClient implements NearClient {\n  private readonly rpcUrl: string;\n\n  constructor(rpcUrl: string) {\n    this.rpcUrl = rpcUrl;\n  }\n\n  // ===========================\n  // PRIVATE HELPER FUNCTIONS\n  // ===========================\n\n  /**\n   * Execute RPC call with proper error handling and result extraction\n   */\n  private async makeRpcCall<T>(\n    method: string,\n    params: any,\n    operationName: string\n  ): Promise<T> {\n\n    const body = {\n      jsonrpc: '2.0',\n      id: crypto.randomUUID(),\n      method,\n      params\n    };\n\n    const response = await fetch(this.rpcUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(body)\n    }).catch(e => {\n      console.error(e);\n      throw new Error(e);\n    });\n\n    if (!response.ok) {\n      throw new Error(`RPC request failed: ${response.status} ${response.statusText}`);\n    }\n\n    const responseText = await response.text();\n    if (!responseText?.trim()) {\n      throw new Error('Empty response from RPC server');\n    }\n\n    const result = JSON.parse(responseText);\n    if (result.error) {\n      throw result.error;\n    }\n\n    // Check for query-specific errors in result.result\n    if (result.result?.error) {\n      throw new Error(`${operationName} Error: ${result.result.error}`);\n    }\n\n    return result.result;\n  }\n\n  // ===========================\n  // PUBLIC API METHODS\n  // ===========================\n\n  async query<T extends QueryResponseKind>(params: RpcQueryRequest): Promise<T> {\n    return this.makeRpcCall<T>(RpcCallType.Query, params, 'Query');\n  }\n\n  async viewAccessKey(accountId: string, publicKey: PublicKey | string, finalityQuery?: FinalityReference): Promise<AccessKeyView> {\n    const publicKeyStr = typeof publicKey === 'string' ? publicKey : publicKey.toString();\n    const finality = finalityQuery?.finality || 'final';\n\n    const params = {\n      request_type: 'view_access_key',\n      finality: finality,\n      account_id: accountId,\n      public_key: publicKeyStr\n    };\n\n    return this.makeRpcCall<AccessKeyView>(RpcCallType.Query, params, 'View Access Key');\n  }\n\n  async viewAccessKeyList(accountId: string, finalityQuery?: FinalityReference): Promise<AccessKeyList> {\n    const finality = finalityQuery?.finality || 'final';\n\n    const params = {\n      request_type: 'view_access_key_list',\n      finality: finality,\n      account_id: accountId\n    };\n\n    return this.makeRpcCall<AccessKeyList>(RpcCallType.Query, params, 'View Access Key List');\n  }\n\n  async viewAccount(accountId: string): Promise<AccountView> {\n    const params = {\n      request_type: 'view_account',\n      finality: 'final',\n      account_id: accountId\n    };\n\n    return this.makeRpcCall<AccountView>(RpcCallType.Query, params, 'View Account');\n  }\n\n  async viewBlock(params: BlockReference): Promise<BlockResult> {\n    return this.makeRpcCall<BlockResult>(RpcCallType.Block, params, 'View Block');\n  }\n\n  async sendTransaction(\n    signedTransaction: SignedTransaction,\n    waitUntil: TxExecutionStatus = DEFAULT_WAIT_STATUS.executeAction\n  ): Promise<FinalExecutionOutcome> {\n    return await this.makeRpcCall<FinalExecutionOutcome>(\n      RpcCallType.Send,\n      {\n        signed_tx_base64: signedTransaction.base64Encode(),\n        wait_until: waitUntil\n      },\n      'Send Transaction'\n    );\n  }\n\n  async callFunction<A, T>(\n    contractId: string,\n    method: string,\n    args: A,\n    blockQuery?: BlockReference\n  ): Promise<T> {\n    const rpcParams = {\n      request_type: 'call_function',\n      finality: 'final',\n      account_id: contractId,\n      method_name: method,\n      args_base64: base64Encode(new TextEncoder().encode(JSON.stringify(args)).buffer)\n    };\n\n    const result = await this.makeRpcCall<ContractResult<T>>(\n      RpcCallType.Query,\n      rpcParams,\n      'View Function'\n    );\n\n    // Parse result bytes to string/JSON\n    const resultBytes = result.result;\n\n    if (!Array.isArray(resultBytes)) {\n      // If result is not bytes array, it might already be parsed\n      return result as unknown as T;\n    }\n\n    const resultString = String.fromCharCode(...resultBytes);\n\n    if (!resultString.trim()) {\n      return null as T;\n    }\n\n    try {\n      const parsed = JSON.parse(resultString);\n      return parsed as T;\n    } catch (parseError) {\n      console.warn('Failed to parse result as JSON, returning as string:', parseError);\n      console.warn('Raw result string:', resultString);\n      // Return the string value if it's not valid JSON\n      const cleanString = resultString.replace(/^\"|\"$/g, ''); // Remove quotes\n      return cleanString as T;\n    }\n  }\n\n  async view<A, T>(params: { account: string; method: string; args: A }): Promise<T> {\n    return this.callFunction<A, T>(params.account, params.method, params.args);\n  }\n\n  async getAccessKeys({ account, block_id }: ViewAccountParams): Promise<{\n    fullAccessKeys: FullAccessKey[];\n    functionCallAccessKeys: FunctionCallAccessKey[];\n  }> {\n    // Build RPC parameters similar to the official implementation\n    const params: any = {\n      request_type: 'view_access_key_list',\n      account_id: account,\n      finality: 'final'\n    };\n\n    // Add block_id if provided (for specific block queries)\n    if (block_id) {\n      params.block_id = block_id;\n      delete params.finality; // block_id takes precedence over finality\n    }\n\n    // Make the RPC call directly to match the official implementation\n    const accessKeyList = await this.makeRpcCall<AccessKeyList>(\n      RpcCallType.Query,\n      params,\n      'View Access Key List'\n    );\n\n    // Separate full access keys and function call access keys\n    const fullAccessKeys: FullAccessKey[] = [];\n    const functionCallAccessKeys: FunctionCallAccessKey[] = [];\n\n    // Process each access key (matching the official categorization logic)\n    for (const key of accessKeyList.keys) {\n      if (key.access_key.permission === 'FullAccess') {\n        // Full Access Keys: Keys with FullAccess permission\n        fullAccessKeys.push(key as FullAccessKey);\n      } else if (key.access_key.permission && typeof key.access_key.permission === 'object' && 'FunctionCall' in key.access_key.permission) {\n        // Function Call Keys: Keys with limited permissions for specific contract calls\n        functionCallAccessKeys.push(key as FunctionCallAccessKey);\n      }\n    }\n\n    return {\n      fullAccessKeys,\n      functionCallAccessKeys\n    };\n  }\n}"],"mappings":"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"}