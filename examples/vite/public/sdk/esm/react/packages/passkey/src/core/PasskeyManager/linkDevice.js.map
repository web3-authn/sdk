{"version":3,"file":"linkDevice.js","names":["QRCode.toDataURL","qrData: DeviceLinkingQRData","error: any","loginError: any","actions: ActionArgsWasm[]"],"sources":["../../../../../../../../src/core/PasskeyManager/linkDevice.ts"],"sourcesContent":["import { KeyPair } from '@near-js/crypto';\n\nimport type { PasskeyManagerContext } from './index';\nimport { IndexedDBManager } from '../IndexedDBManager';\nimport { validateNearAccountId } from '../../utils/validation';\nimport { generateBootstrapVrfChallenge } from './registration';\nimport { base64UrlEncode } from '../../utils';\nimport { DEVICE_LINKING_CONFIG } from '../../config';\n\nimport { ActionType, type ActionArgsWasm } from '../types/actions';\nimport { toAccountId, type AccountId } from '../types/accountIds';\nimport {\n  VRFChallenge,\n  outputAs32Bytes,\n  type EncryptedVRFKeypair,\n  type ServerEncryptedVrfKeypair\n} from '../types/vrf-worker';\nimport { DEFAULT_WAIT_STATUS } from \"../types/rpc\";\n\nimport { getDeviceLinkingAccountContractCall } from \"../rpcCalls\";\nimport QRCode from 'qrcode'; // jsQR will be dynamically imported when needed\nimport type {\n  DeviceLinkingQRData,\n  DeviceLinkingSession,\n  StartDeviceLinkingOptionsDevice2\n} from '../types/linkDevice';\nimport { DeviceLinkingError, DeviceLinkingErrorCode } from '../types/linkDevice';\nimport { DeviceLinkingPhase, DeviceLinkingStatus } from '../types/passkeyManager';\nimport type { DeviceLinkingSSEEvent } from '../types/passkeyManager';\n\n\nasync function generateQRCodeDataURL(data: string): Promise<string> {\n  return QRCode.toDataURL(data, {\n    width: 256,\n    margin: 2,\n    color: {\n      dark: '#000000',\n      light: '#ffffff'\n    },\n    errorCorrectionLevel: 'M'\n  });\n}\n\n/**\n * Device linking flow class - manages the complete device linking process\n *\n * Usage:\n * ```typescript\n * // Device2: Generate QR and start polling\n * const flow = new LinkDeviceFlow(context, options);\n * const { qrData, qrCodeDataURL } = await flow.generateQR(accountId);\n *\n * // Device1: Scan and authorize\n * const result = await LinkDeviceFlow.scanAndLink(context, options);\n *\n * // Device2: Flow automatically completes when AddKey is detected\n * const state = flow.getState();\n * ```\n */\nexport class LinkDeviceFlow {\n  private context: PasskeyManagerContext;\n  private options: StartDeviceLinkingOptionsDevice2;\n  private session: DeviceLinkingSession | null = null;\n  private error?: Error;\n  // Track explicit cancellation to short-circuit in-flight ops and logs\n  private cancelled: boolean = false;\n  // AddKey polling\n  private pollingInterval?: NodeJS.Timeout;\n  private pollGeneration = 0; // invalidate late ticks when stopping/restarting\n  private readonly KEY_POLLING_INTERVAL = DEVICE_LINKING_CONFIG.TIMEOUTS.POLLING_INTERVAL_MS;\n  // Registration retries\n  private registrationRetryTimeout?: NodeJS.Timeout;\n  private registrationRetryCount = 0;\n  private readonly MAX_REGISTRATION_RETRIES = DEVICE_LINKING_CONFIG.RETRY.MAX_REGISTRATION_ATTEMPTS;\n  private readonly RETRY_DELAY_MS = DEVICE_LINKING_CONFIG.TIMEOUTS.REGISTRATION_RETRY_DELAY_MS;\n  // Temporary key cleanup\n  private tempKeyCleanupTimer?: NodeJS.Timeout;\n  private readonly TEMP_KEY_CLEANUP_DELAY_MS = DEVICE_LINKING_CONFIG.TIMEOUTS.TEMP_KEY_CLEANUP_MS;\n\n  constructor(\n    context: PasskeyManagerContext,\n    options: StartDeviceLinkingOptionsDevice2\n  ) {\n    this.context = context;\n    this.options = options;\n  }\n\n  // Guard helpers\n  private ifActive<T>(fn: () => T): T | undefined {\n    if (this.cancelled) return;\n    return fn();\n  }\n\n  private safeOnEvent(evt: DeviceLinkingSSEEvent) {\n    this.ifActive(() => this.options?.onEvent?.(evt));\n  }\n\n  /**\n   * Device2 (companion device): Generate QR code and start polling for AddKey transaction\n   *\n   * Supports two flows:\n   * - Option E: If accountId provided, generate proper NEAR keypair immediately (faster)\n   * - Option F: If no accountId, generate temp NEAR keypair, replace later (seamless UX)\n   */\n  async generateQR(accountId?: AccountId): Promise<{\n    qrData: DeviceLinkingQRData;\n    qrCodeDataURL: string\n  }> {\n    try {\n      if (accountId) {\n        // === OPTION E: Account ID provided - generate proper keypair immediately ===\n        console.log(`LinkDeviceFlow: Option E - Using provided account ID: ${accountId}`);\n\n        // Validate account ID format\n        validateNearAccountId(accountId);\n\n        // validate account exists on-chain\n        const accountExists = await this.context.nearClient.viewAccount(accountId);\n        if (!accountExists) {\n          throw new Error(`Account ${accountId} does not exist onchain`);\n        }\n\n        // Generate VRF challenge for the real account\n        const vrfChallenge = await generateBootstrapVrfChallenge(this.context, accountId);\n\n        // Generate WebAuthn credentials with TouchID (for real account)\n        // Note: Device number will be determined later when Device1 creates the mapping\n        const credential = await this.context.webAuthnManager.generateRegistrationCredentials({\n          nearAccountId: accountId,\n          challenge: vrfChallenge,\n        });\n\n        // Derive NEAR keypair with proper account-specific salt\n        const nearKeyResult = await this.context.webAuthnManager.deriveNearKeypairAndEncrypt({\n          credential,\n          nearAccountId: toAccountId(accountId)\n        });\n\n        if (!nearKeyResult.success || !nearKeyResult.publicKey) {\n          throw new Error('Failed to generate NEAR keypair for provided account');\n        }\n\n        // Create session with real account ID from start\n        this.session = {\n          accountId: accountId,\n          deviceNumber: undefined,\n          nearPublicKey: nearKeyResult.publicKey,\n          credential,\n          vrfChallenge,\n          phase: DeviceLinkingPhase.IDLE,\n          createdAt: Date.now(),\n          expiresAt: Date.now() + DEVICE_LINKING_CONFIG.TIMEOUTS.SESSION_EXPIRATION_MS\n        };\n\n        console.log(`LinkDeviceFlow: Option E - Generated proper NEAR keypair for ${accountId}`);\n\n      } else {\n        // === OPTION F: No account ID - generate temporary keypair, replace later ===\n        console.log(`LinkDeviceFlow: Option F - No account provided, using temporary keypair approach`);\n        // Generate temporary NEAR keypair WITHOUT TouchID/VRF (just for QR generation)\n        const tempNearKeyResult = await this.generateTemporaryNearKeypair();\n\n        // Create session with null accountId (will be discovered from polling)\n        this.session = {\n          accountId: null, // Will be discovered from contract polling\n          deviceNumber: undefined, // Will be discovered from contract polling\n          nearPublicKey: tempNearKeyResult.publicKey,\n          credential: null, // Will be generated later when we know real account\n          vrfChallenge: null, // Will be generated later\n          phase: DeviceLinkingPhase.IDLE,\n          createdAt: Date.now(),\n          expiresAt: Date.now() + DEVICE_LINKING_CONFIG.TIMEOUTS.SESSION_EXPIRATION_MS,\n          tempPrivateKey: tempNearKeyResult.privateKey // Store temp private key for signing later\n        };\n        console.log(`LinkDeviceFlow: Option F - Generated temporary NEAR keypair`);\n      }\n\n      // Generate QR data (works for both options)\n      const qrData: DeviceLinkingQRData = {\n        device2PublicKey: this.session.nearPublicKey,\n        accountId: this.session.accountId || undefined, // Convert null to undefined for optional field\n        timestamp: Date.now(),\n        version: '1.0'\n      };\n\n      // Create QR code data URL\n      const qrDataString = JSON.stringify(qrData);\n      const qrCodeDataURL = await generateQRCodeDataURL(qrDataString);\n      const flowType = accountId\n        ? 'Option E (provided account)'\n        : 'Option F (account discovery)';\n\n      this.safeOnEvent({\n        step: 1,\n        phase: DeviceLinkingPhase.STEP_1_QR_CODE_GENERATED,\n        status: DeviceLinkingStatus.PROGRESS,\n        message: `QR code generated using ${flowType}, waiting for Device1 to scan and authorize...`\n      });\n\n      // Start polling for AddKey transaction (guard if cancelled before reaching here)\n      if (!this.cancelled) {\n        this.startPolling();\n      }\n      this.safeOnEvent({\n        step: 4,\n        phase: DeviceLinkingPhase.STEP_4_POLLING,\n        status: DeviceLinkingStatus.PROGRESS,\n        message: `Polling contract for linked account...`\n      });\n\n      return { qrData, qrCodeDataURL };\n\n    } catch (error: any) {\n      this.error = error;\n      this.safeOnEvent({\n        step: 0,\n        phase: DeviceLinkingPhase.DEVICE_LINKING_ERROR,\n        status: DeviceLinkingStatus.ERROR,\n        error: error.message,\n        message: error.message,\n      });\n      throw new DeviceLinkingError(\n        `Failed to generate device linking QR: ${error.message}`,\n        DeviceLinkingErrorCode.REGISTRATION_FAILED,\n        'generation'\n      );\n    }\n  }\n\n  /**\n   * Generate temporary NEAR keypair without TouchID/VRF for Option F flow\n   * This creates a proper Ed25519 keypair that can be used for the QR code\n   * Includes memory cleanup and automatic expiration\n   */\n  private async generateTemporaryNearKeypair(): Promise<{ publicKey: string; privateKey: string }> {\n    // Generate a temporary random NEAR Ed25519 keypair\n    const keyPair = KeyPair.fromRandom('ed25519');\n    const publicKeyNear = keyPair.getPublicKey().toString();\n    const privateKeyNear = keyPair.toString();\n\n    console.log(`LinkDeviceFlow: Generated temporary Ed25519 keypair with automatic cleanup`);\n\n    // Schedule automatic cleanup of the temporary key from memory\n    this.scheduleTemporaryKeyCleanup(publicKeyNear);\n\n    return {\n      publicKey: publicKeyNear,\n      privateKey: privateKeyNear\n    };\n  }\n\n  /**\n   * Schedule automatic cleanup of temporary private key from memory\n   * This provides defense-in-depth against memory exposure\n   */\n  private scheduleTemporaryKeyCleanup(publicKey: string): void {\n    // Clear any existing cleanup timer\n    if (this.tempKeyCleanupTimer) {\n      clearTimeout(this.tempKeyCleanupTimer);\n    }\n\n    this.tempKeyCleanupTimer = setTimeout(() => {\n      this.cleanupTemporaryKeyFromMemory();\n      console.log(`LinkDeviceFlow: Automatic cleanup executed for temporary key: ${publicKey.substring(0, 20)}...`);\n    }, this.TEMP_KEY_CLEANUP_DELAY_MS);\n\n    console.log(`LinkDeviceFlow: Scheduled automatic cleanup in ${this.TEMP_KEY_CLEANUP_DELAY_MS / 1000 / 60} minutes for key: ${publicKey.substring(0, 20)}...`);\n  }\n\n  /**\n   * Immediately clean up temporary private key from memory\n   * Called on successful completion, cancellation, or timeout\n   */\n  private cleanupTemporaryKeyFromMemory(): void {\n    if (this.session?.tempPrivateKey) {\n      // Overwrite the private key string with zeros\n      const keyLength = this.session.tempPrivateKey.length;\n      this.session.tempPrivateKey = '0'.repeat(keyLength);\n\n      // Then set to empty string to release memory\n      this.session.tempPrivateKey = '';\n\n      console.log('LinkDeviceFlow: Temporary private key cleaned from memory');\n    }\n\n    // Clear the cleanup timer\n    if (this.tempKeyCleanupTimer) {\n      clearTimeout(this.tempKeyCleanupTimer);\n      this.tempKeyCleanupTimer = undefined;\n    }\n  }\n\n  /**\n   * Device2: Start polling blockchain for AddKey transaction\n   */\n  private startPolling(): void {\n    if (!this.session || this.cancelled) return;\n\n    // Stop any existing schedule and invalidate late ticks\n    this.stopPolling();\n    const myGen = ++this.pollGeneration;\n\n    const tick = async () => {\n      if (this.cancelled || this.pollGeneration !== myGen) return;\n\n      if (!this.shouldContinuePolling()) {\n        this.stopPolling();\n        return;\n      }\n      try {\n        const hasKeyAdded = await this.checkForDeviceKeyAdded();\n        if (this.cancelled || this.pollGeneration !== myGen) return;\n        if (hasKeyAdded && this.session) {\n          this.stopPolling();\n          this.safeOnEvent({\n            step: 5,\n            phase: DeviceLinkingPhase.STEP_5_ADDKEY_DETECTED,\n            status: DeviceLinkingStatus.PROGRESS,\n            message: 'AddKey transaction detected, starting registration...'\n          });\n          this.session.phase = DeviceLinkingPhase.STEP_5_ADDKEY_DETECTED;\n          this.startRegistrationWithRetries();\n          return;\n        }\n      } catch (error: any) {\n        if (this.cancelled || this.pollGeneration !== myGen) return;\n        console.error('Polling error:', error);\n        if (error.message?.includes('Account not found')) {\n          console.warn('Account not found - stopping polling');\n          this.stopPolling();\n          return;\n        }\n      }\n\n      if (!this.cancelled && this.pollGeneration === myGen) {\n        this.pollingInterval = setTimeout(tick, this.KEY_POLLING_INTERVAL) as any as NodeJS.Timeout;\n      }\n    };\n\n    this.pollingInterval = setTimeout(tick, this.KEY_POLLING_INTERVAL) as any as NodeJS.Timeout;\n  }\n\n  private shouldContinuePolling(): boolean {\n    if (!this.session) return false;\n\n    // Stop polling if we've detected AddKey and moved to registration\n    if (this.session.phase === DeviceLinkingPhase.STEP_5_ADDKEY_DETECTED) {\n      return false;\n    }\n    // Stop polling if we've completed successfully\n    if (this.session.phase === DeviceLinkingPhase.STEP_7_LINKING_COMPLETE) {\n      return false;\n    }\n    if (Date.now() > this.session.expiresAt) {\n      this.error = new Error('Session expired');\n      this.safeOnEvent({\n        step: 0,\n        phase: DeviceLinkingPhase.DEVICE_LINKING_ERROR,\n        status: DeviceLinkingStatus.ERROR,\n        error: this.error?.message,\n        message: 'Device linking session expired',\n      });\n\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Device2: Check if device key has been added by polling contract HashMap\n   */\n  private async checkForDeviceKeyAdded(): Promise<boolean> {\n    // If polling was cancelled or cleared, bail out early to avoid noisy logs\n    if (this.cancelled || !this.pollingInterval) {\n      return false;\n    }\n    if (!this.session?.nearPublicKey) {\n      console.error(`LinkDeviceFlow: No session or public key available for polling`);\n      return false;\n    }\n\n    try {\n      const linkingResult = await getDeviceLinkingAccountContractCall(\n        this.context.nearClient,\n        this.context.configs.contractId,\n        this.session.nearPublicKey\n      );\n\n      // Check again after RPC returns in case cancel happened mid-flight\n      if (this.cancelled || !this.pollingInterval) {\n        return false;\n      }\n\n      this.safeOnEvent({\n        step: 4,\n        phase: DeviceLinkingPhase.STEP_4_POLLING,\n        status: DeviceLinkingStatus.PROGRESS,\n        message: 'Polling contract for linked account...'\n      });\n\n      if (\n        linkingResult\n        && linkingResult.linkedAccountId\n        && linkingResult.deviceNumber !== undefined\n      ) {\n        // contract returns current deviceNumber, device should be assigned next number\n        const nextDeviceNumber = linkingResult.deviceNumber + 1;\n        console.log(`LinkDeviceFlow: Success! Discovered linked account:`, {\n          linkedAccountId: linkingResult.linkedAccountId,\n          currentCounter: linkingResult.deviceNumber,\n          nextDeviceNumber: nextDeviceNumber,\n        });\n        this.session.accountId = linkingResult.linkedAccountId as AccountId;\n        this.session.deviceNumber = nextDeviceNumber;\n        // Store the next device number for this device\n        return true;\n      } else {\n        if (!this.cancelled) console.log(`LinkDeviceFlow: No mapping found yet...`);\n      }\n\n      return false;\n    } catch (error: any) {\n      console.error(`LinkDeviceFlow: Error checking for device key addition:`, {\n        error: error.message,\n        stack: error.stack,\n        name: error.name,\n        code: error.code\n      });\n\n      return false;\n    }\n  }\n\n  /**\n   * Device2: Start registration process with retry logic\n   */\n  private startRegistrationWithRetries(): void {\n    this.registrationRetryCount = 0;\n    this.attemptRegistration();\n  }\n\n  /**\n   * Device2: Attempt registration with retry logic\n   */\n  private attemptRegistration(): void {\n    this.swapKeysAndRegisterAccount().catch((error: any) => {\n      // Check if this is a retryable error\n      if (this.isRetryableError(error)) {\n        this.registrationRetryCount++;\n\n        if (this.registrationRetryCount > this.MAX_REGISTRATION_RETRIES) {\n          console.error('LinkDeviceFlow: Max registration retries exceeded, failing permanently');\n          // Non-retryable error - fail permanently\n          this.session!.phase = DeviceLinkingPhase.REGISTRATION_ERROR;\n          this.error = error;\n          this.options?.onEvent?.({\n            step: 0,\n            phase: DeviceLinkingPhase.REGISTRATION_ERROR,\n            status: DeviceLinkingStatus.ERROR,\n            error: error.message,\n            message: error.message,\n          });\n        } else {\n          console.warn(`LinkDeviceFlow: Registration failed with retryable error (attempt ${this.registrationRetryCount}/${this.MAX_REGISTRATION_RETRIES}), will retry in ${this.RETRY_DELAY_MS}ms:`, error.message);\n          this.options?.onEvent?.({\n            step: 5,\n            phase: DeviceLinkingPhase.STEP_5_ADDKEY_DETECTED,\n            status: DeviceLinkingStatus.PROGRESS,\n            message: `Registration failed (${error.message}), retrying in ${this.RETRY_DELAY_MS}ms... (${this.registrationRetryCount}/${this.MAX_REGISTRATION_RETRIES})`\n          });\n          // Schedule retry with setTimeout\n          this.registrationRetryTimeout = setTimeout(() => {\n            this.attemptRegistration();\n          }, this.RETRY_DELAY_MS);\n        }\n      } else {\n        // Non-retryable error - fail permanently\n        this.session!.phase = DeviceLinkingPhase.REGISTRATION_ERROR;\n        this.error = error;\n        this.options?.onEvent?.({\n          step: 0,\n          phase: DeviceLinkingPhase.REGISTRATION_ERROR,\n          status: DeviceLinkingStatus.ERROR,\n          error: error.message,\n          message: error.message,\n        });\n      }\n    });\n  }\n\n  /**\n   * Device2: Complete device linking\n   * 1. Derives deterministic VRF and NEAR keys using real accountID (instead of temporary keys)\n   * 2. Executes Key Replacement transaction to replace temporary key with the real key\n   * 3. Signs the registration transaction and broadcasts it.\n   */\n  private async swapKeysAndRegisterAccount(): Promise<void> {\n    if (!this.session || !this.session.accountId) {\n      throw new Error('AccountID not available for registration');\n    }\n\n    try {\n      this.safeOnEvent({\n        step: 6,\n        phase: DeviceLinkingPhase.STEP_6_REGISTRATION,\n        status: DeviceLinkingStatus.PROGRESS,\n        message: 'Storing device authenticator data locally...'\n      });\n\n      // Migrate/generate deterministic VRF credentials for the real account\n      const deterministicKeysResult = await this.deriveDeterministicKeysAndRegisterAccount();\n\n      // Store authenticator data locally on Device2\n      await this.storeDeviceAuthenticator(deterministicKeysResult);\n\n      this.session.phase = DeviceLinkingPhase.STEP_7_LINKING_COMPLETE;\n      this.registrationRetryCount = 0; // Reset retry counter on success\n      this.safeOnEvent({\n        step: 7,\n        phase: DeviceLinkingPhase.STEP_7_LINKING_COMPLETE,\n        status: DeviceLinkingStatus.SUCCESS,\n        message: 'Device linking completed successfully'\n      });\n\n      // Auto-login for Device2 after successful device linking\n      await this.attemptAutoLogin(deterministicKeysResult, this.options);\n\n    } catch (error: any) {\n      // Re-throw error to be handled by attemptRegistration\n      throw error;\n    }\n  }\n\n  /**\n   * Check if an error is retryable (temporary issues that can be resolved)\n   */\n  private isRetryableError(error: any): boolean {\n    const retryableErrorMessages = [\n      'page does not have focus',\n      'a request is already pending',\n      'request is already pending',\n      'operationerror',\n      'notallowederror',\n      'the operation is not allowed at this time',\n      'network error',\n      'timeout',\n      'temporary',\n      'transient'\n    ];\n\n    const errorMessage = error.message?.toLowerCase() || '';\n    const errorName = error.name?.toLowerCase() || '';\n\n    return retryableErrorMessages.some(msg =>\n      errorMessage.includes(msg.toLowerCase()) ||\n      errorName.includes(msg.toLowerCase())\n    );\n  }\n\n  /**\n   * Device2: Attempt auto-login after successful device linking\n   */\n  private async attemptAutoLogin(\n    deterministicKeysResult?: {\n      encryptedVrfKeypair: EncryptedVRFKeypair;\n      serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n      vrfPublicKey: string;\n      nearPublicKey: string;\n      credential: PublicKeyCredential;\n      vrfChallenge?: VRFChallenge;\n    },\n    options?: StartDeviceLinkingOptionsDevice2\n  ): Promise<void> {\n    try {\n      // Send additional event after successful auto-login to update React state\n      options?.onEvent?.({\n        step: 8,\n        phase: DeviceLinkingPhase.STEP_8_AUTO_LOGIN,\n        status: DeviceLinkingStatus.PROGRESS,\n        message: 'Logging in...'\n      });\n\n      if (\n        !this.session || !this.session.accountId ||\n        !this.session.credential || !deterministicKeysResult\n      ) {\n        const missing = [];\n        if (!this.session) missing.push('session');\n        if (!this.session?.accountId) missing.push('accountId');\n        if (!this.session?.credential) missing.push('credential');\n        if (!deterministicKeysResult) missing.push('deterministicKeysResult');\n        throw new Error(`Missing required data for auto-login: ${missing.join(', ')}`);\n      }\n\n      // Try Shamir 3-pass unlock first if available\n      if (\n        deterministicKeysResult.serverEncryptedVrfKeypair &&\n        this.context.configs.vrfWorkerConfigs?.shamir3pass?.relayServerUrl\n      ) {\n        try {\n          console.log('LinkDeviceFlow: Attempting Shamir 3-pass unlock for auto-login');\n          const unlockResult = await this.context.webAuthnManager.shamir3PassDecryptVrfKeypair({\n            nearAccountId: this.session.accountId,\n            kek_s_b64u: deterministicKeysResult.serverEncryptedVrfKeypair.kek_s_b64u,\n            ciphertextVrfB64u: deterministicKeysResult.serverEncryptedVrfKeypair.ciphertextVrfB64u,\n          });\n\n          if (unlockResult.success) {\n            console.log('LinkDeviceFlow: Shamir 3-pass unlock successful for auto-login');\n            this.options?.onEvent?.({\n              step: 8,\n              phase: DeviceLinkingPhase.STEP_8_AUTO_LOGIN,\n              status: DeviceLinkingStatus.SUCCESS,\n              message: `Welcome ${this.session.accountId}`\n            });\n            return; // Success, no need to try TouchID\n          } else {\n            console.log('LinkDeviceFlow: Shamir 3-pass unlock failed, falling back to TouchID');\n          }\n        } catch (error) {\n          console.log('LinkDeviceFlow: Shamir 3-pass unlock error, falling back to TouchID:', error);\n        }\n      }\n\n      // Fall back to TouchID unlock\n      console.log('LinkDeviceFlow: Using TouchID unlock for auto-login');\n      const vrfUnlockResult = await this.context.webAuthnManager.unlockVRFKeypair({\n        nearAccountId: this.session.accountId,\n        encryptedVrfKeypair: deterministicKeysResult.encryptedVrfKeypair,\n        credential: this.session.credential,\n      });\n\n      if (vrfUnlockResult.success) {\n        this.options?.onEvent?.({\n          step: 8,\n          phase: DeviceLinkingPhase.STEP_8_AUTO_LOGIN,\n          status: DeviceLinkingStatus.SUCCESS,\n          message: `Welcome ${this.session.accountId}`\n        });\n      } else {\n        throw new Error(vrfUnlockResult.error || 'VRF unlock failed');\n      }\n    } catch(loginError: any) {\n      console.warn('Login failed after device linking:', loginError);\n      // Don't fail the whole linking process if auto-login fails\n      options?.onEvent?.({\n        step: 0,\n        phase: DeviceLinkingPhase.LOGIN_ERROR,\n        status: DeviceLinkingStatus.ERROR,\n        error: loginError.message,\n        message: loginError.message,\n      });\n    }\n  }\n\n  /**\n   * Device2: Store authenticator data locally on Device2\n   */\n  private async storeDeviceAuthenticator(deterministicKeysResult: {\n    encryptedVrfKeypair: EncryptedVRFKeypair;\n    serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n    vrfPublicKey: string;\n    nearPublicKey: string;\n    credential: PublicKeyCredential;\n    vrfChallenge?: VRFChallenge;\n  } | undefined): Promise<void> {\n    if (!this.session || !this.session.accountId) {\n      throw new Error('Session or account ID not available for storing authenticator');\n    }\n\n    try {\n      const { webAuthnManager } = this.context;\n      const { credential, accountId } = this.session;\n\n      // check for credential after migration (should be available for both Option E and F)\n      if (!credential) {\n        throw new Error('WebAuthn credential not available after VRF migration');\n      }\n      if (!deterministicKeysResult?.encryptedVrfKeypair) {\n        throw new Error('VRF credentials not available after migration');\n      }\n\n      if (this.session.deviceNumber === undefined || this.session.deviceNumber === null) {\n        throw new Error('Device number not available - cannot determine device-specific account ID');\n      }\n\n      // Generate device-specific account ID for storage\n      console.log(\"Storing device authenticator data with device number: \", this.session.deviceNumber);\n      // Store user data with deviceNumber\n      await webAuthnManager.storeUserData({\n        nearAccountId: accountId,\n        deviceNumber: this.session.deviceNumber,\n        clientNearPublicKey: deterministicKeysResult.nearPublicKey,\n        lastUpdated: Date.now(),\n        passkeyCredential: {\n          id: credential.id,\n          rawId: base64UrlEncode(credential.rawId)\n        },\n        encryptedVrfKeypair: {\n          encryptedVrfDataB64u: deterministicKeysResult.encryptedVrfKeypair.encryptedVrfDataB64u,\n          chacha20NonceB64u: deterministicKeysResult.encryptedVrfKeypair.chacha20NonceB64u,\n        },\n        serverEncryptedVrfKeypair: deterministicKeysResult.serverEncryptedVrfKeypair || undefined, // Device linking now uses Shamir 3-pass encryption\n      });\n\n      // Store authenticator with deviceNumber\n      await webAuthnManager.storeAuthenticator({\n        nearAccountId: accountId,\n        deviceNumber: this.session.deviceNumber,\n        credentialId: base64UrlEncode(credential.rawId),\n        credentialPublicKey: new Uint8Array(credential.rawId),\n        transports: ['internal'],\n        name: `Device ${this.session.deviceNumber || 'Unknown'} Passkey for ${accountId.split('.')[0]}`,\n        registered: new Date().toISOString(),\n        syncedAt: new Date().toISOString(),\n        vrfPublicKey: deterministicKeysResult.vrfPublicKey,\n      });\n      console.log(`LinkDeviceFlow: Successfully stored authenticator data for account: ${accountId}, device number: ${this.session.deviceNumber}`);\n\n    } catch (error) {\n      console.error(`LinkDeviceFlow: Failed to store authenticator data:`, error);\n      // Clean up any partial data on failure\n      await this.cleanupFailedLinkingAttempt();\n      throw error;\n    }\n  }\n\n  /**\n   * 1. Derives deterministic VRF and NEAR keys using real accountID (instead of temporary keys)\n   * 2. Executes Key Replacement transaction to replace temporary key with the real key\n   * 3. Signs the registration transaction and broadcasts it.\n   *\n   * For Option E: VRF credentials already exist, just ensure they're stored\n   * For Option F: Generate WebAuthn credential + derive VRF credentials\n   */\n  private async deriveDeterministicKeysAndRegisterAccount(): Promise<{\n    encryptedVrfKeypair: EncryptedVRFKeypair;\n    serverEncryptedVrfKeypair: ServerEncryptedVrfKeypair | null;\n    vrfPublicKey: string;\n    nearPublicKey: string;\n    credential: PublicKeyCredential;\n    vrfChallenge?: VRFChallenge;\n  } | undefined> {\n\n    if (!this.session || !this.session.accountId) {\n      throw new Error('Session account ID not available for migration');\n    };\n    const realAccountId = this.session.accountId;\n\n    try {\n      console.log(`LinkDeviceFlow: Processing VRF credentials for real account: ${realAccountId}`);\n\n      if (!this.session.credential) {\n        // === OPTION F: Need to generate WebAuthn credential + derive VRF ===\n        console.log(`LinkDeviceFlow: Option F - Generating WebAuthn credential for ${realAccountId}`);\n\n        // Generate VRF challenge for the real account (uses account ID as salt)\n        const vrfChallenge = await generateBootstrapVrfChallenge(this.context, realAccountId);\n\n        // Use device number that was discovered during polling\n        const deviceNumber = this.session.deviceNumber;\n        console.log(`LinkDeviceFlow: Using device number ${deviceNumber} for credential generation`);\n\n        // Generate WebAuthn credentials with TouchID (now that we know the real account)\n        const credential = await this.context.webAuthnManager.generateRegistrationCredentialsForLinkDevice({\n          nearAccountId: realAccountId, // Use account ID for consistent PRF salts across devices\n          deviceNumber: deviceNumber!, // Use device number discovered from contract during polling\n          challenge: vrfChallenge,\n        });\n\n        // Store credential and challenge in session for later cleanup\n        this.session.credential = credential;\n        this.session.vrfChallenge = vrfChallenge;\n\n        // Derive VRF keypair from PRF output for storage\n        const vrfDerivationResult = await this.context.webAuthnManager.deriveVrfKeypair({\n          credential: credential,\n          nearAccountId: realAccountId // Use base account ID for PRF salt consistency\n        });\n\n        if (!vrfDerivationResult.success || !vrfDerivationResult.encryptedVrfKeypair) {\n          throw new Error('Failed to derive VRF keypair from PRF for real account');\n        }\n\n        console.log(`LinkDeviceFlow: Option F - Generated proper credentials, implementing 3-step flow`);\n\n        // === STEP 1: Generate NEAR keypair (deterministic, no transaction signing) ===\n        // Use base account ID for consistent keypair derivation across devices\n        const nearKeyResultStep1 = await this.context.webAuthnManager.deriveNearKeypairAndEncrypt({\n          nearAccountId: realAccountId, // Use base account ID for consistency\n          credential: credential,\n          // No options - just generate the keypair, don't sign registration tx yet.\n          // We need the deterministic NEAR public key to get the nonce for the key replacement transaction first\n          // Then once the key replacement transaction is executed, we use the deterministic key\n          // to sign the registration transaction\n        });\n\n        if (!nearKeyResultStep1.success || !nearKeyResultStep1.publicKey) {\n          throw new Error('Failed to derive NEAR keypair in step 1');\n        }\n        console.log(`LinkDeviceFlow: Step 1 - Generated keypair: ${nearKeyResultStep1.publicKey}`);\n\n        // === STEP 2: Execute Key Replacement Transaction ===\n        const {\n          nextNonce,\n          txBlockHash,\n        } = await this.context.webAuthnManager.getNonceManager().getNonceBlockHashAndHeight(this.context.nearClient);\n\n        await this.executeKeySwapTransaction(\n          nearKeyResultStep1.publicKey,\n          nextNonce,\n          txBlockHash\n        );\n\n        // === STEP 3: Get new key's actual nonce and sign registration transaction ===\n        const {\n          nextNonce: newKeyNonce,\n          txBlockHash: newTxBlockHash,\n        } = await this.context.webAuthnManager.getNonceManager().getNonceBlockHashAndHeight(this.context.nearClient);\n        console.log(\"Key Replacement Transaction Block Hash retrieved.\");\n        console.log(\"NewKey's actual nonce >>>> newKeyNonce\", newKeyNonce);\n\n        // Generate the same keypair again (deterministic) but now with with the correct nonce for the registration transaction\n        const nearKeyResultStep3 = await this.context.webAuthnManager.deriveNearKeypairAndEncrypt({\n          nearAccountId: realAccountId, // Use base account ID for consistency\n          credential: credential,\n          options: {\n            vrfChallenge: vrfChallenge,\n            contractId: this.context.configs.contractId,\n            nonce: newKeyNonce, // Use NEW key's actual nonce for the registration transaction\n            blockHash: newTxBlockHash,\n            // Pass the deterministic VRF public key for contract call\n            deterministicVrfPublicKey: vrfDerivationResult.vrfPublicKey,\n          }\n        });\n\n        if (!nearKeyResultStep3.success || !nearKeyResultStep3.signedTransaction) {\n          throw new Error('Failed to sign registration transaction');\n        }\n\n        // === STEP 3: Broadcast Registration Transaction ===\n        console.log(`LinkDeviceFlow: Broadcasting Device2 authenticator registration transaction`);\n        const registrationTxResult = await this.context.nearClient.sendTransaction(nearKeyResultStep3.signedTransaction);\n        console.log(`LinkDeviceFlow: Device2 authenticator registered on-chain:`, registrationTxResult?.transaction?.hash);\n\n        // === OPTION F: Clean up temp account VRF data ===\n        // Clean up any temp account VRF data (Option F only)\n        if (this.session?.tempPrivateKey) {\n          try {\n            await IndexedDBManager.nearKeysDB.deleteEncryptedKey('temp-device-linking.testnet');\n            console.log(`LinkDeviceFlow: Cleaned up temp VRF credentials`);\n          } catch (err) {\n            console.warn(`️LinkDeviceFlow: Could not clean up temp VRF credentials:`, err);\n          }\n\n          // Clean up temporary private key from memory after successful completion\n          this.cleanupTemporaryKeyFromMemory();\n        }\n\n        // Return all derived values - no more session state confusion!\n        const result = {\n          encryptedVrfKeypair: vrfDerivationResult.encryptedVrfKeypair,\n          serverEncryptedVrfKeypair: vrfDerivationResult.serverEncryptedVrfKeypair,\n          vrfPublicKey: vrfDerivationResult.vrfPublicKey,\n          nearPublicKey: nearKeyResultStep1.publicKey,\n          credential: credential,\n          vrfChallenge: vrfChallenge\n        };\n\n        return result;\n\n      } else {\n        // === OPTION E: Regenerate credential with device number ===\n        console.log(`LinkDeviceFlow: Option E - Regenerating credentials with device number for ${realAccountId}`);\n\n        // Generate VRF challenge using the real accountID as PRF salt\n        const vrfChallenge = await generateBootstrapVrfChallenge(this.context, realAccountId);\n\n        // Use device number that was discovered during polling\n        const deviceNumber = this.session.deviceNumber;\n        console.log(`LinkDeviceFlow: Option E - Using device number ${deviceNumber} for credential regeneration`);\n\n        // Regenerate WebAuthn credentials with proper device number\n        const credential = await this.context.webAuthnManager.generateRegistrationCredentialsForLinkDevice({\n          nearAccountId: realAccountId, // Use base account ID for consistent PRF salts across devices\n          deviceNumber: deviceNumber!, // Use device number discovered during polling\n          challenge: vrfChallenge,\n        });\n\n        // Store regenerated credential and challenge in session\n        this.session.credential = credential;\n        this.session.vrfChallenge = vrfChallenge;\n\n        // For Option E, also derive VRF keypair from regenerated credential\n        const vrfDerivationResult = await this.context.webAuthnManager.deriveVrfKeypair({\n          credential: credential,\n          nearAccountId: realAccountId // Use base account ID for PRF salt consistency\n        });\n\n        if (!vrfDerivationResult.success || !vrfDerivationResult.encryptedVrfKeypair) {\n          throw new Error('Failed to derive VRF keypair from PRF for Option E');\n        }\n        console.log(`LinkDeviceFlow: Option E - VRF credentials derived for ${realAccountId}`);\n\n        const result = {\n          encryptedVrfKeypair: vrfDerivationResult.encryptedVrfKeypair,\n          serverEncryptedVrfKeypair: vrfDerivationResult.serverEncryptedVrfKeypair,\n          vrfPublicKey: vrfDerivationResult.vrfPublicKey,\n          nearPublicKey: this.session.nearPublicKey, // For Option E, use existing NEAR public key\n          credential: credential, // Use regenerated credential with device number\n          vrfChallenge: vrfChallenge // Use regenerated VRF challenge\n        };\n\n        return result;\n      }\n\n    } catch (error) {\n      console.error(`LinkDeviceFlow: Failed to process VRF credentials:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Execute key replacement transaction for Option F flow\n   * Replace temporary key with properly derived key using AddKey + DeleteKey\n   */\n  private async executeKeySwapTransaction(\n    newPublicKey: string,\n    nextNonce: string,\n    txBlockHash: string\n  ): Promise<void> {\n    if (!this.session?.tempPrivateKey || !this.session?.accountId) {\n      throw new Error('Missing temporary private key or account ID for key replacement');\n    }\n\n    const { tempPrivateKey, accountId, nearPublicKey: oldPublicKey } = this.session;\n\n    try {\n      console.log(`LinkDeviceFlow: Executing key replacement transaction for ${accountId}`);\n      console.log(`   - Old key: ${oldPublicKey}`);\n      console.log(`   - New key: ${newPublicKey}`);\n\n      // Build actions: AddKey new + DeleteKey old\n      const actions: ActionArgsWasm[] = [\n        {\n          action_type: ActionType.AddKey,\n          public_key: newPublicKey,\n          access_key: JSON.stringify({\n            // nonce: 0, // nonce should be 0 for the new key, specifying nonce here does not seem to do anything\n            permission: { FullAccess: {} }\n          })\n        },\n        {\n          action_type: ActionType.DeleteKey,\n          public_key: oldPublicKey\n        }\n      ];\n\n      // Use the webAuthnManager to sign with the temporary private key\n      const keySwapResult = await this.context.webAuthnManager.signTransactionWithKeyPair({\n        nearPrivateKey: tempPrivateKey,\n        signerAccountId: accountId,\n        receiverId: accountId,\n        nonce: nextNonce,\n        blockHash: txBlockHash,\n        actions\n      });\n\n      // Broadcast the transaction\n      const txResult = await this.context.nearClient.sendTransaction(\n        keySwapResult.signedTransaction,\n        DEFAULT_WAIT_STATUS.linkDeviceSwapKey\n      );\n\n      console.log(`LinkDeviceFlow: Key replacement transaction successful:`, txResult?.transaction?.hash);\n\n    } catch (error) {\n      console.error(`LinkDeviceFlow: Key replacement transaction failed:`, error);\n      throw new Error(`Key replacement failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Clean up failed linking attempts - remove any partially stored data\n   */\n  private async cleanupFailedLinkingAttempt(): Promise<void> {\n    if (!this.session) return;\n\n    try {\n      const { credential, accountId, nearPublicKey } = this.session;\n\n      console.log(`LinkDeviceFlow: Cleaning up failed linking attempt for ${accountId || 'unknown account'}`);\n\n      // Clean up temporary private key from memory first\n      this.cleanupTemporaryKeyFromMemory();\n\n      // Remove any authenticator data for both base and device-specific accounts (if they were discovered)\n      if (accountId && credential) {\n\n        try {\n          await IndexedDBManager.clientDB.deleteAllAuthenticatorsForUser(accountId);\n          console.log(`LinkDeviceFlow: Removed authenticators for ${accountId}`);\n        } catch (err) {\n          console.warn(`️LinkDeviceFlow: Could not remove authenticators for ${accountId}:`, err);\n        }\n\n        try {\n          await IndexedDBManager.clientDB.deleteUser(accountId);\n          console.log(`LinkDeviceFlow: Removed user data for ${accountId}`);\n        } catch (err) {\n          console.warn(`️LinkDeviceFlow: Could not remove user data for ${accountId}:`, err);\n        }\n\n        // Remove any VRF credentials for both device-specific and base accounts (in case re-derivation happened)\n        try {\n          await IndexedDBManager.nearKeysDB.deleteEncryptedKey(accountId);\n          console.log(`LinkDeviceFlow: Removed VRF credentials for device-specific account ${accountId}`);\n        } catch (err) {\n          console.warn(`️LinkDeviceFlow: Could not remove VRF credentials for ${accountId}:`, err);\n        }\n      }\n\n      // Always clean up temp account VRF data (this is where initial QR generation stores data)\n      try {\n        await IndexedDBManager.nearKeysDB.deleteEncryptedKey('temp-device-linking.testnet');\n        console.log(`LinkDeviceFlow: Removed temp VRF credentials`);\n      } catch (err) {\n        console.warn(`️LinkDeviceFlow: Could not remove temp VRF credentials:`, err);\n      }\n\n    } catch (error) {\n      console.error(`LinkDeviceFlow: Error during cleanup:`, error);\n    }\n  }\n\n  /**\n   * Stop polling - guaranteed to clear any existing interval\n   */\n  private stopPolling(): void {\n    if (this.pollingInterval) {\n      console.log(`LinkDeviceFlow: Stopping polling interval`);\n      clearTimeout(this.pollingInterval);\n      this.pollingInterval = undefined;\n    }\n    this.pollGeneration++;\n  }\n\n  /**\n   * Stop registration retry timeout\n   */\n  private stopRegistrationRetry(): void {\n    if (this.registrationRetryTimeout) {\n      console.log(`LinkDeviceFlow: Stopping registration retry timeout`);\n      clearTimeout(this.registrationRetryTimeout);\n      this.registrationRetryTimeout = undefined;\n    }\n  }\n\n  /**\n   * Get current flow state\n   */\n  getState() {\n    return {\n      phase: this.session?.phase,\n      session: this.session,\n      error: this.error,\n    };\n  }\n\n  /**\n   * Cancel the flow and cleanup\n   */\n  cancel(): void {\n    console.log(`LinkDeviceFlow: Cancel called`);\n    this.cancelled = true;\n    this.stopPolling();\n    this.stopRegistrationRetry();\n    this.cleanupTemporaryKeyFromMemory(); // Clean up temporary private key\n    this.session = null;\n    this.error = undefined;\n    this.registrationRetryCount = 0;\n  }\n\n  /**\n   * Reset flow to initial state\n   */\n  reset(): void {\n    this.cancel();\n  }\n}\n"],"mappings":"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"}