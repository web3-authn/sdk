{"version":3,"file":"index.js","names":["globalPasskeyManager: PasskeyManager | null","globalConfig: any","PASSKEY_MANAGER_DEFAULT_CONFIGS: PasskeyManagerConfigs","PasskeyProvider: React.FC<PasskeyContextProviderProps>","result: LoginResult","result: RegistrationResult","loginState","value: PasskeyContextType","config"],"sources":["../../../../src/react/context/index.tsx"],"sourcesContent":["import {\n  createContext,\n  useState,\n  useContext,\n  useEffect,\n  useCallback,\n  useMemo,\n} from 'react';\nimport {\n  PasskeyManager,\n  AccountRecoveryFlow,\n  DeviceLinkingPhase,\n  type SignNEP413MessageParams,\n  type SignNEP413MessageResult,\n  ActionArgs\n} from '@/index';\nimport { useNearClient } from '../hooks/useNearClient';\nimport { useAccountInput } from '../hooks/useAccountInput';\nimport { useRelayer } from '../hooks/useRelayer';\nimport type {\n  PasskeyContextType,\n  PasskeyContextProviderProps,\n  LoginState,\n  AccountInputState,\n  RegistrationResult,\n  LoginHooksOptions,\n  LoginResult,\n  RegistrationHooksOptions,\n  BaseHooksOptions,\n  ActionHooksOptions,\n  StartDeviceLinkingOptionsDevice2,\n  ScanAndLinkDeviceOptionsDevice1,\n} from '../types';\nimport { AccountRecoveryHooksOptions } from '@/core/types/passkeyManager';\nimport { PasskeyManagerConfigs } from \"@/core/types/passkeyManager\";\n\nconst PasskeyContext = createContext<PasskeyContextType | undefined>(undefined);\n\n// Global singleton to prevent multiple PasskeyManager instances in StrictMode\nlet globalPasskeyManager: PasskeyManager | null = null;\nlet globalConfig: any = null;\n\nexport const PASSKEY_MANAGER_DEFAULT_CONFIGS: PasskeyManagerConfigs = {\n  // nearRpcUrl: 'https://rpc.testnet.near.org',\n  nearRpcUrl: 'https://test.rpc.fastnear.com',\n  nearNetwork: 'testnet' as const,\n  contractId: 'web3-authn-v5.testnet',\n  nearExplorerUrl: 'https://testnet.nearblocks.io',\n  relayer: {\n    accountId: 'web3-authn-v5.testnet',\n    url: 'http://localhost:3000',\n    initialUseRelayer: true,\n  },\n  vrfWorkerConfigs: {\n    shamir3pass: {\n      // default Shamir's P in vrf-wasm-worker, needs to match relay server's Shamir P\n      p: '3N5w46AIGjGT2v5Vua_TMD5Ywfa9U2F7-WzW8SNDsIM',\n      relayServerUrl: 'http://localhost:3000',\n      applyServerLockRoute: '/vrf/apply-server-lock',\n      removeServerLockRoute: '/vrf/remove-server-lock',\n    }\n  }\n  ,\n  // By default, use a hosted wallet service origin so integrators don't need to\n  // copy any HTML. Override this in production to your wallet origin if needed.\n  // Leave undefined to run entirely sameâ€‘origin (less secure) for local dev.\n  // walletOrigin: 'https://wallet.web3authn.xyz',\n  // walletServicePath: '/service',\n}\n\nexport const PasskeyProvider: React.FC<PasskeyContextProviderProps> = ({\n  children,\n  config = PASSKEY_MANAGER_DEFAULT_CONFIGS,\n}) => {\n\n  // Authentication state (actual login status)\n  // Note: isLoggedIn is true ONLY when VRF worker has private key in memory (vrfActive = true)\n  // This means the user can generate VRF challenges without additional TouchID prompts\n  const [loginState, setLoginState] = useState<LoginState>({\n    isLoggedIn: false,\n    nearAccountId: null,\n    nearPublicKey: null,\n  });\n\n  // UI input state (separate from authentication state)\n  const [accountInputState, setAccountInputState] = useState<AccountInputState>({\n    inputUsername: '',\n    lastLoggedInUsername: '',\n    lastLoggedInDomain: '',\n    targetAccountId: '',\n    displayPostfix: '',\n    isUsingExistingAccount: false,\n    accountExists: false,\n    indexDBAccounts: []\n  });\n\n  // Get the minimal NEAR RPC provider\n  const nearClient = useNearClient();\n\n  // Initialize PasskeyManager with singleton pattern to prevent double initialization in StrictMode\n  const passkeyManager = useMemo(() => {\n\n    const finalConfig = { ...PASSKEY_MANAGER_DEFAULT_CONFIGS, ...config };\n    // Check if we already have a global instance with the same config\n    const configChanged = JSON.stringify(globalConfig) !== JSON.stringify(finalConfig);\n\n    if (!globalPasskeyManager || configChanged) {\n      console.debug('PasskeyProvider: Creating new PasskeyManager instance with config:', finalConfig);\n      globalPasskeyManager = new PasskeyManager(finalConfig, nearClient);\n      globalConfig = finalConfig;\n    } else {\n    }\n\n    return globalPasskeyManager;\n  }, [config]);\n\n  // Initialize hidden wallet service iframe when walletOrigin is provided\n  useEffect(() => {\n    (async () => {\n      try {\n        const walletOrigin = passkeyManager?.configs?.walletOrigin;\n        if (walletOrigin) {\n          await passkeyManager.initServiceIframe();\n        }\n      } catch (err) {\n        console.warn('[PasskeyProvider] Service iframe init failed:', err);\n      }\n    })();\n  }, [passkeyManager]);\n\n  // Use relayer hook\n  const relayerHook = useRelayer({\n    initialValue: config?.relayer.initialUseRelayer ?? false\n  });\n\n  // Use account input hook\n  const accountInputHook = useAccountInput({\n    passkeyManager,\n    relayerAccount: passkeyManager.configs.relayer.accountId,\n    useRelayer: relayerHook.useRelayer,\n    currentNearAccountId: loginState.nearAccountId,\n    isLoggedIn: loginState.isLoggedIn\n  });\n\n  // Sync account input hook state with account input state\n  useEffect(() => {\n    setAccountInputState({\n      inputUsername: accountInputHook.inputUsername,\n      lastLoggedInUsername: accountInputHook.lastLoggedInUsername,\n      lastLoggedInDomain: accountInputHook.lastLoggedInDomain,\n      targetAccountId: accountInputHook.targetAccountId,\n      displayPostfix: accountInputHook.displayPostfix,\n      isUsingExistingAccount: accountInputHook.isUsingExistingAccount,\n      accountExists: accountInputHook.accountExists,\n      indexDBAccounts: accountInputHook.indexDBAccounts\n    });\n  }, [\n    accountInputHook.inputUsername,\n    accountInputHook.lastLoggedInUsername,\n    accountInputHook.lastLoggedInDomain,\n    accountInputHook.targetAccountId,\n    accountInputHook.displayPostfix,\n    accountInputHook.isUsingExistingAccount,\n    accountInputHook.accountExists,\n    accountInputHook.indexDBAccounts\n  ]);\n\n  // Simple logout that only manages React state\n  const logout = useCallback(async () => {\n    try {\n      // Clear VRF session when user logs out\n      await passkeyManager.logoutAndClearVrfSession();\n    } catch (error) {\n      console.warn('VRF logout warning:', error);\n    }\n\n    setLoginState(prevState => ({\n      ...prevState,\n      isLoggedIn: false,\n      nearAccountId: null,\n      nearPublicKey: null,\n    }));\n  }, [passkeyManager]);\n\n  const loginPasskey = async (nearAccountId: string, options?: LoginHooksOptions) => {\n    const result: LoginResult = await passkeyManager.loginPasskey(nearAccountId, {\n      ...options,\n      onEvent: async (event) => {\n        if (event.phase === 'login-complete' && event.status === 'success') {\n          // Check VRF status to determine if user is truly logged in\n          const currentLoginState = await passkeyManager.getLoginState(nearAccountId);\n          const isVRFLoggedIn = currentLoginState.vrfActive;\n\n          setLoginState(prevState => ({\n            ...prevState,\n            isLoggedIn: isVRFLoggedIn,  // Only logged in if VRF is active\n            nearAccountId: event.nearAccountId || null,\n            nearPublicKey: event.clientNearPublicKey || null,\n          }));\n        }\n        options?.onEvent?.(event);\n      },\n      onError: (error) => {\n        logout();\n        options?.onError?.(error);\n      }\n    });\n\n    return result\n  }\n\n  const registerPasskey = async (nearAccountId: string, options?: RegistrationHooksOptions) => {\n    const result: RegistrationResult = await passkeyManager.registerPasskey(nearAccountId, {\n      ...options,\n      onEvent: async (event) => {\n        if (event.phase === 'registration-complete' && event.status === 'success') {\n          // Check VRF status to determine if user is truly logged in after registration\n          const currentLoginState = await passkeyManager.getLoginState(nearAccountId);\n          const isVRFLoggedIn = currentLoginState.vrfActive;\n\n          setLoginState(prevState => ({\n            ...prevState,\n            isLoggedIn: isVRFLoggedIn,  // Only logged in if VRF is active\n            nearAccountId: nearAccountId,\n            nearPublicKey: currentLoginState.publicKey || null,\n          }));\n        }\n        options?.onEvent?.(event);\n      },\n      onError: (error) => {\n        logout();\n        options?.onError?.(error);\n      }\n    });\n\n    return result;\n  }\n\n  const startAccountRecoveryFlow = (options?: AccountRecoveryHooksOptions): AccountRecoveryFlow => {\n    return passkeyManager.startAccountRecoveryFlow(options);\n  }\n\n  /**\n   * Device2: Start device linking flow\n   * @param options - DeviceLinkingOptionsDevice2\n   * @returns LinkDeviceFlow\n   */\n  const startDeviceLinkingFlow = (options?: StartDeviceLinkingOptionsDevice2) => {\n    return passkeyManager.startDeviceLinkingFlow({\n      ...options,\n      onEvent: (event) => {\n        // Call original event handler\n        options?.onEvent?.(event);\n        // Update React state when auto-login completes successfully\n        if (event.phase === DeviceLinkingPhase.STEP_7_LINKING_COMPLETE && event.status === 'success') {\n          // Refresh login state to update React context after successful auto-login\n          refreshLoginState()\n        }\n      }\n    });\n  }\n\n  const executeAction = async (args: {\n    nearAccountId: string,\n    receiverId: string,\n    actionArgs: ActionArgs,\n    options?: ActionHooksOptions\n  }) => {\n    return await passkeyManager.executeAction({\n      nearAccountId: args.nearAccountId,\n      receiverId: args.receiverId,\n      actionArgs: args.actionArgs,\n      options: args.options\n    });\n  }\n\n  const signNEP413Message = async (args: {\n    nearAccountId: string,\n    params: SignNEP413MessageParams,\n    options?: BaseHooksOptions\n  }) => {\n    return await passkeyManager.signNEP413Message({\n      nearAccountId: args.nearAccountId,\n      params: args.params,\n      options: args.options\n    });\n  }\n\n  // Function to manually refresh login state\n  const refreshLoginState = useCallback(async (nearAccountId?: string) => {\n    try {\n      const loginState = await passkeyManager.getLoginState(nearAccountId);\n\n      if (loginState.nearAccountId) {\n        // User is only logged in if VRF worker has private key in memory\n        const isVRFLoggedIn = loginState.vrfActive;\n\n        setLoginState(prevState => ({\n          ...prevState,\n          nearAccountId: loginState.nearAccountId,\n          nearPublicKey: loginState.publicKey,\n          isLoggedIn: isVRFLoggedIn  // Only logged in if VRF is active\n        }));\n      }\n    } catch (error) {\n      console.error('Error refreshing login state:', error);\n    }\n  }, [passkeyManager]);\n\n  // Load user data on mount\n  useEffect(() => {\n    refreshLoginState();\n  }, [refreshLoginState]);\n\n  const value: PasskeyContextType = {\n    // Core PasskeyManager instance - provides ALL functionality\n    passkeyManager,\n\n    // Simple login/register functions\n    registerPasskey,\n    loginPasskey,\n    logout,                      // Clears VRF session (logs out)\n\n    // Execute actions\n    executeAction,\n    // NEP-413 message signing\n    signNEP413Message,           // Sign NEP-413 messages\n\n    // Account recovery functions\n    startAccountRecoveryFlow,   // Create account recovery flow to discover accounts onchain, and recover accounts\n    // Device linking functions\n    startDeviceLinkingFlow,     // Create device linking flow for Whatsapp-style QR scan + device linking\n\n    // Login state\n    getLoginState: (nearAccountId?: string) => passkeyManager.getLoginState(nearAccountId),\n    refreshLoginState,           // Manually refresh login state\n    loginState,\n\n    // Account input management\n    // UI account name input state (form/input tracking)\n    accountInputState,\n    setInputUsername: accountInputHook.setInputUsername,\n    refreshAccountData: accountInputHook.refreshAccountData,\n    useRelayer: relayerHook.useRelayer,\n    setUseRelayer: relayerHook.setUseRelayer,\n    toggleRelayer: relayerHook.toggleRelayer,\n\n    // Confirmation configuration functions\n    setConfirmBehavior: (behavior: 'requireClick' | 'autoProceed') => passkeyManager.setConfirmBehavior(behavior),\n    setConfirmationConfig: (config: any) => passkeyManager.setConfirmationConfig(config),\n    setUserTheme: (theme: 'dark' | 'light') => passkeyManager.setUserTheme(theme),\n    getConfirmationConfig: () => passkeyManager.getConfirmationConfig(),\n\n    // Account management functions\n    viewAccessKeyList: (accountId: string) => passkeyManager.viewAccessKeyList(accountId),\n  };\n\n  return <PasskeyContext.Provider value={value}>{children}</PasskeyContext.Provider>;\n};\n\nexport const usePasskeyContext = () => {\n  const context = useContext(PasskeyContext);\n  if (context === undefined) {\n    throw new Error('usePasskeyContext must be used within a PasskeyContextProvider');\n  }\n  return context;\n};\n\n// Re-export types for convenience\nexport type {\n  PasskeyContextType,\n  ExecuteActionCallbacks,\n  RegistrationResult,\n  LoginResult,\n} from '../types';\n"],"mappings":"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"}