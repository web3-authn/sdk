{"version":3,"file":"iframe-geometry.js","names":["points: Array<{ x: number; y: number }>"],"sources":["../../../../../../../../../../src/core/WebAuthnManager/LitComponents/IframeButtonWithTooltipConfirmer/iframe-geometry.ts"],"sourcesContent":["\nexport type TooltipPositionEnum =\n  | 'top-left'\n  | 'top-center'\n  | 'top-right'\n  | 'left'\n  | 'right'\n  | 'bottom-left'\n  | 'bottom-center'\n  | 'bottom-right';\n\n// Public (external) tooltip position shape — no internal layout knobs\nexport interface TooltipPosition {\n  width: string;\n  height: string;\n  position: TooltipPositionEnum;\n}\n\n// Internal shape used by the SDK for layout calculations\nexport interface TooltipPositionInternal extends TooltipPosition {\n  offset: string;\n  boxPadding?: string; // e.g., '8px'\n}\n\nexport interface Rectangle {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  borderRadius?: number;\n}\n\nexport interface TooltipGeometry {\n  button: Rectangle;\n  tooltip: Rectangle;\n  position: TooltipPositionEnum;\n  gap: number;\n  visible: boolean;\n}\n\n/**\n * Rounding & pixel-snapping strategy\n *\n * DOM measurements from getBoundingClientRect() often contain fractional values\n * (e.g., width: 200.4px). If these are rounded the wrong way, the iframe that\n * hosts the embedded UI can end up undersized by up to 1px, which manifests as\n * a faint scrollbar or a clipped tooltip.\n *\n * To avoid this, we follow these rules across the embedded tooltip flow:\n * - Positions (x, y): Math.floor — never extend negative space; align to pixels.\n * - Sizes (width, height): Math.ceil — never shrink rectangles; ensure fit.\n *\n * The embedded element applies this when constructing TooltipGeometry from\n * DOMRects. See EmbeddedTxButton.ts (buildGeometry).\n * On the host side, computeExpandedIframeSizeFromGeometryPure()\n * already uses Math.ceil on the right/bottom edges as a second line of defense.\n */\n\n/**\n * IframeClipPathGenerator creates precise clip-path polygons for button + tooltip unions.\n * Supports all 8 tooltip positions with optimized shape algorithms.\n */\nexport class IframeClipPathGenerator {\n  static generateUnion(geometry: TooltipGeometry, paddingPx: number = 0): string {\n    // Optionally expand both rectangles by padding to loosen the clip-path\n    const pad = (r: Rectangle): Rectangle => ({\n      x: r.x - paddingPx,\n      y: r.y - paddingPx,\n      width: r.width + 2 * paddingPx,\n      height: r.height + 2 * paddingPx,\n      borderRadius: r.borderRadius,\n    });\n    const button = paddingPx ? pad(geometry.button) : geometry.button;\n    const tooltip = paddingPx ? pad(geometry.tooltip) : geometry.tooltip;\n    const { position, gap } = geometry;\n    if (!CSS.supports('clip-path: polygon(0 0)')) {\n      console.warn('clip-path not supported, skipping shape generation');\n      return '';\n    }\n    switch (position) {\n      case 'top-left': {\n        const upper = (button.y <= tooltip.y) ? button : tooltip;\n        const lower = (upper === button) ? tooltip : button;\n        return this.generateVerticalLUnion(upper, lower, 'left');\n      }\n      case 'top-center':\n        return this.generateTopCenterUnion(button, tooltip, gap);\n      case 'top-right': {\n        const upper = (button.y <= tooltip.y) ? button : tooltip;\n        const lower = (upper === button) ? tooltip : button;\n        return this.generateVerticalLUnion(upper, lower, 'right');\n      }\n      case 'left':\n        return this.generateLeftUnion(button, tooltip, gap);\n      case 'right':\n        return this.generateRightUnion(button, tooltip, gap);\n      case 'bottom-left': {\n        const upper = (button.y <= tooltip.y) ? button : tooltip;\n        const lower = (upper === button) ? tooltip : button;\n        return this.generateVerticalLUnion(upper, lower, 'left');\n      }\n      case 'bottom-center':\n        return this.generateBottomCenterUnion(button, tooltip, gap);\n      case 'bottom-right': {\n        const upper = (button.y <= tooltip.y) ? button : tooltip;\n        const lower = (upper === button) ? tooltip : button;\n        return this.generateVerticalLUnion(upper, lower, 'right');\n      }\n      default:\n        console.warn(`Unknown tooltip position: ${position}`);\n        return this.generateTopCenterUnion(button, tooltip, gap);\n    }\n  }\n\n  /**\n   * Build an L-shaped rectilinear polygon for two vertically stacked rectangles (upper over lower).\n   * The hingeSide selects which side (left|right) the connecting corridor should hug to avoid\n   * capturing the opposite empty corner.\n   */\n  private static generateVerticalLUnion(\n    upper: Rectangle,\n    lower: Rectangle,\n    hingeSide: 'left' | 'right'\n  ): string {\n    // Ensure vertical ordering (upper.y <= lower.y). If not, swap.\n    if (upper.y > lower.y) {\n      const tmp = upper; upper = lower; lower = tmp;\n    }\n\n    const uL = upper.x;\n    const uR = upper.x + upper.width;\n    const uT = upper.y;\n    const uB = upper.y + upper.height;\n\n    const lL = lower.x;\n    const lR = lower.x + lower.width;\n    const lT = lower.y;\n    const lB = lower.y + lower.height;\n\n    // If rectangles overlap in Y or overlap fully in X, fallback to bounding rect\n    const overlapY = Math.max(0, Math.min(uB, lB) - Math.max(uT, lT));\n    if (overlapY > 0) {\n      const minX = Math.min(uL, lL);\n      const maxX = Math.max(uR, lR);\n      const minY = Math.min(uT, lT);\n      const maxY = Math.max(uB, lB);\n      return `polygon(${minX}px ${minY}px, ${maxX}px ${minY}px, ${maxX}px ${maxY}px, ${minX}px ${maxY}px)`;\n    }\n\n    let points: Array<{ x: number; y: number }> = [];\n    if (hingeSide === 'left') {\n      points = [\n        { x: uL, y: uT },\n        { x: uR, y: uT },\n        { x: uR, y: uB },\n        { x: uL, y: uB },\n        { x: lL, y: uB },\n        { x: lL, y: lB },\n        { x: lR, y: lB },\n        { x: lR, y: lT },\n        { x: uL, y: lT },\n        { x: uL, y: uT },\n      ];\n    } else {\n      points = [\n        { x: uL, y: uT },\n        { x: uR, y: uT },\n        { x: uR, y: uB },\n        { x: lR, y: uB },\n        { x: lR, y: lB },\n        { x: lL, y: lB },\n        { x: lL, y: lT },\n        { x: uR, y: lT },\n        { x: uR, y: uT },\n        { x: uL, y: uT },\n      ];\n    }\n\n    const deduped = points.filter((p, i, arr) => i === 0 || !(p.x === arr[i - 1].x && p.y === arr[i - 1].y));\n    const coords = deduped.map(p => `${p.x}px ${p.y}px`).join(', ');\n    return `polygon(${coords})`;\n  }\n\n  private static generateTopCenterUnion(button: Rectangle, tooltip: Rectangle, gap: number): string {\n    const minX = Math.min(button.x, tooltip.x);\n    const maxX = Math.max(button.x + button.width, tooltip.x + tooltip.width);\n    const minY = tooltip.y;\n    const maxY = button.y + button.height;\n    const borderRadius = 2;\n    const width = maxX - minX;\n    const height = maxY - minY;\n    return `polygon(${this.createRoundedRect(minX, minY, width, height, borderRadius)})`;\n  }\n\n  private static generateBottomCenterUnion(button: Rectangle, tooltip: Rectangle, gap: number): string {\n    const minX = Math.min(button.x, tooltip.x);\n    const maxX = Math.max(button.x + button.width, tooltip.x + tooltip.width);\n    const minY = button.y;\n    const maxY = tooltip.y + tooltip.height;\n    const borderRadius = 2;\n    const width = maxX - minX;\n    const height = maxY - minY;\n    return `polygon(${this.createRoundedRect(minX, minY, width, height, borderRadius)})`;\n  }\n\n  private static generateLeftUnion(button: Rectangle, tooltip: Rectangle, gap: number): string {\n    const minX = tooltip.x;\n    const maxX = button.x + button.width;\n    const minY = Math.min(button.y, tooltip.y);\n    const maxY = Math.max(button.y + button.height, tooltip.y + tooltip.height);\n    const borderRadius = 2;\n    const width = maxX - minX;\n    const height = maxY - minY;\n    return `polygon(${this.createRoundedRect(minX, minY, width, height, borderRadius)})`;\n  }\n\n  private static generateRightUnion(button: Rectangle, tooltip: Rectangle, gap: number): string {\n    const minX = button.x;\n    const maxX = tooltip.x + tooltip.width;\n    const minY = Math.min(button.y, tooltip.y);\n    const maxY = Math.max(button.y + button.height, tooltip.y + tooltip.height);\n    const borderRadius = 2;\n    const width = maxX - minX;\n    const height = maxY - minY;\n    return `polygon(${this.createRoundedRect(minX, minY, width, height, borderRadius)})`;\n  }\n\n  public static createRoundedRect(\n    x: number, y: number, width: number, height: number, radius: number\n  ): string {\n    const r = Math.min(radius, width / 2, height / 2);\n    return [\n      `${x + r}px ${y}px`,\n      `${x + width - r}px ${y}px`,\n      `${x + width}px ${y + r}px`,\n      `${x + width}px ${y + height - r}px`,\n      `${x + width - r}px ${y + height}px`,\n      `${x + r}px ${y + height}px`,\n      `${x}px ${y + height - r}px`,\n      `${x}px ${y + r}px`\n    ].join(', ');\n  }\n\n  public static buildButtonClipPathPure(rect: { x: number; y: number; width: number; height: number }, paddingPx: number = 0): string {\n    const x = rect.x - paddingPx;\n    const y = rect.y - paddingPx;\n    const width = rect.width + 2 * paddingPx;\n    const height = rect.height + 2 * paddingPx;\n    const clipPath = `polygon(${x}px ${y}px, ${x + width}px ${y}px, ${x + width}px ${y + height}px, ${x}px ${y + height}px)`;\n    return clipPath;\n  }\n}\n\n// === Local helpers (pure) ===\n\nexport function toPx(v: string | number): string {\n  return typeof v === 'number' ? `${v}px` : v;\n}\n\nexport function utilParsePx(value: string | number): number {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') {\n    if (value === 'auto') {\n      throw new Error('Cannot parse \"auto\" value for pixel calculations. Please provide a specific pixel value.');\n    }\n    const match = value.match(/^(\\d+(?:\\.\\d+)?)px$/);\n    if (match) {\n      return parseFloat(match[1]);\n    }\n    throw new Error(`Invalid pixel value: \"${value}\". Expected format: \"123px\" or numeric value.`);\n  }\n  return 0;\n}\n\nexport function computeIframeSizePure(input: {\n  buttonWidthPx: number;\n  buttonHeightPx: number;\n  tooltipWidthPx: number;\n  tooltipHeightPx: number;\n  offsetPx: number;\n  position: TooltipPositionEnum;\n  paddingPx?: number;\n}): { width: number; height: number; flushClass: string; buttonPositionX: number; buttonPositionY: number } {\n  const p = input.paddingPx ?? 8;\n  const { buttonWidthPx: bw, buttonHeightPx: bh, tooltipWidthPx: tw, tooltipHeightPx: th, offsetPx: o, position } = input;\n  let width = 0, height = 0, buttonPositionX = 0, buttonPositionY = 0;\n  let flushClass = 'flush-top-center';\n  switch (position) {\n    case 'top-left':\n      flushClass = 'flush-bottom-left';\n      width = Math.max(bw, tw) + p; height = bh + o + th + p; buttonPositionX = 0; buttonPositionY = th + o; break;\n    case 'top-center':\n      flushClass = 'flush-bottom-center';\n      width = Math.max(bw, tw) + p; height = bh + o + th + p; buttonPositionX = (width - bw) / 2; buttonPositionY = th + o; break;\n    case 'top-right':\n      flushClass = 'flush-bottom-right';\n      width = Math.max(bw, tw) + p; height = bh + o + th + p; buttonPositionX = width - bw; buttonPositionY = th + o; break;\n    case 'left':\n      flushClass = 'flush-right';\n      width = tw + o + bw + p; height = Math.max(bh, th) + p; buttonPositionX = tw + o; buttonPositionY = (height - bh) / 2; break;\n    case 'right':\n      flushClass = 'flush-left';\n      width = bw + o + tw + p; height = Math.max(bh, th) + p; buttonPositionX = 0; buttonPositionY = (height - bh) / 2; break;\n    case 'bottom-left':\n      flushClass = 'flush-top-left';\n      width = Math.max(bw, tw) + p; height = bh + o + th + p; buttonPositionX = 0; buttonPositionY = 0; break;\n    case 'bottom-center':\n      flushClass = 'flush-top-center';\n      width = Math.max(bw, tw) + p; height = bh + o + th + p; buttonPositionX = (width - bw) / 2; buttonPositionY = 0; break;\n    case 'bottom-right':\n      flushClass = 'flush-top-right';\n      width = Math.max(bw, tw) + p; height = bh + o + th + p; buttonPositionX = width - bw; buttonPositionY = 0; break;\n  }\n  return { width, height, flushClass, buttonPositionX, buttonPositionY };\n}\n\nexport function computeExpandedIframeSizeFromGeometryPure(input: {\n  geometry: { button: { x: number; y: number; width: number; height: number }; tooltip: { x: number; y: number; width: number; height: number } };\n  paddingPx?: number;\n  fallback: { width: number; height: number };\n}): { width: number; height: number } {\n  const p = input.paddingPx ?? 8;\n  const g = input.geometry;\n  const right = Math.max(g.button.x + g.button.width, g.tooltip.x + g.tooltip.width);\n  const bottom = Math.max(g.button.y + g.button.height, g.tooltip.y + g.tooltip.height);\n  return {\n    width: Math.max(input.fallback.width, Math.ceil(right) + p),\n    height: Math.max(input.fallback.height, Math.ceil(bottom) + p)\n  };\n}\n"],"mappings":"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"}