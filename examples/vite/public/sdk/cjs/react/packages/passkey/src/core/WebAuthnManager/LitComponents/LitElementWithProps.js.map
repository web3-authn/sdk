{"version":3,"file":"LitElementWithProps.js","names":["LitElement"],"sources":["../../../../../../../../../src/core/WebAuthnManager/LitComponents/LitElementWithProps.ts"],"sourcesContent":["import { LitElement } from 'lit';\n\nexport type CSSProperties = Record<string, string | Record<string, string> | undefined>;\n\n/**\n * Drop-in replacement for LitElement that automatically handles the custom element upgrade race.\n * See lit-element-with-props.md for more details.\n * All properties defined in static properties will be automatically upgraded on mount.\n */\nexport class LitElementWithProps extends LitElement {\n\n  /**\n   * Handles the custom element upgrade race for a specific property.\n   * This method ensures that any property values set before the custom element\n   * fully upgrades are correctly re-applied through Lit's property system.\n   * @param prop - The property name to upgrade\n   */\n  private upgradeProperty(prop: string): void {\n    if (Object.prototype.hasOwnProperty.call(this, prop)) {\n      // Capture the value that was set before upgrade\n      const selfRead = this as Record<string, unknown>;\n      const value = selfRead[prop];\n\n      // Remove the property so the class getter/setter takes over\n      delete selfRead[prop];\n\n      // Re-assign through the proper setter to trigger Lit's reactivity\n      (this as Record<string, unknown>)[prop] = value;\n    }\n  }\n\n  /**\n   * Automatically upgrades all properties defined in static properties.\n   * Called automatically in connectedCallback - no manual intervention needed.\n   */\n  private upgradeAllProperties(): void {\n    const constructor = this.constructor as typeof LitElement;\n    const properties = constructor.properties;\n\n    if (properties) {\n      // Handle both object syntax and Map syntax\n      const propertyNames = properties instanceof Map\n        ? Array.from(properties.keys())\n        : Object.keys(properties);\n\n      propertyNames.forEach(prop => this.upgradeProperty(prop));\n    }\n  }\n\n  /**\n   * Generic styles property for component customization.\n   * Subclasses can override this with their specific style types.\n   */\n  styles?: ComponentStyles;\n\n  /**\n   * Lit lifecycle: Called when element is added to DOM.\n   * Automatically upgrades all defined properties to handle the upgrade race.\n   */\n  connectedCallback(): void {\n    super.connectedCallback();\n    this.upgradeAllProperties();\n\n    // Apply styles if they exist\n    if (this.styles) {\n      this.applyStyles(this.styles, this.getComponentPrefix());\n    }\n  }\n\n  /**\n   * Override this method in subclasses to return the appropriate component prefix\n   * for CSS variable naming (e.g., 'tree', 'modal', 'button').\n   */\n  protected getComponentPrefix(): string {\n    return 'component';\n  }\n\n  /**\n   * Applies CSS variables for styling. Can be overridden by subclasses for component-specific behavior.\n   * @param styles - The styles object to apply\n   * @param componentPrefix - Optional component prefix override, defaults to getComponentPrefix()\n   */\n  protected applyStyles(styles: ComponentStyles, componentPrefix?: string): void {\n    if (!styles) return;\n\n    const prefix = componentPrefix || this.getComponentPrefix();\n\n    // 1) Apply base design tokens (legacy predictable list)\n    const baseVars = [\n      'fontFamily', 'fontSize', 'color', 'backgroundColor',\n      'colorPrimary', 'colorSecondary', 'colorSuccess', 'colorWarning', 'colorError',\n      'colorBackground', 'colorSurface', 'colorBorder', 'textPrimary', 'textSecondary',\n      'fontSizeSm', 'fontSizeBase', 'fontSizeLg', 'fontSizeXl',\n      'radiusSm', 'radiusMd', 'radiusLg', 'radiusXl',\n      'gap2', 'gap3', 'gap4', 'gap6',\n      'shadowSm', 'shadowMd'\n    ];\n    baseVars.forEach((varName) => {\n      const v = styles[varName as keyof ComponentStyles];\n      if (typeof v === 'string') {\n        this.style.setProperty(`--w3a-${this.camelToKebab(varName)}`, v);\n      }\n    });\n\n    // 2) Promote any other top-level string values to host CSS vars automatically.\n    // This ensures all palette keys from base-styles (e.g., DARK_THEME) become available\n    // as --w3a-<kebab-name> without maintaining a static allowlist.\n    Object.entries(styles).forEach(([key, value]) => {\n      if (typeof value === 'string') {\n        this.style.setProperty(`--w3a-${this.camelToKebab(key)}`, value);\n      }\n    });\n\n    // Apply component-specific variables\n    Object.entries(styles).forEach(([section, sectionStyles]) => {\n      if (sectionStyles && typeof sectionStyles === 'object' && !baseVars.includes(section)) {\n        Object.entries(sectionStyles).forEach(([prop, value]) => {\n          const kebabSection = this.camelToKebab(section);\n          const kebabProp = this.camelToKebab(prop);\n          // New convention with double underscores\n          const cssVarNew = `--w3a-${prefix}__${kebabSection}__${kebabProp}`;\n          this.style.setProperty(cssVarNew, String(value));\n        });\n      }\n    });\n  }\n\n  /**\n   * Converts camelCase strings to kebab-case for CSS variables\n   */\n  camelToKebab(str: string): string {\n    return str.replace(/([A-Z])/g, '-$1').toLowerCase();\n  }\n}\n\n/**\n * Generic styles interface for component styling\n */\nexport interface ComponentStyles extends CSSProperties{\n  // Base design system variables\n  fontFamily?: string;\n  fontSize?: string;\n  color?: string;\n  backgroundColor?: string;\n\n  // Core color variables\n  colorPrimary?: string;\n  colorSecondary?: string;\n  colorSuccess?: string;\n  colorWarning?: string;\n  colorError?: string;\n  colorBackground?: string;\n  colorSurface?: string;\n  colorBorder?: string;\n  textPrimary?: string;\n  textSecondary?: string;\n\n  // Typography\n  fontSizeSm?: string;\n  fontSizeBase?: string;\n  fontSizeLg?: string;\n  fontSizeXl?: string;\n\n  // Spacing and layout\n  radiusSm?: string;\n  radiusMd?: string;\n  radiusLg?: string;\n  radiusXl?: string;\n  gap2?: string;\n  gap3?: string;\n  gap4?: string;\n  gap6?: string;\n  shadowSm?: string;\n  shadowMd?: string;\n\n  // Component-specific variables (to be extended by subclasses)\n  [key: string]: string | Record<string, string> | undefined;\n}\n"],"mappings":";;;;;;;;;AASA,IAAa,sBAAb,cAAyCA,sBAAW;;;;;;;CAQlD,AAAQ,gBAAgB,MAAoB;AAC1C,MAAI,OAAO,UAAU,eAAe,KAAK,MAAM,OAAO;GAEpD,MAAM,WAAW;GACjB,MAAM,QAAQ,SAAS;AAGvB,UAAO,SAAS;AAGhB,GAAC,KAAiC,QAAQ;;;;;;;CAQ9C,AAAQ,uBAA6B;EACnC,MAAM,cAAc,KAAK;EACzB,MAAM,aAAa,YAAY;AAE/B,MAAI,YAAY;GAEd,MAAM,gBAAgB,sBAAsB,MACxC,MAAM,KAAK,WAAW,UACtB,OAAO,KAAK;AAEhB,iBAAc,SAAQ,SAAQ,KAAK,gBAAgB;;;;;;;CAQvD;;;;;CAMA,oBAA0B;AACxB,QAAM;AACN,OAAK;AAGL,MAAI,KAAK,OACP,MAAK,YAAY,KAAK,QAAQ,KAAK;;;;;;CAQvC,AAAU,qBAA6B;AACrC,SAAO;;;;;;;CAQT,AAAU,YAAY,QAAyB,iBAAgC;AAC7E,MAAI,CAAC,OAAQ;EAEb,MAAM,SAAS,mBAAmB,KAAK;EAGvC,MAAM,WAAW;GACf;GAAc;GAAY;GAAS;GACnC;GAAgB;GAAkB;GAAgB;GAAgB;GAClE;GAAmB;GAAgB;GAAe;GAAe;GACjE;GAAc;GAAgB;GAAc;GAC5C;GAAY;GAAY;GAAY;GACpC;GAAQ;GAAQ;GAAQ;GACxB;GAAY;;AAEd,WAAS,SAAS,YAAY;GAC5B,MAAM,IAAI,OAAO;AACjB,OAAI,OAAO,MAAM,SACf,MAAK,MAAM,YAAY,SAAS,KAAK,aAAa,YAAY;;AAOlE,SAAO,QAAQ,QAAQ,SAAS,CAAC,KAAK,WAAW;AAC/C,OAAI,OAAO,UAAU,SACnB,MAAK,MAAM,YAAY,SAAS,KAAK,aAAa,QAAQ;;AAK9D,SAAO,QAAQ,QAAQ,SAAS,CAAC,SAAS,mBAAmB;AAC3D,OAAI,iBAAiB,OAAO,kBAAkB,YAAY,CAAC,SAAS,SAAS,SAC3E,QAAO,QAAQ,eAAe,SAAS,CAAC,MAAM,WAAW;IACvD,MAAM,eAAe,KAAK,aAAa;IACvC,MAAM,YAAY,KAAK,aAAa;IAEpC,MAAM,YAAY,SAAS,OAAO,IAAI,aAAa,IAAI;AACvD,SAAK,MAAM,YAAY,WAAW,OAAO;;;;;;;CASjD,aAAa,KAAqB;AAChC,SAAO,IAAI,QAAQ,YAAY,OAAO"}