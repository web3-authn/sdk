{"version":3,"file":"actions.js","names":[],"sources":["../../../../../../../../src/core/types/actions.ts"],"sourcesContent":["import { AccountId } from \"./accountIds\";\n\n// === TRANSACTION INPUT INTERFACES ===\n\nexport interface TransactionInput {\n  receiverId: string;\n  actions: ActionArgs[],\n}\n\nexport interface TransactionInputWasm {\n  receiverId: string;\n  actions: ActionArgsWasm[],\n  nonce?: string; // Optional - computed in confirmation flow if not provided\n}\n\n/**\n * Enum for all supported NEAR action types\n * Provides type safety and better developer experience\n */\nexport enum ActionType {\n  CreateAccount = \"CreateAccount\",\n  DeployContract = \"DeployContract\",\n  FunctionCall = \"FunctionCall\",\n  Transfer = \"Transfer\",\n  Stake = \"Stake\",\n  AddKey = \"AddKey\",\n  DeleteKey = \"DeleteKey\",\n  DeleteAccount = \"DeleteAccount\",\n}\n\nexport enum TxExecutionStatus {\n  NONE = 'NONE',\n  INCLUDED = 'INCLUDED',\n  INCLUDED_FINAL = 'INCLUDED_FINAL',\n  EXECUTED = 'EXECUTED',\n  FINAL = 'FINAL',\n  EXECUTED_OPTIMISTIC = 'EXECUTED_OPTIMISTIC'\n}\n\n// === ACTION INTERFACES (camelCase for JS) ===\n\nexport interface FunctionCallAction {\n  type: ActionType.FunctionCall;\n  /** Name of the contract method to call */\n  methodName: string;\n  /** Arguments to pass to the method (will be JSON.stringify'd automatically) */\n  args: Record<string, any>;\n  /** Maximum gas to use for this call (default: '30000000000000' 30 TGas) */\n  gas?: string;\n  /** Amount of NEAR tokens to attach in yoctoNEAR (default: '0') */\n  deposit?: string;\n}\n\nexport interface TransferAction {\n  type: ActionType.Transfer;\n  /** Amount of NEAR tokens to transfer in yoctoNEAR */\n  amount: string;\n}\n\nexport interface CreateAccountAction {\n  type: ActionType.CreateAccount;\n}\n\nexport interface DeployContractAction {\n  type: ActionType.DeployContract;\n  /** Contract code as Uint8Array or base64 string */\n  code: Uint8Array | string;\n}\n\nexport interface StakeAction {\n  type: ActionType.Stake;\n  /** Amount to stake in yoctoNEAR */\n  stake: string;\n  /** Public key of the validator */\n  publicKey: string;\n}\n\nexport interface AddKeyAction {\n  type: ActionType.AddKey;\n  /** Public key to add */\n  publicKey: string;\n  /** Access key configuration */\n  accessKey: {\n    /** Starting nonce for the key */\n    nonce?: number;\n    /** Permission level for the key */\n    permission: 'FullAccess' | {\n      /** Function call permissions */\n      FunctionCall: {\n        /** Maximum allowance in yoctoNEAR (optional for unlimited) */\n        allowance?: string;\n        /** Contract that can be called (default: same as receiverId) */\n        receiverId?: string;\n        /** Method names that can be called (empty array = all methods) */\n        methodNames?: string[];\n      };\n    };\n  };\n}\n\nexport interface DeleteKeyAction {\n  type: ActionType.DeleteKey;\n  /** Public key to remove */\n  publicKey: string;\n}\n\nexport interface DeleteAccountAction {\n  type: ActionType.DeleteAccount;\n  /** Account that will receive the remaining balance */\n  beneficiaryId: string;\n}\n\n/**\n * Action types for all NEAR actions\n * camelCase for JS\n */\nexport type ActionArgs =\n  | FunctionCallAction\n  | TransferAction\n  | CreateAccountAction\n  | DeployContractAction\n  | StakeAction\n  | AddKeyAction\n  | DeleteKeyAction\n  | DeleteAccountAction;\n\n// === ACTION TYPES ===\n\n// ActionArgsWasm matches the Rust enum structure exactly\n// snake_case for wasm\nexport type ActionArgsWasm =\n  | { action_type: ActionType.CreateAccount }\n  | { action_type: ActionType.DeployContract; code: number[] }\n  | {\n      action_type: ActionType.FunctionCall;\n      method_name: string;\n      args: string; // JSON string, not object\n      gas: string;\n      deposit: string;\n    }\n  | { action_type: ActionType.Transfer; deposit: string }\n  | { action_type: ActionType.Stake; stake: string; public_key: string }\n  | { action_type: ActionType.AddKey; public_key: string; access_key: string }\n  | { action_type: ActionType.DeleteKey; public_key: string }\n  | { action_type: ActionType.DeleteAccount; beneficiary_id: string }\n\nexport function isActionArgsWasm(a?: any): a is ActionArgsWasm {\n  return a && typeof a === 'object' && 'action_type' in a\n}\n\nexport function toActionArgsWasm(action: ActionArgs): ActionArgsWasm {\n  switch (action.type) {\n    case ActionType.Transfer:\n      return {\n        action_type: ActionType.Transfer,\n        deposit: action.amount\n      };\n\n    case ActionType.FunctionCall:\n      return {\n        action_type: ActionType.FunctionCall,\n        method_name: action.methodName,\n        args: JSON.stringify(action.args),\n        gas: action.gas || \"30000000000000\",\n        deposit: action.deposit || \"0\"\n      };\n\n    case ActionType.AddKey:\n      // Ensure access key has proper format with nonce and permission object\n      const accessKey = {\n        nonce: action.accessKey.nonce || 0,\n        permission: action.accessKey.permission === 'FullAccess'\n          ? { FullAccess: {} }\n          : action.accessKey.permission // For FunctionCall permissions, pass as-is\n      };\n      return {\n        action_type: ActionType.AddKey,\n        public_key: action.publicKey,\n        access_key: JSON.stringify(accessKey)\n      };\n\n    case ActionType.DeleteKey:\n      return {\n        action_type: ActionType.DeleteKey,\n        public_key: action.publicKey\n      };\n\n    case ActionType.CreateAccount:\n      return {\n        action_type: ActionType.CreateAccount\n      };\n\n    case ActionType.DeleteAccount:\n      return {\n        action_type: ActionType.DeleteAccount,\n        beneficiary_id: action.beneficiaryId\n      };\n\n    case ActionType.DeployContract:\n      return {\n        action_type: ActionType.DeployContract,\n        code: typeof action.code === 'string'\n          ? Array.from(new TextEncoder().encode(action.code))\n          : Array.from(action.code)\n      };\n\n    case ActionType.Stake:\n      return {\n        action_type: ActionType.Stake,\n        stake: action.stake,\n        public_key: action.publicKey\n      };\n\n    default:\n      throw new Error(`Action type ${(action as any).type} is not supported`);\n  }\n}\n\n// === ACTION TYPE VALIDATION ===\n\n/**\n * Validate action parameters before sending to worker\n */\nexport function validateActionArgsWasm(actionArgsWasm: ActionArgsWasm): void {\n  switch (actionArgsWasm.action_type) {\n    case ActionType.FunctionCall:\n      if (!actionArgsWasm.method_name) {\n        throw new Error('method_name required for FunctionCall');\n      }\n      if (!actionArgsWasm.args) {\n        throw new Error('args required for FunctionCall');\n      }\n      if (!actionArgsWasm.gas) {\n        throw new Error('gas required for FunctionCall');\n      }\n      if (!actionArgsWasm.deposit) {\n        throw new Error('deposit required for FunctionCall');\n      }\n      // Validate args is valid JSON string\n      try {\n        JSON.parse(actionArgsWasm.args);\n      } catch {\n        throw new Error('FunctionCall action args must be valid JSON string');\n      }\n      break;\n    case ActionType.Transfer:\n      if (!actionArgsWasm.deposit) {\n        throw new Error('deposit required for Transfer');\n      }\n      break;\n    case ActionType.CreateAccount:\n      // No additional validation needed\n      break;\n    case ActionType.DeployContract:\n      if (!actionArgsWasm.code || actionArgsWasm.code.length === 0) {\n        throw new Error('code required for DeployContract');\n      }\n      break;\n    case ActionType.Stake:\n      if (!actionArgsWasm.stake) {\n        throw new Error('stake amount required for Stake');\n      }\n      if (!actionArgsWasm.public_key) {\n        throw new Error('public_key required for Stake');\n      }\n      break;\n    case ActionType.AddKey:\n      if (!actionArgsWasm.public_key) {\n        throw new Error('public_key required for AddKey');\n      }\n      if (!actionArgsWasm.access_key) {\n        throw new Error('access_key required for AddKey');\n      }\n      break;\n    case ActionType.DeleteKey:\n      if (!actionArgsWasm.public_key) {\n        throw new Error('public_key required for DeleteKey');\n      }\n      break;\n    case ActionType.DeleteAccount:\n      if (!actionArgsWasm.beneficiary_id) {\n        throw new Error('beneficiary_id required for DeleteAccount');\n      }\n      break;\n    default:\n      throw new Error(`Unsupported action type: ${(actionArgsWasm as any).action_type}`);\n  }\n}\n\n// === CONVERSIONS: WASM -> JS ACTIONS ===\n\n/**\n * Convert a single ActionArgsWasm (snake_case, stringified fields) to ActionArgs (camelCase, typed fields)\n */\nexport function fromActionArgsWasm(a: ActionArgsWasm): ActionArgs {\n  switch (a.action_type) {\n    case ActionType.FunctionCall: {\n      let parsedArgs: Record<string, any> = {};\n      try {\n        parsedArgs = a.args ? JSON.parse(a.args) : {};\n      } catch {\n        // leave as empty object if parsing fails\n        parsedArgs = {};\n      }\n      return {\n        type: ActionType.FunctionCall,\n        methodName: a.method_name,\n        args: parsedArgs,\n        gas: a.gas,\n        deposit: a.deposit\n      };\n    }\n    case ActionType.Transfer:\n      return {\n        type: ActionType.Transfer,\n        amount: a.deposit\n      };\n    case ActionType.CreateAccount:\n      return {\n        type: ActionType.CreateAccount\n      };\n    case ActionType.DeployContract: {\n      // Represent code as Uint8Array for consistency\n      const codeBytes = Array.isArray(a.code) ? new Uint8Array(a.code) : new Uint8Array();\n      return {\n        type: ActionType.DeployContract,\n        code: codeBytes\n      };\n    }\n    case ActionType.Stake:\n      return {\n        type: ActionType.Stake,\n        stake: a.stake,\n        publicKey: a.public_key\n      };\n    case ActionType.AddKey: {\n      // access_key is a JSON string of { nonce, permission: { FullAccess: {} } | { FunctionCall: {...} } }\n      let accessKey: any;\n      try {\n        accessKey = JSON.parse(a.access_key);\n      } catch {\n        accessKey = { nonce: 0, permission: { FullAccess: {} } };\n      }\n      // Normalize permission back to SDK shape\n      const permission: any = accessKey?.permission;\n      let normalizedPermission: 'FullAccess' | { FunctionCall: { allowance?: string; receiverId?: string; methodNames?: string[] } } = 'FullAccess';\n      if (permission && typeof permission === 'object') {\n        if ('FullAccess' in permission) {\n          normalizedPermission = 'FullAccess';\n        } else if ('FunctionCall' in permission) {\n          const fc = permission.FunctionCall || {};\n          normalizedPermission = {\n            FunctionCall: {\n              allowance: fc.allowance,\n              receiverId: fc.receiver_id ?? fc.receiverId,\n              methodNames: fc.method_names ?? fc.methodNames\n            }\n          };\n        }\n      }\n      return {\n        type: ActionType.AddKey,\n        publicKey: a.public_key,\n        accessKey: {\n          nonce: typeof accessKey?.nonce === 'number' ? accessKey.nonce : 0,\n          permission: normalizedPermission\n        }\n      };\n    }\n    case ActionType.DeleteKey:\n      return {\n        type: ActionType.DeleteKey,\n        publicKey: a.public_key\n      };\n    case ActionType.DeleteAccount:\n      return {\n        type: ActionType.DeleteAccount,\n        beneficiaryId: a.beneficiary_id\n      };\n    default:\n      // Exhaustive guard\n      throw new Error(`Unsupported wasm action_type: ${(a as any)?.action_type}`);\n  }\n}\n\n/** Convert a TransactionInputWasm structure to TransactionInput */\nexport function fromTransactionInputWasm(tx: TransactionInputWasm): TransactionInput {\n  return {\n    receiverId: tx.receiverId,\n    actions: tx.actions.map(fromActionArgsWasm)\n  };\n}\n\n/** Convert an array of TransactionInputWasm to TransactionInput[] */\nexport function fromTransactionInputsWasm(txs: TransactionInputWasm[]): TransactionInput[] {\n  return (txs || []).map(fromTransactionInputWasm);\n}\n"],"mappings":";;;;;;AAmBA,IAAY,oDAAL;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGF,IAAY,kEAAL;AACL;AACA;AACA;AACA;AACA;AACA;;;AAkHF,SAAgB,iBAAiB,QAAoC;AACnE,SAAQ,OAAO,MAAf;EACE,KAAK,WAAW,SACd,QAAO;GACL,aAAa,WAAW;GACxB,SAAS,OAAO;;EAGpB,KAAK,WAAW,aACd,QAAO;GACL,aAAa,WAAW;GACxB,aAAa,OAAO;GACpB,MAAM,KAAK,UAAU,OAAO;GAC5B,KAAK,OAAO,OAAO;GACnB,SAAS,OAAO,WAAW;;EAG/B,KAAK,WAAW;GAEd,MAAM,YAAY;IAChB,OAAO,OAAO,UAAU,SAAS;IACjC,YAAY,OAAO,UAAU,eAAe,eACxC,EAAE,YAAY,OACd,OAAO,UAAU;;AAEvB,UAAO;IACL,aAAa,WAAW;IACxB,YAAY,OAAO;IACnB,YAAY,KAAK,UAAU;;EAG/B,KAAK,WAAW,UACd,QAAO;GACL,aAAa,WAAW;GACxB,YAAY,OAAO;;EAGvB,KAAK,WAAW,cACd,QAAO,EACL,aAAa,WAAW;EAG5B,KAAK,WAAW,cACd,QAAO;GACL,aAAa,WAAW;GACxB,gBAAgB,OAAO;;EAG3B,KAAK,WAAW,eACd,QAAO;GACL,aAAa,WAAW;GACxB,MAAM,OAAO,OAAO,SAAS,WACzB,MAAM,KAAK,IAAI,cAAc,OAAO,OAAO,SAC3C,MAAM,KAAK,OAAO;;EAG1B,KAAK,WAAW,MACd,QAAO;GACL,aAAa,WAAW;GACxB,OAAO,OAAO;GACd,YAAY,OAAO;;EAGvB,QACE,OAAM,IAAI,MAAM,eAAgB,OAAe,KAAK;;;;;;AAS1D,SAAgB,uBAAuB,gBAAsC;AAC3E,SAAQ,eAAe,aAAvB;EACE,KAAK,WAAW;AACd,OAAI,CAAC,eAAe,YAClB,OAAM,IAAI,MAAM;AAElB,OAAI,CAAC,eAAe,KAClB,OAAM,IAAI,MAAM;AAElB,OAAI,CAAC,eAAe,IAClB,OAAM,IAAI,MAAM;AAElB,OAAI,CAAC,eAAe,QAClB,OAAM,IAAI,MAAM;AAGlB,OAAI;AACF,SAAK,MAAM,eAAe;WACpB;AACN,UAAM,IAAI,MAAM;;AAElB;EACF,KAAK,WAAW;AACd,OAAI,CAAC,eAAe,QAClB,OAAM,IAAI,MAAM;AAElB;EACF,KAAK,WAAW,cAEd;EACF,KAAK,WAAW;AACd,OAAI,CAAC,eAAe,QAAQ,eAAe,KAAK,WAAW,EACzD,OAAM,IAAI,MAAM;AAElB;EACF,KAAK,WAAW;AACd,OAAI,CAAC,eAAe,MAClB,OAAM,IAAI,MAAM;AAElB,OAAI,CAAC,eAAe,WAClB,OAAM,IAAI,MAAM;AAElB;EACF,KAAK,WAAW;AACd,OAAI,CAAC,eAAe,WAClB,OAAM,IAAI,MAAM;AAElB,OAAI,CAAC,eAAe,WAClB,OAAM,IAAI,MAAM;AAElB;EACF,KAAK,WAAW;AACd,OAAI,CAAC,eAAe,WAClB,OAAM,IAAI,MAAM;AAElB;EACF,KAAK,WAAW;AACd,OAAI,CAAC,eAAe,eAClB,OAAM,IAAI,MAAM;AAElB;EACF,QACE,OAAM,IAAI,MAAM,4BAA6B,eAAuB"}