{"version":3,"file":"index.js","names":["PasskeyClientDBManager","PasskeyNearKeysDBManager"],"sources":["../../../../../../../../src/core/IndexedDBManager/index.ts"],"sourcesContent":["// === EXPORTS ===\nexport { PasskeyClientDBManager } from './passkeyClientDB';\nexport { PasskeyNearKeysDBManager } from './passkeyNearKeysDB';\n\n// Re-export types for convenience\nexport type {\n  ClientUserData,\n  UserPreferences,\n  ClientAuthenticatorData,\n  IndexedDBEvent\n} from './passkeyClientDB';\n\nexport type {\n  EncryptedKeyData\n} from './passkeyNearKeysDB';\n\nimport { AccountId } from '../types/accountIds';\n// === SINGLETON INSTANCES ===\nimport { PasskeyClientDBManager, type ClientUserData } from './passkeyClientDB';\nimport { PasskeyNearKeysDBManager, type EncryptedKeyData } from './passkeyNearKeysDB';\n\n// Export singleton instances for backward compatibility with existing code\nexport const passkeyClientDB = new PasskeyClientDBManager();\nexport const passkeyNearKeysDB = new PasskeyNearKeysDBManager();\n\n// === UNIFIED INTERFACE ===\n/**\n * Unified IndexedDB interface providing access to both databases\n * This allows centralized access while maintaining separation of concerns\n */\nexport class UnifiedIndexedDBManager {\n  public readonly clientDB: PasskeyClientDBManager;\n  public readonly nearKeysDB: PasskeyNearKeysDBManager;\n  private _initialized = false;\n\n  constructor() {\n    this.clientDB = passkeyClientDB;\n    this.nearKeysDB = passkeyNearKeysDB;\n  }\n\n  /**\n   * Initialize both databases proactively\n   * This ensures both databases are created and ready for use\n   */\n  async initialize(): Promise<void> {\n    if (this._initialized) {\n      return;\n    }\n\n    try {\n      // Initialize both databases by calling a simple operation\n      // This will trigger the getDB() method in both managers and ensure databases are created\n      await Promise.all([\n        this.clientDB.getAppState('_init_check'),\n        this.nearKeysDB.hasEncryptedKey('_init_check')\n      ]);\n\n      this._initialized = true;\n    } catch (error) {\n      console.warn('Failed to initialize IndexedDB databases:', error);\n      // Don't throw - allow the SDK to continue working, databases will be initialized on first use\n    }\n  }\n\n  /**\n   * Check if databases have been initialized\n   */\n  get isInitialized(): boolean {\n    return this._initialized;\n  }\n\n  // === CONVENIENCE METHODS ===\n\n  /**\n   * Get user data and check if they have encrypted NEAR keys\n   */\n  async getUserWithKeys(nearAccountId: AccountId): Promise<{\n    userData: ClientUserData | null;\n    hasKeys: boolean;\n    keyData?: EncryptedKeyData | null;\n  }> {\n    const [userData, hasKeys, keyData] = await Promise.all([\n      this.clientDB.getUser(nearAccountId),\n      this.nearKeysDB.hasEncryptedKey(nearAccountId),\n      this.nearKeysDB.getEncryptedKey(nearAccountId)\n    ]);\n\n    return {\n      userData,\n      hasKeys,\n      keyData: hasKeys ? keyData : undefined\n    };\n  }\n}\n\n// Export singleton instance of unified manager\nexport const IndexedDBManager = new UnifiedIndexedDBManager();\n\n// Initialize databases proactively when the module is imported\n// This ensures both databases are created and available immediately\nIndexedDBManager.initialize().catch(error => {\n  console.warn('Failed to proactively initialize IndexedDB on module load:', error);\n});"],"mappings":";;;;AAsBA,MAAa,kBAAkB,IAAIA;AACnC,MAAa,oBAAoB,IAAIC;;;;;AAOrC,IAAa,0BAAb,MAAqC;CACnC,AAAgB;CAChB,AAAgB;CAChB,AAAQ,eAAe;CAEvB,cAAc;AACZ,OAAK,WAAW;AAChB,OAAK,aAAa;;;;;;CAOpB,MAAM,aAA4B;AAChC,MAAI,KAAK,aACP;AAGF,MAAI;AAGF,SAAM,QAAQ,IAAI,CAChB,KAAK,SAAS,YAAY,gBAC1B,KAAK,WAAW,gBAAgB;AAGlC,QAAK,eAAe;WACb,OAAO;AACd,WAAQ,KAAK,6CAA6C;;;;;;CAQ9D,IAAI,gBAAyB;AAC3B,SAAO,KAAK;;;;;CAQd,MAAM,gBAAgB,eAInB;EACD,MAAM,CAAC,UAAU,SAAS,WAAW,MAAM,QAAQ,IAAI;GACrD,KAAK,SAAS,QAAQ;GACtB,KAAK,WAAW,gBAAgB;GAChC,KAAK,WAAW,gBAAgB;;AAGlC,SAAO;GACL;GACA;GACA,SAAS,UAAU,UAAU;;;;AAMnC,MAAa,mBAAmB,IAAI;AAIpC,iBAAiB,aAAa,OAAM,UAAS;AAC3C,SAAQ,KAAK,8DAA8D"}