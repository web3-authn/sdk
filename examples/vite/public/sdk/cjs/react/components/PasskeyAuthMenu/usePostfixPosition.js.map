{"version":3,"file":"usePostfixPosition.js","names":[],"sources":["../../../../../src/react/components/PasskeyAuthMenu/usePostfixPosition.ts"],"sourcesContent":["import { useCallback, useLayoutEffect, useRef } from 'react';\n\nexport interface UsePostfixPositionOptions {\n  /** The current input text value */\n  inputValue: string;\n  /** Gap in pixels between the typed text and the postfix */\n  gap?: number;\n  /** Extra padding added to input's right side beyond postfix width */\n  paddingBuffer?: number;\n}\n\nexport interface UsePostfixPositionReturn {\n  /** Callback ref for the input element */\n  bindInput: (el: HTMLInputElement | null) => void;\n  /** Callback ref for the postfix span element */\n  bindPostfix: (el: HTMLSpanElement | null) => void;\n}\n\n/**\n * Hook to handle dynamic positioning of a postfix element relative to input text\n *\n * This hook calculates the width of the input text and positions the postfix\n * element immediately after the text, creating an inline domain display effect.\n *\n * This is a self-contained variant that manages its own refs via callback refs.\n * It's more robust when multiple inputs exist on the page, since each hook\n * instance maintains its own element references, measurer, and observers.\n *\n * ⚠️  TIMING CRITICAL: The useLayoutEffect MUST depend on [inputRef.current, postfixRef.current]\n *     because refs are null on first mount and only become available after DOM elements\n *     are created. Without these dependencies, the effect runs once with null refs and\n *     exits early, causing postfix to never show on first page load.\n */\nexport function usePostfixPosition({ inputValue, gap = 1, paddingBuffer = 4 }: UsePostfixPositionOptions): UsePostfixPositionReturn {\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const postfixRef = useRef<HTMLSpanElement | null>(null);\n  const prevValueRef = useRef<string>('');\n  // Off-DOM canvas for text measurement (avoids inserting hidden spans)\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const ctxRef = useRef<CanvasRenderingContext2D | null>(null);\n  const resizeObserverRef = useRef<ResizeObserver | null>(null);\n  const rafRef = useRef<number | null>(null);\n  const rafRef2 = useRef<number | null>(null);\n\n  const schedule = (fn: () => void) => {\n    if (rafRef.current) cancelAnimationFrame(rafRef.current);\n    if (rafRef2.current) cancelAnimationFrame(rafRef2.current);\n    rafRef.current = requestAnimationFrame(() => {\n      rafRef2.current = requestAnimationFrame(fn);\n    });\n  };\n\n  const measureAndPosition = () => {\n    const input = inputRef.current;\n    const postfix = postfixRef.current;\n\n    // Always clear padding when value is empty or elements are missing\n    if (!inputValue || inputValue.length === 0) {\n      if (input) input.style.paddingRight = '';\n      if (postfix) postfix.style.visibility = 'hidden';\n      return;\n    }\n\n    // If we cannot measure, ensure padding is not left behind\n    if (!input || !postfix) {\n      if (input) input.style.paddingRight = '';\n      return;\n    }\n\n    const cs = window.getComputedStyle(input);\n    // Prepare canvas context with computed font\n    let ctx = ctxRef.current;\n    if (!ctx) {\n      canvasRef.current = document.createElement('canvas');\n      ctx = canvasRef.current.getContext('2d');\n      ctxRef.current = ctx;\n    }\n    let textWidth = 0;\n    if (ctx) {\n      // Fallback if cs.font is empty: build from parts\n      const fontString = cs.font && cs.font !== ''\n        ? cs.font\n        : `${cs.fontStyle || ''} ${cs.fontVariant || ''} ${cs.fontWeight || ''} ${cs.fontSize || '16px'} / ${cs.lineHeight || 'normal'} ${cs.fontFamily || 'sans-serif'}`;\n      ctx.font = fontString;\n      // Measure only up to caret to avoid dependence on timing of scrollLeft updates\n      const caret = (input as HTMLInputElement).selectionStart ?? inputValue.length;\n      // Respect text-transform for width calculation\n      let toMeasure = inputValue.slice(0, caret);\n      switch (cs.textTransform) {\n        case 'uppercase':\n          toMeasure = inputValue.toUpperCase();\n          break;\n        case 'lowercase':\n          toMeasure = inputValue.toLowerCase();\n          break;\n        case 'capitalize':\n          toMeasure = inputValue.replace(/\\b(\\p{L})/gu, (m) => m.toUpperCase());\n          break;\n      }\n      textWidth = ctx.measureText(toMeasure).width;\n      // Approximate letter-spacing impact if set\n      if (cs.letterSpacing && cs.letterSpacing !== 'normal') {\n        const ls = parseFloat(cs.letterSpacing) || 0;\n        if (ls !== 0 && toMeasure.length > 1) {\n          textWidth += ls * (toMeasure.length - 1);\n        }\n      }\n    }\n\n    const inputPaddingLeft = parseFloat(cs.paddingLeft) || 0;\n    const inputBorderLeft = parseFloat(cs.borderLeftWidth) || 0;\n    // Account for horizontal scroll so postfix stays attached to visible text end\n    const scrollLeft = (input as any).scrollLeft || 0;\n    const calculatedLeft = inputPaddingLeft + inputBorderLeft + Math.max(0, textWidth - scrollLeft) + gap;\n\n    postfix.style.left = `${calculatedLeft}px`;\n    postfix.style.visibility = 'visible';\n\n    // Do not modify input padding-right; avoid squishing the visible text width\n    // Overlap is prevented by positioning the postfix after the visible text end\n  };\n\n  useLayoutEffect(() => {\n    const input = inputRef.current;\n    const postfix = postfixRef.current;\n    if (!input || !postfix) {\n      return;\n    }\n\n    const ro = new ResizeObserver(() => schedule(measureAndPosition));\n    resizeObserverRef.current = ro;\n    ro.observe(input);\n    ro.observe(postfix);\n\n    // Initial and font-ready scheduling\n    schedule(measureAndPosition);\n    // @ts-ignore fonts API may not exist\n    if (document && (document as any).fonts && (document as any).fonts.ready) {\n      // @ts-ignore\n      (document as any).fonts.ready.then(() => schedule(measureAndPosition)).catch(() => {});\n    }\n\n    const onResize = () => schedule(measureAndPosition);\n    const onScroll = () => schedule(measureAndPosition);\n    const onSelect = () => schedule(measureAndPosition);\n    input.addEventListener('scroll', onScroll);\n    input.addEventListener('select', onSelect);\n    window.addEventListener('resize', onResize);\n\n    return () => {\n      window.removeEventListener('resize', onResize);\n      try { input.removeEventListener('scroll', onScroll); } catch {}\n      try { input.removeEventListener('select', onSelect); } catch {}\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.disconnect();\n        resizeObserverRef.current = null;\n      }\n      if (inputRef.current) {\n        inputRef.current.style.paddingRight = '';\n      }\n      if (rafRef.current) cancelAnimationFrame(rafRef.current);\n      if (rafRef2.current) cancelAnimationFrame(rafRef2.current);\n      ctxRef.current = null;\n      canvasRef.current = null;\n    };\n  }, [\n    // CRITICAL: These dependencies ensure the effect runs when refs become available\n    // Without these, the effect only runs once on mount when refs are still null\n    // This was the root cause of postfix not showing on first page load\n    inputRef.current,\n    postfixRef.current\n  ]);\n\n  // This effect handles repositioning when the input value changes\n  // It can use inputValue directly since the main effect already set up the measurer\n  useLayoutEffect(() => {\n    const prev = prevValueRef.current || '';\n    const now = inputValue || '';\n    // Only do a synchronous measure for the first character to eliminate\n    // the empty → 1 char flash. For all other edits (including deletions),\n    // rely on rAF + scroll listener to avoid measuring before scrollLeft\n    // has settled, which causes a second jump.\n    if (prev.length === 0 && now.length === 1) {\n      try { measureAndPosition(); } catch {}\n    }\n    schedule(measureAndPosition);\n    prevValueRef.current = now;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [inputValue]);\n\n  const bindInput = useCallback((el: HTMLInputElement | null) => {\n    inputRef.current = el;\n  }, []);\n\n  const bindPostfix = useCallback((el: HTMLSpanElement | null) => {\n    postfixRef.current = el;\n  }, []);\n\n  return { bindInput, bindPostfix };\n}\n"],"mappings":"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"}