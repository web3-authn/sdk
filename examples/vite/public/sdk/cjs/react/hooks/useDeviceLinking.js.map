{"version":3,"file":"useDeviceLinking.js","names":["usePasskeyContext","DeviceLinkingPhase","DeviceLinkingStatus","pollingInterval: NodeJS.Timeout | null","deleteKeyTimeout: NodeJS.Timeout | null","linkingError: any"],"sources":["../../../../src/react/hooks/useDeviceLinking.ts"],"sourcesContent":["import { useRef, useCallback } from 'react';\nimport { usePasskeyContext } from '../context';\nimport {\n  DeviceLinkingPhase,\n  DeviceLinkingStatus,\n  type DeviceLinkingQRData,\n  type LinkDeviceResult,\n  type DeviceLinkingSSEEvent\n} from '@/index';\nimport { QRScanMode } from '@/react/hooks/useQRCamera';\n\n/**\n * Device Linking Hook\n *\n * Provides device linking functionality with QR code scanning and transaction management.\n *\n * **Important:** This hook must be used inside a PasskeyManager context.\n * Wrap your app with PasskeyProvider or ensure PasskeyManager is available in context.\n *\n * @example\n * ```tsx\n * import { PasskeyProvider } from '@web3authn/passkey/react';\n * import { useDeviceLinking } from '@web3authn/passkey/react';\n *\n * function DeviceLinker() {\n *   const { linkDevice } = useDeviceLinking({\n *     onDeviceLinked: (result) => console.log('Device linked:', result),\n *     onError: (error) => console.error('Error:', error)\n *   });\n *\n *   return <button onClick={() => linkDevice(qrData, QRScanMode.CAMERA)}>\n *     Link Device\n *   </button>;\n * }\n * ```\n */\nexport interface UseDeviceLinkingOptions {\n  onDeviceLinked?: (result: LinkDeviceResult) => void;\n  onError?: (error: Error) => void;\n  onClose?: () => void;\n  onEvent?: (event: DeviceLinkingSSEEvent) => void;\n  fundingAmount?: string;\n}\n\nexport interface UseDeviceLinkingReturn {\n  linkDevice: (qrData: DeviceLinkingQRData, source: QRScanMode) => Promise<void>;\n}\n\nexport const useDeviceLinking = (options: UseDeviceLinkingOptions): UseDeviceLinkingReturn => {\n  const { passkeyManager } = usePasskeyContext();\n  const {\n    onDeviceLinked,\n    onError,\n    onClose,\n    onEvent,\n    fundingAmount = '0.05'\n  } = options;\n\n  const hasClosedEarlyRef = useRef(false);\n\n  // Use refs for callbacks to avoid dependency changes\n  const callbacksRef = useRef({\n    onDeviceLinked,\n    onError,\n    onClose,\n    onEvent\n  });\n\n  // Update refs when callbacks change\n  callbacksRef.current = {\n    onDeviceLinked,\n    onError,\n    onClose,\n    onEvent\n  };\n\n  // Handle device linking with early close logic and polling\n  const linkDevice = useCallback(async (qrData: DeviceLinkingQRData, source: QRScanMode) => {\n\n    const {\n      onDeviceLinked,\n      onError,\n      onClose,\n      onEvent\n    } = callbacksRef.current;\n\n    try {\n      console.log(`useDeviceLinking: Starting device linking from ${source}...`);\n      hasClosedEarlyRef.current = false; // Reset for this linking attempt\n\n      const nearClient = passkeyManager.getNearClient();\n\n      const result = await passkeyManager.linkDeviceWithQRCode(qrData, {\n        fundingAmount,\n        onEvent: (event) => {\n          onEvent?.(event);\n          console.log(`useDeviceLinking: ${source} linking event -`, event.phase, event.message);\n          // Close scanner immediately after QR validation succeeds\n          switch (event.phase) {\n            case DeviceLinkingPhase.STEP_3_AUTHORIZATION:\n              if (event.status === DeviceLinkingStatus.PROGRESS) {\n                console.log('useDeviceLinking: QR validation complete - closing scanner while linking continues...');\n                hasClosedEarlyRef.current = true;\n                onClose?.();\n              }\n              break;\n          }\n        },\n        onError: (error: any) => {\n          console.error(`useDeviceLinking: ${source} linking error -`, error.message);\n          onError?.(error);\n        }\n      });\n\n      console.log(`useDeviceLinking: ${source} linking completed -`, { success: !!result });\n\n      // Start polling to check if Device2 has completed registration and removed the temporary key\n      const POLLING_INTERVAL_MS = 4000; // 4 seconds\n      const DELETE_KEY_TIMEOUT_MS = 20000; // 20 seconds\n\n      let pollingInterval: NodeJS.Timeout | null = null;\n      let deleteKeyTimeout: NodeJS.Timeout | null = null;\n      let pollingActive = true;\n\n      // Helper function to check if temporary key exists\n      const checkTemporaryKeyExists = async (): Promise<boolean> => {\n        try {\n          const accessKeyList = await nearClient.viewAccessKeyList(result.linkedToAccount || '');\n          return accessKeyList.keys.some(key => key.public_key === result.device2PublicKey);\n        } catch (error) {\n          console.error(`Failed to check access keys:`, error);\n          return false;\n        }\n      };\n\n      // Helper function to cleanup timers\n      const cleanupTimers = () => {\n        if (pollingInterval) {\n          clearInterval(pollingInterval);\n          pollingInterval = null;\n        }\n        if (deleteKeyTimeout) {\n          clearTimeout(deleteKeyTimeout);\n          deleteKeyTimeout = null;\n        }\n        pollingActive = false;\n      };\n\n      // Start polling\n      pollingInterval = setInterval(async () => {\n        if (!pollingActive) return;\n\n        const tempKeyExists = await checkTemporaryKeyExists();\n        if (!tempKeyExists) {\n          console.log(`Temporary key no longer exists, stopping polling and clearing timeout`);\n          cleanupTimers();\n        }\n      }, POLLING_INTERVAL_MS);\n\n      // Start timeout to broadcast DeleteKey transaction after timeout\n      deleteKeyTimeout = setTimeout(async () => {\n        try {\n          console.log(`Checking if temporary key still exists after timeout...`);\n          const tempKeyExists = await checkTemporaryKeyExists();\n          if (tempKeyExists) {\n            console.log(`Temporary key still exists, broadcasting DeleteKey transaction for key: ${result.device2PublicKey.substring(0, 20)}...`);\n            const deleteKeyTxResult = await nearClient.sendTransaction(result.signedDeleteKeyTransaction!);\n            console.log(`DeleteKey transaction broadcasted successfully. Transaction hash: ${deleteKeyTxResult?.transaction?.hash}`);\n          } else {\n            console.log(`Temporary key no longer exists, no need to broadcast DeleteKey transaction`);\n          }\n        } catch (error) {\n          console.error(`Failed to check access keys or broadcast DeleteKey transaction:`, error);\n        }\n        cleanupTimers();\n      }, DELETE_KEY_TIMEOUT_MS);\n\n      // Cleanup timers on successful completion\n      cleanupTimers();\n\n      onDeviceLinked?.(result);\n\n    } catch (linkingError: any) {\n      console.error(`useDeviceLinking: ${source} linking failed -`, linkingError.message);\n      onError?.(linkingError);\n\n      // Close scanner on error if it hasn't been closed early\n      if (!hasClosedEarlyRef.current) {\n        console.log('useDeviceLinking: Closing scanner due to linking error...');\n        onClose?.();\n      }\n    }\n  }, [fundingAmount, passkeyManager]);\n\n  return {\n    linkDevice,\n  };\n};"],"mappings":";;;;;;;AAgDA,MAAa,oBAAoB,YAA6D;CAC5F,MAAM,EAAE,mBAAmBA;CAC3B,MAAM,EACJ,gBACA,SACA,SACA,SACA,gBAAgB,WACd;CAEJ,MAAM,sCAA2B;CAGjC,MAAM,iCAAsB;EAC1B;EACA;EACA;EACA;;AAIF,cAAa,UAAU;EACrB;EACA;EACA;EACA;;CAIF,MAAM,oCAAyB,OAAO,QAA6B,WAAuB;EAExF,MAAM,EACJ,kCACA,oBACA,oBACA,uBACE,aAAa;AAEjB,MAAI;AACF,WAAQ,IAAI,kDAAkD,OAAO;AACrE,qBAAkB,UAAU;GAE5B,MAAM,aAAa,eAAe;GAElC,MAAM,SAAS,MAAM,eAAe,qBAAqB,QAAQ;IAC/D;IACA,UAAU,UAAU;AAClB,iBAAU;AACV,aAAQ,IAAI,qBAAqB,OAAO,mBAAmB,MAAM,OAAO,MAAM;AAE9E,aAAQ,MAAM,OAAd;MACE,KAAKC,0CAAmB;AACtB,WAAI,MAAM,WAAWC,2CAAoB,UAAU;AACjD,gBAAQ,IAAI;AACZ,0BAAkB,UAAU;AAC5B;;AAEF;;;IAGN,UAAU,UAAe;AACvB,aAAQ,MAAM,qBAAqB,OAAO,mBAAmB,MAAM;AACnE,iBAAU;;;AAId,WAAQ,IAAI,qBAAqB,OAAO,uBAAuB,EAAE,SAAS,CAAC,CAAC;GAG5E,MAAM,sBAAsB;GAC5B,MAAM,wBAAwB;GAE9B,IAAIC,kBAAyC;GAC7C,IAAIC,mBAA0C;GAC9C,IAAI,gBAAgB;GAGpB,MAAM,0BAA0B,YAA8B;AAC5D,QAAI;KACF,MAAM,gBAAgB,MAAM,WAAW,kBAAkB,OAAO,mBAAmB;AACnF,YAAO,cAAc,KAAK,MAAK,QAAO,IAAI,eAAe,OAAO;aACzD,OAAO;AACd,aAAQ,MAAM,gCAAgC;AAC9C,YAAO;;;GAKX,MAAM,sBAAsB;AAC1B,QAAI,iBAAiB;AACnB,mBAAc;AACd,uBAAkB;;AAEpB,QAAI,kBAAkB;AACpB,kBAAa;AACb,wBAAmB;;AAErB,oBAAgB;;AAIlB,qBAAkB,YAAY,YAAY;AACxC,QAAI,CAAC,cAAe;IAEpB,MAAM,gBAAgB,MAAM;AAC5B,QAAI,CAAC,eAAe;AAClB,aAAQ,IAAI;AACZ;;MAED;AAGH,sBAAmB,WAAW,YAAY;AACxC,QAAI;AACF,aAAQ,IAAI;KACZ,MAAM,gBAAgB,MAAM;AAC5B,SAAI,eAAe;AACjB,cAAQ,IAAI,2EAA2E,OAAO,iBAAiB,UAAU,GAAG,IAAI;MAChI,MAAM,oBAAoB,MAAM,WAAW,gBAAgB,OAAO;AAClE,cAAQ,IAAI,qEAAqE,mBAAmB,aAAa;WAEjH,SAAQ,IAAI;aAEP,OAAO;AACd,aAAQ,MAAM,mEAAmE;;AAEnF;MACC;AAGH;AAEA,sBAAiB;WAEVC,cAAmB;AAC1B,WAAQ,MAAM,qBAAqB,OAAO,oBAAoB,aAAa;AAC3E,eAAU;AAGV,OAAI,CAAC,kBAAkB,SAAS;AAC9B,YAAQ,IAAI;AACZ;;;IAGH,CAAC,eAAe;AAEnB,QAAO,EACL"}