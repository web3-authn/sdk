{"version":3,"file":"useQRCamera.js","names":["ScanQRCodeFlow","getOptimalCameraFacingMode","enumerateVideoDevices","detectFrontCamera","error: any","error"],"sources":["../../../../src/react/hooks/useQRCamera.ts"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\nimport { getOptimalCameraFacingMode } from '../deviceDetection';\nimport type { DeviceLinkingQRData } from '@/index';\nimport { ScanQRCodeFlow, enumerateVideoDevices, detectFrontCamera } from '../../utils/qrScanner';\n\n/**\n * QR Camera Scanning Hook\n *\n * Provides camera-based QR code scanning functionality for device linking.\n *\n * **Important:** This hook must be used inside a PasskeyManager context.\n * Wrap your app with PasskeyProvider or ensure PasskeyManager is available in context.\n *\n * @example\n * ```tsx\n * import { PasskeyProvider } from '@web3authn/passkey/react';\n * import { useQRCamera } from '@web3authn/passkey/react';\n *\n * function QRScanner() {\n *   const qrCamera = useQRCamera({\n *     onQRDetected: (qrData) => console.log('QR detected:', qrData),\n *     onError: (error) => console.error('Error:', error)\n *   });\n *\n *   return <video ref={qrCamera.videoRef} />;\n * }\n * ```\n */\nexport enum QRScanMode {\n  CAMERA = 'camera',\n  FILE = 'file',\n  AUTO = 'auto'\n}\n\nexport interface UseQRCameraOptions {\n  onQRDetected?: (qrData: DeviceLinkingQRData) => void;\n  onError?: (error: Error) => void;\n  isOpen?: boolean;\n  cameraId?: string;\n}\n\nexport interface UseQRCameraReturn {\n  // State\n  isScanning: boolean;\n  isProcessing: boolean;\n  error: string | null;\n  cameras: MediaDeviceInfo[];\n  selectedCamera: string;\n  scanMode: QRScanMode;\n  isFrontCamera: boolean;\n  scanDurationMs: number;\n\n  // Refs for UI\n  videoRef: React.RefObject<HTMLVideoElement | null>;\n  canvasRef: React.RefObject<HTMLCanvasElement | null>;\n\n  // Controls\n  startScanning: () => Promise<void>;\n  stopScanning: () => void;\n  handleCameraChange: (deviceId: string) => void;\n  setScanMode: (mode: QRScanMode) => void;\n  setError: (error: string | null) => void;\n\n  // Utilities\n  getOptimalFacingMode: () => 'user' | 'environment';\n}\n\nexport const useQRCamera = (options: UseQRCameraOptions): UseQRCameraReturn => {\n  const {\n    onQRDetected,\n    onError,\n    isOpen = true,\n    cameraId\n  } = options;\n\n  // Refs\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const flowRef = useRef<ScanQRCodeFlow | null>(null);\n\n  // State\n  const [isScanning, setIsScanning] = useState(false);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [cameras, setCameras] = useState<MediaDeviceInfo[]>([]);\n  const [selectedCamera, setSelectedCamera] = useState<string>(cameraId || '');\n  const [scanMode, setScanMode] = useState<QRScanMode>(QRScanMode.CAMERA);\n  const [isFrontCamera, setIsFrontCamera] = useState<boolean>(false);\n  const [scanDurationMs, setScanDurationMs] = useState<number>(0);\n\n  // Create ScanQRCodeFlow instance\n  // This is the core scanning engine that handles camera access and QR detection\n  useEffect(() => {\n    flowRef.current = new ScanQRCodeFlow(\n      {\n        cameraId: selectedCamera,\n        cameraConfigs: {\n          facingMode: getOptimalCameraFacingMode()\n        },\n        timeout: 60000 // 60 seconds\n      },\n      {\n        onQRDetected: (qrData) => {\n          console.log('useQRCamera: Valid QR data detected -', {\n            devicePublicKey: qrData.device2PublicKey,\n            accountId: qrData.accountId,\n            timestamp: new Date(qrData.timestamp || 0).toISOString()\n          });\n          setIsProcessing(false);\n          setIsScanning(false);\n          setScanDurationMs(0);\n          onQRDetected?.(qrData);\n        },\n        onError: (err) => {\n          console.error('useQRCamera: QR scan error -', err);\n          setError(err.message);\n          setIsProcessing(false);\n          setIsScanning(false);\n          setScanDurationMs(0);\n          onError?.(err);\n        },\n        onCameraReady: (stream) => {\n          // Camera stream is ready, but video element attachment is handled separately\n          console.log('useQRCamera: Camera stream ready');\n        },\n        onScanProgress: (duration) => {\n          setScanDurationMs(duration);\n        }\n      }\n    );\n\n    return () => {\n      if (flowRef.current) {\n        // Hook Cleanup Point 1: Stop scanning and cleanup\n        flowRef.current.stop();\n        flowRef.current = null;\n      }\n    };\n  }, []); // Only initialize once\n\n  // Load cameras on mount\n  useEffect(() => {\n    const loadCameras = async () => {\n      try {\n        const videoDevices = await enumerateVideoDevices();\n        setCameras(videoDevices);\n\n        if (videoDevices.length > 0 && !selectedCamera) {\n          const firstCamera = videoDevices[0];\n          setSelectedCamera(firstCamera.deviceId);\n          setIsFrontCamera(detectFrontCamera(firstCamera));\n        }\n      } catch (error: any) {\n        setError(error.message);\n      }\n    };\n\n    loadCameras();\n  }, []);\n\n  // Update flow camera when selectedCamera changes\n  useEffect(() => {\n    if (flowRef.current && selectedCamera) {\n      flowRef.current.switchCamera(selectedCamera);\n    }\n  }, [selectedCamera]);\n\n  // Attach/detach video element when ref changes\n  useEffect(() => {\n    if (videoRef.current && flowRef.current) {\n      flowRef.current.attachVideoElement(videoRef.current);\n    }\n\n    return () => {\n      if (flowRef.current) {\n        flowRef.current.detachVideoElement();\n      }\n    };\n  }, [videoRef.current]);\n\n  // Hook Cleanup Point 2: (when modal closes or scan mode changes from camera to file)\n  useEffect(() => {\n    const flow = flowRef.current;\n    if (!flow) return;\n\n    if (isOpen && scanMode === QRScanMode.CAMERA) {\n      setError(null);\n      setIsProcessing(true);\n      setIsScanning(true);\n      setScanDurationMs(0);\n      flow.startQRScanner();\n    } else {\n      flow.stop();\n      setIsScanning(false);\n      setIsProcessing(false);\n      setScanDurationMs(0);\n    }\n  }, [isOpen, scanMode]);\n\n  // Manual controls\n  const startScanning = useCallback(async () => {\n    if (flowRef.current) {\n      setError(null);\n      setIsProcessing(true);\n      setIsScanning(true);\n      setScanDurationMs(0);\n      await flowRef.current.startQRScanner();\n    }\n  }, []);\n\n  // Hook Cleanup Point 3: called when user explicitly stops scanning\n  const stopScanning = useCallback(() => {\n    if (flowRef.current) {\n      flowRef.current.stop();\n      setIsScanning(false);\n      setIsProcessing(false);\n      setScanDurationMs(0);\n    }\n  }, []);\n\n  // Handle camera change\n  const handleCameraChange = useCallback(async (deviceId: string) => {\n    setSelectedCamera(deviceId);\n\n    const selectedCameraDevice = cameras.find(camera => camera.deviceId === deviceId);\n    if (selectedCameraDevice) {\n      setIsFrontCamera(detectFrontCamera(selectedCameraDevice));\n    }\n\n    // The useEffect will handle updating the flow\n  }, [cameras]);\n\n  const getOptimalFacingMode = useCallback(() => getOptimalCameraFacingMode(), []);\n\n  return {\n    // State\n    isScanning,\n    isProcessing,\n    error,\n    cameras,\n    selectedCamera,\n    scanMode,\n    isFrontCamera,\n    scanDurationMs,\n\n    // Refs for UI\n    videoRef,\n    canvasRef,\n\n    // Controls\n    startScanning,\n    stopScanning,\n    handleCameraChange,\n    setScanMode,\n    setError,\n\n    // Utilities\n    getOptimalFacingMode\n  };\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,IAAY,oDAAL;AACL;AACA;AACA;;;AAoCF,MAAa,eAAe,YAAmD;CAC7E,MAAM,EACJ,cACA,SACA,SAAS,MACT,aACE;CAGJ,MAAM,6BAAoC;CAC1C,MAAM,8BAAsC;CAC5C,MAAM,4BAAwC;CAG9C,MAAM,CAAC,YAAY,qCAA0B;CAC7C,MAAM,CAAC,cAAc,uCAA4B;CACjD,MAAM,CAAC,OAAO,gCAAoC;CAClD,MAAM,CAAC,SAAS,kCAA0C;CAC1D,MAAM,CAAC,gBAAgB,yCAAsC,YAAY;CACzE,MAAM,CAAC,UAAU,mCAAoC,WAAW;CAChE,MAAM,CAAC,eAAe,wCAAsC;CAC5D,MAAM,CAAC,gBAAgB,yCAAsC;AAI7D,4BAAgB;AACd,UAAQ,UAAU,IAAIA,iCACpB;GACE,UAAU;GACV,eAAe,EACb,YAAYC;GAEd,SAAS;KAEX;GACE,eAAe,WAAW;AACxB,YAAQ,IAAI,yCAAyC;KACnD,iBAAiB,OAAO;KACxB,WAAW,OAAO;KAClB,WAAW,IAAI,KAAK,OAAO,aAAa,GAAG;;AAE7C,oBAAgB;AAChB,kBAAc;AACd,sBAAkB;AAClB,mBAAe;;GAEjB,UAAU,QAAQ;AAChB,YAAQ,MAAM,gCAAgC;AAC9C,aAAS,IAAI;AACb,oBAAgB;AAChB,kBAAc;AACd,sBAAkB;AAClB,cAAU;;GAEZ,gBAAgB,WAAW;AAEzB,YAAQ,IAAI;;GAEd,iBAAiB,aAAa;AAC5B,sBAAkB;;;AAKxB,eAAa;AACX,OAAI,QAAQ,SAAS;AAEnB,YAAQ,QAAQ;AAChB,YAAQ,UAAU;;;IAGrB;AAGH,4BAAgB;EACd,MAAM,cAAc,YAAY;AAC9B,OAAI;IACF,MAAM,eAAe,MAAMC;AAC3B,eAAW;AAEX,QAAI,aAAa,SAAS,KAAK,CAAC,gBAAgB;KAC9C,MAAM,cAAc,aAAa;AACjC,uBAAkB,YAAY;AAC9B,sBAAiBC,oCAAkB;;YAE9BC,SAAY;AACnB,aAASC,QAAM;;;AAInB;IACC;AAGH,4BAAgB;AACd,MAAI,QAAQ,WAAW,eACrB,SAAQ,QAAQ,aAAa;IAE9B,CAAC;AAGJ,4BAAgB;AACd,MAAI,SAAS,WAAW,QAAQ,QAC9B,SAAQ,QAAQ,mBAAmB,SAAS;AAG9C,eAAa;AACX,OAAI,QAAQ,QACV,SAAQ,QAAQ;;IAGnB,CAAC,SAAS;AAGb,4BAAgB;EACd,MAAM,OAAO,QAAQ;AACrB,MAAI,CAAC,KAAM;AAEX,MAAI,UAAU,aAAa,WAAW,QAAQ;AAC5C,YAAS;AACT,mBAAgB;AAChB,iBAAc;AACd,qBAAkB;AAClB,QAAK;SACA;AACL,QAAK;AACL,iBAAc;AACd,mBAAgB;AAChB,qBAAkB;;IAEnB,CAAC,QAAQ;CAGZ,MAAM,uCAA4B,YAAY;AAC5C,MAAI,QAAQ,SAAS;AACnB,YAAS;AACT,mBAAgB;AAChB,iBAAc;AACd,qBAAkB;AAClB,SAAM,QAAQ,QAAQ;;IAEvB;CAGH,MAAM,4CAAiC;AACrC,MAAI,QAAQ,SAAS;AACnB,WAAQ,QAAQ;AAChB,iBAAc;AACd,mBAAgB;AAChB,qBAAkB;;IAEnB;CAGH,MAAM,4CAAiC,OAAO,aAAqB;AACjE,oBAAkB;EAElB,MAAM,uBAAuB,QAAQ,MAAK,WAAU,OAAO,aAAa;AACxE,MAAI,qBACF,kBAAiBF,oCAAkB;IAIpC,CAAC;CAEJ,MAAM,oDAAyCF,sDAA8B;AAE7E,QAAO;EAEL;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAGA;EACA;EAGA;EACA;EACA;EACA;EACA;EAGA"}