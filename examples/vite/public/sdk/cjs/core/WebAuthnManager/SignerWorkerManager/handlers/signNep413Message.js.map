{"version":3,"file":"signNep413Message.js","names":["extractPrfFromCredential","WorkerRequestType","isSignNep413MessageSuccess","error: any"],"sources":["../../../../../../src/core/WebAuthnManager/SignerWorkerManager/handlers/signNep413Message.ts"],"sourcesContent":["\nimport { WorkerRequestType, isSignNep413MessageSuccess } from '../../../types/signer-worker';\nimport { extractPrfFromCredential } from '../../credentialsHelpers';\nimport { SignerWorkerManagerContext } from '..';\n\n\n/**\n * Sign a NEP-413 message using the user's passkey-derived private key\n *\n * @param payload - NEP-413 signing parameters including message, recipient, nonce, and state\n * @returns Promise resolving to signing result with account ID, public key, and signature\n */\nexport async function signNep413Message({ ctx, payload }: {\n  ctx: SignerWorkerManagerContext;\n  payload: {\n    message: string;\n    recipient: string;\n    nonce: string;\n    state: string | null;\n    accountId: string;\n    credential: PublicKeyCredential;\n  };\n}): Promise<{\n  success: boolean;\n  accountId: string;\n  publicKey: string;\n  signature: string;\n  state?: string;\n  error?: string;\n}> {\n  try {\n    const encryptedKeyData = await ctx.indexedDB.nearKeysDB.getEncryptedKey(payload.accountId);\n\n    if (!encryptedKeyData) {\n      throw new Error(`No encrypted key found for account: ${payload.accountId}`);\n    }\n\n    const { chacha20PrfOutput } = extractPrfFromCredential({\n      credential: payload.credential,\n      firstPrfOutput: true,\n      secondPrfOutput: false,\n    });\n\n    const response = await ctx.sendMessage<WorkerRequestType.SignNep413Message>({\n      message: {\n        type: WorkerRequestType.SignNep413Message,\n        payload: {\n          message: payload.message,\n          recipient: payload.recipient,\n          nonce: payload.nonce,\n          state: payload.state || undefined,\n          accountId: payload.accountId,\n          prfOutput: chacha20PrfOutput, // Use ChaCha20 PRF output for decryption\n          encryptedPrivateKeyData: encryptedKeyData.encryptedData,\n          encryptedPrivateKeyIv: encryptedKeyData.iv\n        }\n      }\n    });\n\n    if (!isSignNep413MessageSuccess(response)) {\n      console.error('SignerWorkerManager: NEP-413 signing failed:', response);\n      throw new Error('NEP-413 signing failed');\n    }\n\n    return {\n      success: true,\n      accountId: response.payload.accountId,\n      publicKey: response.payload.publicKey,\n      signature: response.payload.signature,\n      state: response.payload.state || undefined\n    };\n\n  } catch (error: any) {\n    console.error('SignerWorkerManager: NEP-413 signing error:', error);\n    return {\n      success: false,\n      accountId: '',\n      publicKey: '',\n      signature: '',\n      error: error.message || 'Unknown error'\n    };\n  }\n}\n"],"mappings":";;;;;;;;;;;AAYA,eAAsB,kBAAkB,EAAE,KAAK,WAiB5C;AACD,KAAI;EACF,MAAM,mBAAmB,MAAM,IAAI,UAAU,WAAW,gBAAgB,QAAQ;AAEhF,MAAI,CAAC,iBACH,OAAM,IAAI,MAAM,uCAAuC,QAAQ;EAGjE,MAAM,EAAE,sBAAsBA,oDAAyB;GACrD,YAAY,QAAQ;GACpB,gBAAgB;GAChB,iBAAiB;;EAGnB,MAAM,WAAW,MAAM,IAAI,YAAiD,EAC1E,SAAS;GACP,MAAMC,6CAAkB;GACxB,SAAS;IACP,SAAS,QAAQ;IACjB,WAAW,QAAQ;IACnB,OAAO,QAAQ;IACf,OAAO,QAAQ,SAAS;IACxB,WAAW,QAAQ;IACnB,WAAW;IACX,yBAAyB,iBAAiB;IAC1C,uBAAuB,iBAAiB;;;AAK9C,MAAI,CAACC,iDAA2B,WAAW;AACzC,WAAQ,MAAM,gDAAgD;AAC9D,SAAM,IAAI,MAAM;;AAGlB,SAAO;GACL,SAAS;GACT,WAAW,SAAS,QAAQ;GAC5B,WAAW,SAAS,QAAQ;GAC5B,WAAW,SAAS,QAAQ;GAC5B,OAAO,SAAS,QAAQ,SAAS;;UAG5BC,OAAY;AACnB,UAAQ,MAAM,+CAA+C;AAC7D,SAAO;GACL,SAAS;GACT,WAAW;GACX,WAAW;GACX,WAAW;GACX,OAAO,MAAM,WAAW"}