{"version":3,"file":"handleSecureConfirmRequest.js","names":["decision: SecureConfirmDecision","decisionWithCredentials: SecureConfirmDecision","reservedNonces: string[] | undefined","transactionSummary: TransactionSummary","IFRAME_BUTTON_ID","uiDigest: string | null","mountIframeModalHostWithHandle","awaitIframeModalDecisionWithHandle","toAccountId","extractPrfFromCredential","serializeRegistrationCredentialWithPRF","serializeAuthenticationCredentialWithPRF","SecureConfirmMessageType","out: any"],"sources":["../../../../../../src/core/WebAuthnManager/SignerWorkerManager/confirmTxFlow/handleSecureConfirmRequest.ts"],"sourcesContent":["import {\n  extractPrfFromCredential,\n  serializeRegistrationCredentialWithPRF,\n  serializeAuthenticationCredentialWithPRF,\n} from '../../credentialsHelpers';\nimport type { SignerWorkerManagerContext } from '../index';\nimport type { ConfirmationConfig } from '../../../types/signer-worker';\nimport {\n  SecureConfirmMessage,\n  SecureConfirmDecision,\n  TransactionSummary,\n  SecureConfirmMessageType,\n  SecureConfirmData,\n} from './types';\nimport { TransactionContext } from '../../../types';\nimport { toAccountId } from '../../../types/accountIds';\nimport { fetchNonceBlockHashAndHeight } from '../../../rpcCalls';\nimport type { NonceManager } from '../../../nonceManager';\nimport { awaitIframeModalDecisionWithHandle, mountIframeModalHostWithHandle } from '../../LitComponents/modal';\nimport { IFRAME_BUTTON_ID } from '../../LitComponents/IframeButtonWithTooltipConfirmer/tags';\n\n/**\n * Handles secure confirmation requests from the worker with robust error handling\n * => SecureConfirmMessageType.PROMPT_USER_CONFIRM_IN_JS_MAIN_THREAD\n * and proper data validation. Supports both transaction and registration confirmation flows.\n */\nexport async function handlePromptUserConfirmInJsMainThread(\n  ctx: SignerWorkerManagerContext,\n  message: {\n    type: SecureConfirmMessageType.PROMPT_USER_CONFIRM_IN_JS_MAIN_THREAD,\n    data: SecureConfirmData,\n  },\n  worker: Worker\n): Promise<void> {\n\n  // 1. Validate and parse request\n  const {\n    data,\n    summary,\n    confirmationConfig,\n    transactionSummary\n  } = validateAndParseRequest({ ctx, message });\n\n  // 2. Perform NEAR RPC calls first (needed for VRF challenge)\n  const nearRpcResult = await performNearRpcCalls(ctx, data);\n\n  // 3. If NEAR RPC failed, return error\n  if (nearRpcResult.error || !nearRpcResult.transactionContext) {\n    sendWorkerResponse(worker, {\n      requestId: data.requestId,\n      intentDigest: data.intentDigest,\n      confirmed: false,\n      error: `Failed to fetch NEAR data: ${nearRpcResult.details}`\n    });\n    return;\n  }\n\n  const transactionContext = nearRpcResult.transactionContext;\n\n  // 4. Generate VRF challenge with NEAR data\n  if (!ctx.vrfWorkerManager) {\n    throw new Error('VrfWorkerManager not available in context');\n  }\n  const vrfChallenge = await ctx.vrfWorkerManager.generateVrfChallenge({\n    userId: data.rpcCall.nearAccountId,\n    rpId: window.location.hostname,\n    blockHeight: transactionContext.txBlockHeight,\n    blockHash: transactionContext.txBlockHash,\n  });\n\n  // 5. Render user confirmation UI with VRF challenge\n  const userConfirmResult = await renderUserConfirmUI({ ctx, confirmationConfig, transactionSummary, data, vrfChallenge });\n  const { confirmed, confirmHandle, error: uiError } = userConfirmResult;\n\n  // 6. If user rejected (confirmed === false), exit early\n  if (!confirmed) {\n    // Release any reserved nonces for this modal request\n    try {\n      nearRpcResult.reservedNonces?.forEach(n => ctx.nonceManager.releaseNonce(n));\n    } catch (e) {\n      console.warn('[SignerWorkerManager]: Failed to release reserved nonces on cancel:', e);\n    }\n    closeModalSafely(confirmHandle, false);\n    sendWorkerResponse(worker, {\n      requestId: data.requestId,\n      intentDigest: data.intentDigest,\n      confirmed: false,\n      error: uiError\n    });\n    return;\n  }\n\n  // 7. Create decision with generated data\n  const decision: SecureConfirmDecision = {\n    requestId: data.requestId,\n    intentDigest: data.intentDigest,\n    confirmed: true,\n    vrfChallenge, // Generated here\n    transactionContext: transactionContext, // Generated here\n  };\n\n  // 8. Collect credentials using generated VRF challenge\n  let decisionWithCredentials: SecureConfirmDecision;\n  let touchIdSuccess = false;\n\n  try {\n    const result = await collectTouchIdCredentials({\n      ctx,\n      data,\n      decision,\n    });\n    decisionWithCredentials = result.decisionWithCredentials;\n    touchIdSuccess = decisionWithCredentials?.confirmed ?? false;\n  } catch (touchIdError) {\n    console.error('[SignerWorkerManager]: Failed to collect credentials:', touchIdError);\n    const isCancelled = touchIdError instanceof DOMException &&\n      (touchIdError.name === 'NotAllowedError' || touchIdError.name === 'AbortError');\n\n    if (isCancelled) {\n      console.log('[SignerWorkerManager]: User cancelled secure confirm request');\n    }\n\n    decisionWithCredentials = {\n      ...decision,\n      confirmed: false,\n      error: isCancelled ? 'User cancelled secure confirm request' : 'Failed to collect credentials',\n      _confirmHandle: undefined,\n    };\n    touchIdSuccess = false;\n  } finally {\n    // Always close the modal after TouchID attempt (success or failure)\n    closeModalSafely(confirmHandle, touchIdSuccess);\n  }\n\n  // 9. Send confirmation response back to wasm-signer-worker\n  // Release any reserved nonces if final decision is not confirmed\n  try {\n    if (!decisionWithCredentials?.confirmed) {\n      nearRpcResult.reservedNonces?.forEach(n => ctx.nonceManager.releaseNonce(n));\n    }\n  } catch (e) {\n    console.warn('[SignerWorkerManager]: Failed to release reserved nonces after decision:', e);\n  }\n  sendWorkerResponse(worker, decisionWithCredentials);\n}\n\n/**\n * Performs NEAR RPC call to get nonce, block hash and height\n * Uses NonceManager if available, otherwise falls back to direct RPC calls\n * For batch transactions, reserves nonces for each transaction\n */\nasync function performNearRpcCalls(\n  ctx: SignerWorkerManagerContext,\n  data: SecureConfirmData\n): Promise<{\n  transactionContext: TransactionContext | null;\n  error?: string;\n  details?: string;\n  reservedNonces?: string[];\n}> {\n  try {\n    // Use NonceManager's smart caching method\n    const transactionContext = await ctx.nonceManager.getNonceBlockHashAndHeight(ctx.nearClient);\n    console.log(\"Using NonceManager smart caching\");\n\n    // Reserve nonces for this request to avoid parallel collisions\n    const txCount = data.tx_signing_requests?.length || 1;\n    let reservedNonces: string[] | undefined;\n    try {\n      reservedNonces = ctx.nonceManager.reserveNonces(txCount);\n      console.log(`[NonceManager]: Reserved ${txCount} nonce(s):`, reservedNonces);\n      // Provide the first reserved nonce to the worker context; worker handles per-tx assignment\n      transactionContext.nextNonce = reservedNonces[0];\n    } catch (error) {\n      console.warn(`[NonceManager]: Failed to reserve ${txCount} nonce(s):`, error);\n      // Continue with existing nextNonce; worker may auto-increment where appropriate\n    }\n\n    return {\n      transactionContext,\n      error: undefined,\n      details: undefined,\n      reservedNonces\n    };\n  } catch (error) {\n    return {\n      transactionContext: null,\n      error: 'NEAR_RPC_FAILED',\n      details: error instanceof Error ? error.message : String(error)\n    };\n  }\n}\n\n//////////////////////////////////\n// === CONFIRMATION LOGIC ===\n//////////////////////////////////\n\n/**\n * Validates and parses the confirmation request data\n */\nfunction validateAndParseRequest({ ctx, message }: {\n  ctx: SignerWorkerManagerContext,\n  message: SecureConfirmMessage,\n}): {\n  data: SecureConfirmData;\n  summary: TransactionSummary;\n  confirmationConfig: ConfirmationConfig;\n  transactionSummary: TransactionSummary;\n} {\n  // Validate required fields\n  const data = message.data;\n  if (!data || !data.requestId) {\n    throw new Error('Invalid secure confirm request - missing requestId');\n  }\n\n  // Parse and validate summary data (can contain extra fields we need)\n  const summary = parseTransactionSummary(data.summary);\n  // Get confirmation configuration from data (overrides user settings) or use user's settings\n  const confirmationConfig = data.confirmationConfig || ctx.userPreferencesManager.getConfirmationConfig();\n  const transactionSummary: TransactionSummary = {\n    totalAmount: summary?.totalAmount,\n    method: summary?.method || (data.isRegistration ? 'Register Account' : undefined),\n    intentDigest: data.intentDigest\n  };\n\n  return {\n    data,\n    summary,\n    confirmationConfig,\n    transactionSummary\n  };\n}\n\n/**\n * Determines user confirmation based on UI mode and configuration\n */\nasync function renderUserConfirmUI({\n  ctx,\n  data,\n  confirmationConfig,\n  transactionSummary,\n  vrfChallenge,\n}: {\n  ctx: SignerWorkerManagerContext,\n  data: SecureConfirmData,\n  confirmationConfig: ConfirmationConfig,\n  transactionSummary: TransactionSummary,\n  vrfChallenge?: any;\n}): Promise<{\n  confirmed: boolean;\n  confirmHandle?: { element: any, close: (confirmed: boolean) => void };\n  error?: string;\n}> {\n\n  switch (confirmationConfig.uiMode) {\n    case 'skip': {\n      // Bypass UI entirely - automatically confirm\n      return { confirmed: true, confirmHandle: undefined };\n    }\n\n    case 'embedded': {\n      // For embedded mode, validate that the UI displayed transactions match\n      // the worker-provided transactions by comparing canonical digests.\n      try {\n        const hostEl = document.querySelector(IFRAME_BUTTON_ID) as any;\n\n        // Apply theme to existing embedded component if theme is specified\n        if (hostEl && confirmationConfig.theme) {\n          hostEl.tooltipTheme = confirmationConfig.theme;\n        }\n\n        let uiDigest: string | null = null;\n        if (hostEl?.requestUiIntentDigest) {\n          uiDigest = await hostEl.requestUiIntentDigest();\n          console.log('[SecureConfirm] digest check', { uiDigest, intentDigest: data.intentDigest });\n        } else {\n          console.error('[SecureConfirm]: missing requestUiIntentDigest on secure element');\n        }\n        // Debug: show UI digest and WASM worker's provided intentDigest for comparison\n        if (uiDigest !== data.intentDigest) {\n          console.error('[SecureConfirm]: UI digest mismatch');\n          const errPayload = JSON.stringify({ code: 'ui_digest_mismatch', uiDigest, intentDigest: data.intentDigest });\n          return { confirmed: false, confirmHandle: undefined, error: errPayload };\n        }\n        return { confirmed: true, confirmHandle: undefined };\n      } catch (e) {\n        console.error('[SecureConfirm]: Failed to validate UI digest', e);\n        return { confirmed: false, confirmHandle: undefined, error: 'ui_digest_validation_failed' };\n      }\n    }\n\n    case 'modal': {\n      if (confirmationConfig.behavior === 'autoProceed') {\n        // Mount modal immediately in loading state\n        const handle = await mountIframeModalHostWithHandle({\n          ctx,\n          summary: transactionSummary,\n          txSigningRequests: data.tx_signing_requests,\n          vrfChallenge: vrfChallenge,\n          loading: true,\n          theme: confirmationConfig.theme\n        });\n        // Wait for the specified delay before proceeding\n        const delay = confirmationConfig.autoProceedDelay ?? 1000; // Default 1 seconds if not specified\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return { confirmed: true, confirmHandle: handle };\n\n      } else {\n        // Require click\n        const { confirmed, handle } = await awaitIframeModalDecisionWithHandle({\n          ctx,\n          summary: transactionSummary,\n          txSigningRequests: data.tx_signing_requests,\n          vrfChallenge: vrfChallenge,\n          theme: confirmationConfig.theme\n        });\n        return { confirmed, confirmHandle: handle };\n      }\n    }\n\n    default: {\n      // Fallback to modal with explicit confirm for unknown UI modes\n      const handle = await mountIframeModalHostWithHandle({\n        ctx,\n        summary: transactionSummary,\n        txSigningRequests: data.tx_signing_requests,\n        vrfChallenge: vrfChallenge,\n        loading: true,\n        theme: confirmationConfig.theme\n      });\n      return { confirmed: true, confirmHandle: handle };\n    }\n  }\n}\n\n/**\n * Collects WebAuthn credentials and PRF output if conditions are met\n */\nasync function collectTouchIdCredentials({\n  ctx,\n  data,\n  decision,\n}: {\n  ctx: SignerWorkerManagerContext,\n  data: SecureConfirmData,\n  decision: SecureConfirmDecision,\n}): Promise<{ decisionWithCredentials: SecureConfirmDecision }> {\n  const nearAccountId = data.rpcCall?.nearAccountId || (data as any).nearAccountId;\n  const vrfChallenge = decision.vrfChallenge; // Now comes from confirmation flow\n\n  if (!nearAccountId) {\n    throw new Error('nearAccountId not available for credential collection');\n  }\n  if (!vrfChallenge) {\n    throw new Error('VRF challenge not available for credential collection');\n  }\n\n  const authenticators = await ctx.indexedDB.clientDB.getAuthenticatorsByUser(toAccountId(nearAccountId));\n\n  const credential = await ctx.touchIdPrompt.getCredentials({\n    nearAccountId: nearAccountId,\n    challenge: vrfChallenge,\n    authenticators: authenticators,\n  });\n\n  // Extract PRF output for decryption (registration needs both PRF outputs)\n  const dualPrfOutputs = extractPrfFromCredential({\n    credential,\n    firstPrfOutput: true,\n    secondPrfOutput: data.isRegistration, // Registration needs second PRF output\n  });\n\n  if (!dualPrfOutputs.chacha20PrfOutput) {\n    throw new Error('Failed to extract PRF output from credential');\n  }\n\n  // Serialize credential for WASM worker (use appropriate serializer based on flow type)\n  const serializedCredential = data.isRegistration\n    ? serializeRegistrationCredentialWithPRF({\n        credential,\n        firstPrfOutput: true,\n        secondPrfOutput: true\n      })\n    : serializeAuthenticationCredentialWithPRF({ credential });\n\n  return {\n    decisionWithCredentials: {\n      ...decision,\n      credential: serializedCredential,\n      prfOutput: dualPrfOutputs.chacha20PrfOutput,\n      confirmed: true,\n      _confirmHandle: undefined,\n    }\n  };\n}\n\n/**\n * Safely parses transaction summary data, handling both string and object formats\n */\nfunction parseTransactionSummary(summaryData: string | object | undefined): any {\n  if (!summaryData) {\n    return {};\n  }\n  if (typeof summaryData === 'string') {\n    try {\n      return JSON.parse(summaryData);\n    } catch (parseError) {\n      console.warn('[SignerWorkerManager]: Failed to parse summary string:', parseError);\n      return {};\n    }\n  }\n  if (typeof summaryData === 'object' && summaryData !== null) {\n    return summaryData;\n  }\n  console.warn('[SignerWorkerManager]: Unexpected summary data type:', typeof summaryData);\n  return {};\n}\n\n/**\n * Safely closes modal with error handling\n */\nfunction closeModalSafely(confirmHandle: any, confirmed: boolean): void {\n  if (confirmHandle?.close) {\n    try {\n      confirmHandle.close(confirmed);\n      console.log('[SecureConfirm] Modal closed safely');\n    } catch (modalError) {\n      console.warn('[SecureConfirm] Error closing modal:', modalError);\n    }\n  }\n}\n\n/**\n * Sends response to worker with consistent message format\n */\nfunction sendWorkerResponse(worker: Worker, responseData: any): void {\n  // Sanitize payload to ensure postMessage structured-clone safety\n  const sanitized = sanitizeForPostMessage(responseData);\n  worker.postMessage({\n    type: SecureConfirmMessageType.USER_PASSKEY_CONFIRM_RESPONSE,\n    data: sanitized\n  });\n}\n\nfunction sanitizeForPostMessage(data: any): any {\n  if (data == null) return data;\n  if (typeof data !== 'object') return data;\n  // Drop private handles and any functions (non-cloneable)\n  const out: any = Array.isArray(data) ? [] : {};\n  for (const key of Object.keys(data)) {\n    if (key === '_confirmHandle') continue;\n    const value = (data as any)[key];\n    if (typeof value === 'function') continue;\n    out[key] = value;\n  }\n  return out;\n}\n"],"mappings":"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"}