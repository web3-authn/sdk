{"version":3,"file":"index.js","names":["IndexedDBManager","TouchIdPrompt","SIGNER_WORKER_MANAGER_CONFIG","promises: Promise<void>[]","responses: WorkerResponseForRequest<T>[]","SecureConfirmMessageType","handlePromptUserConfirmInJsMainThread","isWorkerProgress","isWorkerError","isWorkerSuccess","deriveNearKeypairAndEncrypt","decryptPrivateKeyWithPrf","checkCanRegisterUser","signVerifyAndRegisterUser","signTransactionsWithActions","recoverKeypairFromPasskey","extractCosePublicKey","signTransactionWithKeyPair","signNep413Message"],"sources":["../../../../../src/core/WebAuthnManager/SignerWorkerManager/index.ts"],"sourcesContent":["\nimport { SignedTransaction, type NearClient } from '../../NearClient';\nimport { ClientAuthenticatorData, UnifiedIndexedDBManager } from '../../IndexedDBManager';\nimport { IndexedDBManager } from '../../IndexedDBManager';\nimport { TouchIdPrompt } from \"../touchIdPrompt\";\nimport { SIGNER_WORKER_MANAGER_CONFIG } from \"../../../config\";\nimport {\n  WorkerRequestType,\n  WorkerResponseForRequest,\n  isWorkerProgress,\n  isWorkerError,\n  isWorkerSuccess,\n  WorkerProgressResponse,\n  WorkerErrorResponse,\n  WorkerRequestTypeMap,\n} from '../../types/signer-worker';\nimport { VRFChallenge } from '../../types/vrf-worker';\nimport { VrfWorkerManager } from '../VrfWorkerManager';\nimport type { ActionArgsWasm, TransactionInputWasm } from '../../types/actions';\nimport type { onProgressEvents } from '../../types/passkeyManager';\nimport type { AuthenticatorOptions } from '../../types/authenticatorOptions';\nimport { AccountId } from \"../../types/accountIds\";\nimport { ConfirmationConfig } from '../../types/signer-worker';\n\nimport {\n  deriveNearKeypairAndEncrypt,\n  decryptPrivateKeyWithPrf,\n  checkCanRegisterUser,\n  signVerifyAndRegisterUser,\n  signTransactionsWithActions,\n  recoverKeypairFromPasskey,\n  extractCosePublicKey,\n  signTransactionWithKeyPair,\n  signNep413Message,\n} from './handlers';\n\nimport {\n  SecureConfirmMessageType,\n  SecureConfirmMessage,\n  SecureConfirmData,\n  handlePromptUserConfirmInJsMainThread,\n} from './confirmTxFlow';\nimport { RpcCallPayload } from '../../types/signer-worker';\nimport { UserPreferencesManager } from '../userPreferences';\nimport { NonceManager } from '../../nonceManager';\n\n\nexport interface SignerWorkerManagerContext {\n  touchIdPrompt: TouchIdPrompt;\n  nearClient: NearClient;\n  indexedDB: UnifiedIndexedDBManager;\n  vrfWorkerManager?: VrfWorkerManager;\n  userPreferencesManager: UserPreferencesManager;\n  nonceManager: NonceManager;\n  sendMessage: <T extends WorkerRequestType>(args: {\n    message: {\n      type: T;\n      payload: WorkerRequestTypeMap[T]['request']\n    };\n    onEvent?: (update: onProgressEvents) => void;\n    timeoutMs?: number;\n  }) => Promise<WorkerResponseForRequest<T>>;\n}\n\n/**\n * WebAuthnWorkers handles PRF, workers, and COSE operations\n *\n * Note: Challenge store removed as VRF provides cryptographic freshness\n * without needing centralized challenge management\n */\nexport class SignerWorkerManager {\n\n  private indexedDB: UnifiedIndexedDBManager;\n  private touchIdPrompt: TouchIdPrompt;\n  private vrfWorkerManager: VrfWorkerManager;\n  private nearClient: NearClient;\n  private userPreferencesManager: UserPreferencesManager;\n  private nonceManager: NonceManager;\n\n  constructor(\n    vrfWorkerManager: VrfWorkerManager,\n    nearClient: NearClient,\n    userPreferencesManager: UserPreferencesManager,\n    nonceManager: NonceManager\n  ) {\n    this.indexedDB = IndexedDBManager;\n    this.touchIdPrompt = new TouchIdPrompt();\n    this.vrfWorkerManager = vrfWorkerManager;\n    this.nearClient = nearClient;\n    this.userPreferencesManager = userPreferencesManager;\n    this.nonceManager = nonceManager;\n  }\n\n  private getContext(): SignerWorkerManagerContext {\n    return {\n      sendMessage: this.sendMessage.bind(this), // bind to access this.createSecureWorker\n      indexedDB: this.indexedDB,\n      touchIdPrompt: this.touchIdPrompt,\n      vrfWorkerManager: this.vrfWorkerManager,\n      nearClient: this.nearClient,\n      userPreferencesManager: this.userPreferencesManager,\n      nonceManager: this.nonceManager,\n    };\n  }\n\n  createSecureWorker(): Worker {\n    // Simple path resolution - build:all copies worker files to /workers/\n    const workerUrl = new URL(SIGNER_WORKER_MANAGER_CONFIG.WORKER.URL, window.location.origin);\n    console.debug('Creating secure worker from:', workerUrl.href);\n    try {\n      const worker = new Worker(workerUrl, {\n        type: SIGNER_WORKER_MANAGER_CONFIG.WORKER.TYPE,\n        name: SIGNER_WORKER_MANAGER_CONFIG.WORKER.NAME\n      });\n      worker.onerror = (event) => { console.error('Worker error:', event); };\n      // Add error handling\n      return worker;\n    } catch (error) {\n      console.error('Failed to create worker:', error);\n      throw new Error(`Failed to create secure worker: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Executes a worker operation by sending a message to the secure worker.\n   * Handles progress updates via onEvent callback, supports both single and multiple response patterns.\n   * Intercepts secure confirmation handshake messages for pluggable UI.\n   * Resolves with the final worker response or rejects on error/timeout.\n   *\n   * @template T - Worker request type.\n   * @param params.message - The message to send to the worker.\n   * @param params.onEvent - Optional callback for progress events.\n   * @param params.timeoutMs - Optional timeout in milliseconds.\n   * @returns Promise resolving to the worker response for the request.\n   */\n  private workerPool: Worker[] = [];\n  private readonly MAX_WORKER_POOL_SIZE = 3; // Increased for security model\n\n  private getWorkerFromPool(): Worker {\n    if (this.workerPool.length > 0) {\n      return this.workerPool.pop()!;\n    }\n    return this.createSecureWorker();\n  }\n\n  private terminateAndReplaceWorker(worker: Worker): void {\n    // Always terminate workers to clear memory\n    worker.terminate();\n    // Asynchronously create a replacement worker for the pool\n    this.createReplacementWorker();\n  }\n\n  private async createReplacementWorker(): Promise<void> {\n    try {\n      const worker = this.createSecureWorker();\n\n      // Simple health check\n      const healthPromise = new Promise<void>((resolve, reject) => {\n        const timeout = setTimeout(() => reject(new Error('Health check timeout')), 5000);\n\n        const onMessage = (event: MessageEvent) => {\n          if (event.data?.type === 'WORKER_READY' || event.data?.ready) {\n            worker.removeEventListener('message', onMessage);\n            clearTimeout(timeout);\n            resolve();\n          }\n        };\n\n        worker.addEventListener('message', onMessage);\n        worker.onerror = () => {\n          worker.removeEventListener('message', onMessage);\n          clearTimeout(timeout);\n          reject(new Error('Worker error during health check'));\n        };\n      });\n\n      await healthPromise;\n\n      if (this.workerPool.length < this.MAX_WORKER_POOL_SIZE) {\n        this.workerPool.push(worker);\n      } else {\n        worker.terminate();\n      }\n    } catch (error) {\n      console.warn('SignerWorkerManager: Failed to create replacement worker:', error);\n    }\n  }\n\n  /**\n   * Pre-warm worker pool by creating and initializing workers in advance\n   * This reduces latency for the first transaction by having workers ready\n   */\n  async preWarmWorkerPool(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (let i = 0; i < this.MAX_WORKER_POOL_SIZE; i++) {\n      promises.push(\n        new Promise<void>((resolve, reject) => {\n          try {\n            const worker = this.createSecureWorker();\n\n            // Set up one-time ready handler\n            const onReady = (event: MessageEvent) => {\n              if (event.data?.type === 'WORKER_READY' || event.data?.ready) {\n                worker.removeEventListener('message', onReady);\n                this.terminateAndReplaceWorker(worker);\n                resolve();\n              }\n            };\n\n            worker.addEventListener('message', onReady);\n\n            // Set up error handler\n            worker.onerror = (error) => {\n              worker.removeEventListener('message', onReady);\n              console.error(`WebAuthnManager: Worker ${i + 1} pre-warm failed:`, error);\n              reject(error);\n            };\n\n            // Timeout after 5 seconds\n            setTimeout(() => {\n              worker.removeEventListener('message', onReady);\n              console.warn(`WebAuthnManager: Worker ${i + 1} pre-warm timeout`);\n              reject(new Error('Pre-warm timeout'));\n            }, 5000);\n\n          } catch (error) {\n            console.error(`WebAuthnManager: Failed to create worker ${i + 1}:`, error);\n            reject(error);\n          }\n        })\n      );\n    }\n\n    try {\n      await Promise.allSettled(promises);\n    } catch (error) {\n      console.warn('WebAuthnManager: Some workers failed to pre-warm:', error);\n    }\n  }\n\n  private async sendMessage<T extends WorkerRequestType>({\n    message,\n    onEvent,\n    timeoutMs = SIGNER_WORKER_MANAGER_CONFIG.TIMEOUTS.DEFAULT // 10s\n  }: {\n    message: { type: T; payload: WorkerRequestTypeMap[T]['request'] };\n    onEvent?: (update: onProgressEvents) => void;\n    timeoutMs?: number;\n  }): Promise<WorkerResponseForRequest<T>> {\n\n    const worker = this.getWorkerFromPool();\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        try {\n          this.terminateAndReplaceWorker(worker);\n        } catch {}\n        // Notify any open modal host to transition to error state\n        try {\n          const seconds = Math.round(timeoutMs / 1000);\n          window.postMessage({ type: 'MODAL_TIMEOUT', payload: `Timed out after ${seconds}s, try again` }, '*');\n        } catch {}\n        reject(new Error(`Worker operation timed out after ${timeoutMs}ms`));\n      }, timeoutMs);\n\n      const responses: WorkerResponseForRequest<T>[] = [];\n\n      worker.onmessage = async (event) => {\n        try {\n          // Ignore readiness pings that can arrive if a worker was just spawned\n          if (event?.data?.type === 'WORKER_READY' || event?.data?.ready) {\n            return; // not a response to an operation\n          }\n          // Use strong typing from WASM-generated types\n          const response = event.data as WorkerResponseForRequest<T>;\n          responses.push(response);\n\n          // Intercept secure confirm handshake (Phase A: pluggable UI)\n          if (event.data.type === SecureConfirmMessageType.PROMPT_USER_CONFIRM_IN_JS_MAIN_THREAD) {\n            await handlePromptUserConfirmInJsMainThread(\n              this.getContext(),\n              event.data as {\n                type: SecureConfirmMessageType.PROMPT_USER_CONFIRM_IN_JS_MAIN_THREAD,\n                data: SecureConfirmData,\n              },\n              worker\n            );\n            return; // do not treat as a worker response, continue listening for more messages\n          }\n\n          // Handle progress updates using WASM-generated numeric enum values\n          if (isWorkerProgress(response)) {\n            const progressResponse = response as WorkerProgressResponse;\n            onEvent?.(progressResponse.payload as onProgressEvents);\n            return; // Continue listening for more messages\n          }\n\n          // Handle errors using WASM-generated enum\n          if (isWorkerError(response)) {\n            clearTimeout(timeoutId);\n            this.terminateAndReplaceWorker(worker);\n            const errorResponse = response as WorkerErrorResponse;\n            console.error('Worker error response:', errorResponse);\n            reject(new Error(errorResponse.payload.error));\n            return;\n          }\n\n          // Handle successful completion types using strong typing\n          if (isWorkerSuccess(response)) {\n            clearTimeout(timeoutId);\n            this.terminateAndReplaceWorker(worker);\n            resolve(response as WorkerResponseForRequest<T>);\n            return;\n          }\n\n          // If we reach here, the response doesn't match any expected type\n          console.error('Unexpected worker response format:', {\n            response,\n            responseType: typeof response,\n            isObject: typeof response === 'object',\n            hasType: response && typeof response === 'object' && 'type' in response,\n            type: (response as any)?.type\n          });\n\n          // Check if it's a generic Error object\n          if (response && typeof response === 'object' && 'message' in response && 'stack' in response) {\n            clearTimeout(timeoutId);\n            this.terminateAndReplaceWorker(worker);\n            console.error('Worker sent generic Error object:', response);\n            reject(new Error(`Worker sent generic error: ${(response as Error).message}`));\n            return;\n          }\n\n          // Unknown response format\n          clearTimeout(timeoutId);\n          this.terminateAndReplaceWorker(worker);\n          reject(new Error(`Unknown worker response format: ${JSON.stringify(response)}`));\n        } catch (error) {\n          clearTimeout(timeoutId);\n          this.terminateAndReplaceWorker(worker);\n          console.error('Error processing worker message:', error);\n          reject(new Error(`Worker message processing error: ${error instanceof Error ? error.message : String(error)}`));\n        }\n      };\n\n      worker.onerror = (event) => {\n        clearTimeout(timeoutId);\n        this.terminateAndReplaceWorker(worker);\n        const errorMessage = event.error?.message || event.message || 'Unknown worker error';\n        console.error('Worker error details (progress):', {\n          message: errorMessage,\n          filename: event.filename,\n          lineno: event.lineno,\n          colno: event.colno,\n          error: event.error\n        });\n        reject(new Error(`Worker error: ${errorMessage}`));\n      };\n\n      // Format message for Rust SignerWorkerMessage structure using WASM types\n      const formattedMessage = {\n        type: message.type, // Numeric enum value from WorkerRequestType\n        payload: message.payload,\n      };\n\n      worker.postMessage(formattedMessage);\n    });\n  }\n\n  /**\n   * Secure registration flow with dual PRF: WebAuthn + WASM worker encryption using dual PRF\n   * Optionally signs a link_device_register_user transaction if VRF data is provided\n   */\n  async deriveNearKeypairAndEncrypt(args: {\n    credential: PublicKeyCredential,\n    nearAccountId: AccountId,\n    options?: {\n      vrfChallenge: VRFChallenge;\n      deterministicVrfPublicKey: string; // Add VRF public key for registration transactions\n      contractId: string;\n      nonce: string;\n      blockHash: string;\n      authenticatorOptions?: AuthenticatorOptions; // Authenticator options for registration\n    }\n  }): Promise<{\n    success: boolean;\n    nearAccountId: AccountId;\n    publicKey: string;\n    signedTransaction?: SignedTransaction;\n  }> {\n    return deriveNearKeypairAndEncrypt({ ctx: this.getContext(), ...args });\n  }\n\n  /**\n   * Secure private key decryption with dual PRF\n   */\n  async decryptPrivateKeyWithPrf(args: {\n    nearAccountId: AccountId,\n    authenticators: ClientAuthenticatorData[],\n  }): Promise<{\n    decryptedPrivateKey: string;\n    nearAccountId: AccountId\n  }> {\n    return decryptPrivateKeyWithPrf({ ctx: this.getContext(), ...args });\n  }\n\n  async checkCanRegisterUser(args: {\n    vrfChallenge: VRFChallenge,\n    credential: PublicKeyCredential,\n    contractId: string;\n    nearRpcUrl: string;\n    authenticatorOptions?: AuthenticatorOptions; // Authenticator options for registration check\n    onEvent?: (update: onProgressEvents) => void;\n  }): Promise<{\n    success: boolean;\n    verified?: boolean;\n    registrationInfo?: any;\n    logs?: string[];\n    signedTransactionBorsh?: number[];\n    error?: string;\n  }> {\n    return checkCanRegisterUser({ ctx: this.getContext(), ...args });\n  }\n\n  /**\n   * @deprecated Testnet only, use createAccountAndRegisterWithRelayServer instead for prod\n   */\n  async signVerifyAndRegisterUser(args: {\n    vrfChallenge: VRFChallenge,\n    credential: PublicKeyCredential,\n    contractId: string;\n    deterministicVrfPublicKey: string; // Required deterministic VRF key for dual registration\n    nearAccountId: AccountId;\n    nearPublicKeyStr: string;\n    nearClient: NearClient; // NEAR RPC client for getting transaction metadata\n    nearRpcUrl: string; // NEAR RPC URL for contract verification\n    deviceNumber?: number; // Device number for multi-device support (defaults to 1)\n    authenticatorOptions?: AuthenticatorOptions; // Authenticator options for registration\n    onEvent?: (update: onProgressEvents) => void;\n  }): Promise<{\n    verified: boolean;\n    registrationInfo?: any;\n    logs?: string[];\n    signedTransaction: SignedTransaction;\n    preSignedDeleteTransaction: SignedTransaction | null;\n  }> {\n    return signVerifyAndRegisterUser({ ctx: this.getContext(), ...args });\n  }\n\n  // === ACTION-BASED SIGNING METHODS ===\n\n  /**\n   * Sign multiple transactions with shared VRF challenge and credential\n   * Efficiently processes multiple transactions with one PRF authentication\n   */\n  async signTransactionsWithActions(args: {\n    transactions: TransactionInputWasm[],\n    rpcCall: RpcCallPayload,\n    onEvent?: (update: onProgressEvents) => void,\n    confirmationConfigOverride?: ConfirmationConfig,\n  }): Promise<Array<{\n    signedTransaction: SignedTransaction;\n    nearAccountId: AccountId;\n    logs?: string[]\n  }>> {\n    return signTransactionsWithActions({ ctx: this.getContext(), ...args });\n  }\n\n  /**\n   * Recover keypair from authentication credential for account recovery\n   * Uses dual PRF-based Ed25519 key derivation with account-specific HKDF and AES encryption\n   */\n  async recoverKeypairFromPasskey(args: {\n    credential: PublicKeyCredential;\n    accountIdHint?: string;\n  }): Promise<{\n    publicKey: string;\n    encryptedPrivateKey: string;\n    iv: string;\n    accountIdHint?: string;\n  }> {\n    return recoverKeypairFromPasskey({ ctx: this.getContext(), ...args });\n  }\n\n  /**\n   * Extract COSE public key from WebAuthn attestation object\n   * Simple operation that doesn't require TouchID or progress updates\n   */\n  async extractCosePublicKey(attestationObjectBase64url: string): Promise<Uint8Array> {\n    return extractCosePublicKey({ ctx: this.getContext(), attestationObjectBase64url });\n  }\n\n  /**\n   * Sign transaction with raw private key (for key replacement in Option D device linking)\n   * No TouchID/PRF required - uses provided private key directly\n   */\n  async signTransactionWithKeyPair(args: {\n    nearPrivateKey: string;\n    signerAccountId: string;\n    receiverId: string;\n    nonce: string;\n    blockHash: string;\n    actions: ActionArgsWasm[];\n  }): Promise<{\n    signedTransaction: SignedTransaction;\n    logs?: string[];\n  }> {\n    return signTransactionWithKeyPair({ ctx: this.getContext(), ...args });\n  }\n\n  /**\n   * Sign a NEP-413 message using the user's passkey-derived private key\n   *\n   * @param payload - NEP-413 signing parameters including message, recipient, nonce, and state\n   * @returns Promise resolving to signing result with account ID, public key, and signature\n   */\n  async signNep413Message(payload: {\n    message: string;\n    recipient: string;\n    nonce: string;\n    state: string | null;\n    accountId: string;\n    credential: PublicKeyCredential;\n  }): Promise<{\n    success: boolean;\n    accountId: string;\n    publicKey: string;\n    signature: string;\n    state?: string;\n    error?: string;\n  }> {\n    return signNep413Message({ ctx: this.getContext(), payload });\n  }\n\n}\n"],"mappings":"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"}