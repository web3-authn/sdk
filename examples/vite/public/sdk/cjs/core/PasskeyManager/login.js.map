{"version":3,"file":"login.js","names":["LoginPhase","LoginStatus","err: any","userData","authenticators","unlockResult: { success: boolean; error?: string }","error: any","createRandomVRFChallenge","result: LoginResult","getUserFriendlyErrorMessage"],"sources":["../../../../src/core/PasskeyManager/login.ts"],"sourcesContent":["import type {\n  LoginHooksOptions,\n  LoginResult,\n  LoginState,\n  LoginSSEvent,\n} from '../types/passkeyManager';\nimport { LoginPhase, LoginStatus } from '../types/passkeyManager';\nimport type { PasskeyManagerContext } from './index';\nimport type { AccountId } from '../types/accountIds';\nimport type { WebAuthnAuthenticationCredential } from '../types/webauthn';\nimport { getUserFriendlyErrorMessage } from '../../utils/errors';\nimport { createRandomVRFChallenge, ServerEncryptedVrfKeypair, VRFChallenge } from '../types/vrf-worker';\nimport { base64UrlEncode } from '@/utils/encoders';\n\n/**\n * Core login function that handles passkey authentication without React dependencies\n */\nexport async function loginPasskey(\n  context: PasskeyManagerContext,\n  nearAccountId: AccountId,\n  options?: LoginHooksOptions\n): Promise<LoginResult> {\n\n  const { onEvent, onError, hooks } = options || {};\n  // Emit started event\n  onEvent?.({\n    step: 1,\n    phase: LoginPhase.STEP_1_PREPARATION,\n    status: LoginStatus.PROGRESS,\n    message: `Starting login for ${nearAccountId}`\n  });\n\n  try {\n    // Run beforeCall hook\n    await hooks?.beforeCall?.();\n\n    // Validation\n    if (!window.isSecureContext) {\n      const errorMessage = 'Passkey operations require a secure context (HTTPS or localhost).';\n      const error = new Error(errorMessage);\n      onError?.(error);\n      onEvent?.({\n        step: 0,\n        phase: LoginPhase.LOGIN_ERROR,\n        status: LoginStatus.ERROR,\n        message: errorMessage,\n        error: errorMessage\n      });\n      const result = { success: false, error: errorMessage };\n      hooks?.afterCall?.(false, result);\n      return result;\n    }\n\n    // Handle login and unlock VRF keypair in VRF WASM worker for WebAuthn challenge generation\n    return await handleLoginUnlockVRF(\n      context,\n      nearAccountId,\n      onEvent,\n      onError,\n      hooks\n    );\n\n  } catch (err: any) {\n    onError?.(err);\n    onEvent?.({\n      step: 0,\n      phase: LoginPhase.LOGIN_ERROR,\n      status: LoginStatus.ERROR,\n      message: err.message,\n      error: err.message\n    });\n    const result = { success: false, error: err.message };\n    hooks?.afterCall?.(false, result);\n    return result;\n  }\n}\n\n/**\n * Handle onchain (serverless) login using VRF flow per docs/vrf_challenges.md\n *\n * VRF AUTHENTICATION FLOW:\n * 1. Unlock VRF keypair in Service Worker memory using PRF\n *      - Check if user has VRF credentials stored locally\n *      - Decrypt VRF keypair using PRF from WebAuthn ceremony\n * 2. Generate VRF challenge using stored VRF keypair + NEAR block data (no TouchID needed)\n * 3. Use VRF output as WebAuthn challenge for authentication\n * 4. Verify VRF proof and WebAuthn response on contract simultaneously\n *      - VRF proof assures WebAuthn challenge is fresh and valid (replay protection)\n *      - WebAuthn verification for origin + biometric credentials + device authenticity\n *\n * BENEFITS OF VRF FLOW:\n * - Single WebAuthn authentication to unlock VRF keys to generate WebAuthn challenges\n *   - VRF keypair persists in-memory in VRF Worker until logout\n *   - Subsequent authentications can generate VRF challenges without additional TouchID\n * - Provides cryptographically verifiable, stateless authentication\n * - Uses NEAR block data for freshness guarantees\n * - Follows RFC-compliant VRF challenge construction\n * - Eliminates server-side session state\n */\nasync function handleLoginUnlockVRF(\n  context: PasskeyManagerContext,\n  nearAccountId: AccountId,\n  onEvent?: (event: LoginSSEvent) => void,\n  onError?: (error: Error) => void,\n  hooks?: {\n    beforeCall?: () => void | Promise<void>;\n    afterCall?: (success: boolean, result?: any) => void | Promise<void>\n  }\n): Promise<LoginResult> {\n\n  const { webAuthnManager } = context;\n\n  try {\n\n    // Step 1: Get VRF credentials and authenticators, and validate them\n    const {\n      userData,\n      authenticators\n    } = await Promise.all([\n      webAuthnManager.getUser(nearAccountId),\n      webAuthnManager.getAuthenticatorsByUser(nearAccountId),\n    ]).then(([userData, authenticators]) => {\n      // Validate user data and authenticators\n      if (!userData) {\n        throw new Error(`User data not found for ${nearAccountId} in IndexedDB. Please register an account.`);\n      }\n      if (!userData.clientNearPublicKey) {\n        throw new Error(`No NEAR public key found for ${nearAccountId}. Please register an account.`);\n      }\n      if (\n        !userData.encryptedVrfKeypair?.encryptedVrfDataB64u ||\n        !userData.encryptedVrfKeypair?.chacha20NonceB64u\n      ) {\n        throw new Error('No VRF credentials found. Please register an account.');\n      }\n      if (authenticators.length === 0) {\n        throw new Error(`No authenticators found for account ${nearAccountId}. Please register.`);\n      }\n      return { userData, authenticators };\n    });\n\n    // Step 2: Try Shamir 3-pass commutative unlock first (no TouchID required), fallback to TouchID\n    onEvent?.({\n      step: 2,\n      phase: LoginPhase.STEP_2_WEBAUTHN_ASSERTION,\n      status: LoginStatus.PROGRESS,\n      message: 'Attempting to unlock VRF keypair...'\n    });\n\n    let unlockResult: { success: boolean; error?: string } = { success: false };\n\n    const hasServerEncrypted = !!userData.serverEncryptedVrfKeypair;\n    const relayerUrl = context.configs.relayer?.url;\n    const useShamir3PassVRFKeyUnlock = hasServerEncrypted && !!relayerUrl;\n\n    if (useShamir3PassVRFKeyUnlock) {\n      try {\n        const shamir = userData.serverEncryptedVrfKeypair as ServerEncryptedVrfKeypair;\n        if (!shamir.ciphertextVrfB64u || !shamir.kek_s_b64u) {\n          throw new Error('Missing Shamir3Pass fields (ciphertextVrfB64u/kek_s_b64u)');\n        }\n\n        unlockResult = await webAuthnManager.shamir3PassDecryptVrfKeypair({\n          nearAccountId,\n          kek_s_b64u: shamir.kek_s_b64u,\n          ciphertextVrfB64u: shamir.ciphertextVrfB64u,\n        });\n\n        if (unlockResult.success) {\n          const vrfStatus = await webAuthnManager.checkVrfStatus();\n          const active = vrfStatus.active && vrfStatus.nearAccountId === nearAccountId;\n          if (!active) {\n            unlockResult = { success: false, error: 'VRF session inactive after Shamir3Pass' };\n          }\n        } else {\n          console.error('Shamir3Pass unlock failed:', unlockResult.error);\n          throw new Error(`Shamir3Pass unlock failed: ${unlockResult.error}`);\n        }\n      } catch (error: any) {\n        console.warn('Shamir3Pass unlock error, falling back to TouchID:', error.message);\n        unlockResult = { success: false, error: error.message };\n      }\n    }\n\n    // Fallback to TouchID if Shamir3Pass decryption failed\n    if (!unlockResult.success) {\n      console.debug('Falling back to TouchID authentication for VRF unlock');\n      onEvent?.({\n        step: 2,\n        phase: LoginPhase.STEP_2_WEBAUTHN_ASSERTION,\n        status: LoginStatus.PROGRESS,\n        message: 'Authenticating with TouchID to unlock VRF keypair...'\n      });\n\n      // Get credential for VRF unlock\n      const challenge = createRandomVRFChallenge();\n      const credential = await webAuthnManager.getCredentials({\n        nearAccountId,\n        challenge: challenge as VRFChallenge,\n        authenticators,\n      });\n\n      unlockResult = await webAuthnManager.unlockVRFKeypair({\n        nearAccountId: nearAccountId,\n        encryptedVrfKeypair: {\n          encryptedVrfDataB64u: userData.encryptedVrfKeypair.encryptedVrfDataB64u,\n          chacha20NonceB64u: userData.encryptedVrfKeypair.chacha20NonceB64u,\n        },\n        credential: credential,\n      });\n    }\n\n    if (!unlockResult.success) {\n      throw new Error(`Failed to unlock VRF keypair: ${unlockResult.error}`);\n    }\n\n    onEvent?.({\n      step: 3,\n      phase: LoginPhase.STEP_3_VRF_UNLOCK,\n      status: LoginStatus.SUCCESS,\n      message: 'VRF keypair unlocked successfully'\n    });\n\n    // Step 3: Update local data and return success\n    await webAuthnManager.updateLastLogin(nearAccountId);\n    await webAuthnManager.setLastUser(nearAccountId);\n\n    const result: LoginResult = {\n      success: true,\n      loggedInNearAccountId: nearAccountId,\n      clientNearPublicKey: userData?.clientNearPublicKey!, // non-null, validated above\n      nearAccountId: nearAccountId\n    };\n\n    onEvent?.({\n      step: 4,\n      phase: LoginPhase.STEP_4_LOGIN_COMPLETE,\n      status: LoginStatus.SUCCESS,\n      message: 'Login completed successfully',\n      nearAccountId: nearAccountId,\n      clientNearPublicKey: userData?.clientNearPublicKey || ''\n    });\n\n    hooks?.afterCall?.(true, result);\n    return result;\n\n  } catch (error: any) {\n    // Use centralized error handling\n    const errorMessage = getUserFriendlyErrorMessage(error, 'login');\n\n    onError?.(error);\n    onEvent?.({\n      step: 0,\n      phase: LoginPhase.LOGIN_ERROR,\n      status: LoginStatus.ERROR,\n      message: errorMessage,\n      error: errorMessage\n    });\n\n    const result = { success: false, error: errorMessage };\n    hooks?.afterCall?.(false, result);\n    return result;\n  }\n}\n\nexport async function getLoginState(\n  context: PasskeyManagerContext,\n  nearAccountId?: AccountId\n): Promise<LoginState> {\n  const { webAuthnManager } = context;\n  try {\n    // Determine target account ID\n    let targetAccountId = nearAccountId;\n    if (!targetAccountId) {\n      const lastUsedAccountId = await webAuthnManager.getLastUsedNearAccountId() || undefined;\n      targetAccountId = lastUsedAccountId?.nearAccountId || undefined;\n    }\n    if (!targetAccountId) {\n      return {\n        isLoggedIn: false,\n        nearAccountId: null,\n        publicKey: null,\n        vrfActive: false,\n        userData: null\n      };\n    }\n\n    // Get comprehensive user data from IndexedDB (single call instead of two)\n    const userData = await webAuthnManager.getUser(targetAccountId);\n    const publicKey = userData?.clientNearPublicKey || null;\n\n    // Check actual VRF worker status\n    const vrfStatus = await webAuthnManager.checkVrfStatus();\n    const vrfActive = vrfStatus.active && vrfStatus.nearAccountId === targetAccountId;\n\n    // Determine if user is considered \"logged in\"\n    // User is logged in if they have user data and VRF is active\n    const isLoggedIn = !!(userData && userData.clientNearPublicKey && vrfActive);\n\n    return {\n      isLoggedIn,\n      nearAccountId: targetAccountId,\n      publicKey,\n      vrfActive,\n      userData,\n      vrfSessionDuration: vrfStatus.sessionDuration || 0\n    };\n\n  } catch (error: any) {\n    console.warn('Error getting login state:', error);\n    return {\n      isLoggedIn: false,\n      nearAccountId: nearAccountId || null,\n      publicKey: null,\n      vrfActive: false,\n      userData: null\n    };\n  }\n}\n\nexport async function getRecentLogins(\n  context: PasskeyManagerContext\n): Promise<{\n  accountIds: string[],\n  lastUsedAccountId: {\n    nearAccountId: AccountId,\n    deviceNumber: number,\n  } | null\n}> {\n  const { webAuthnManager } = context;\n  // Get all user accounts from IndexDB\n  const allUsersData = await webAuthnManager.getAllUserData();\n  const accountIds = allUsersData.map(user => user.nearAccountId);\n  // Get last used account for initial state\n  const lastUsedAccountId = await webAuthnManager.getLastUsedNearAccountId();\n\n  return {\n    accountIds,\n    lastUsedAccountId,\n  }\n}\n\nexport async function logoutAndClearVrfSession(context: PasskeyManagerContext): Promise<void> {\n  console.log(\"LOGOUT AND CLEAR VRF SESSION\");\n  const { webAuthnManager } = context;\n  await webAuthnManager.clearVrfSession();\n}\n\n/**\n * Verify authentication response through relay server\n * Routes the request to relay server which calls the web3authn contract for verification\n * and issues a JWT or session credential\n */\nexport async function verifyAuthenticationResponse(\n  relayServerUrl: string,\n  vrfChallenge: VRFChallenge,\n  webauthnAuthentication: WebAuthnAuthenticationCredential\n): Promise<{\n  success: boolean;\n  verified?: boolean;\n  jwt?: string;\n  sessionCredential?: any;\n  error?: string;\n  contractResponse?: any;\n}> {\n  try {\n    const response = await fetch(`${relayServerUrl}/verify-authentication-response`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        vrfChallenge: vrfChallenge,\n        webauthnAuthentication: webauthnAuthentication,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      return {\n        success: false,\n        error: `HTTP ${response.status}: ${errorText}`,\n      };\n    }\n\n    const result = await response.json();\n    return {\n      success: true,\n      verified: result.verified,\n      jwt: result.jwt,\n      sessionCredential: result.sessionCredential,\n      contractResponse: result.contractResponse,\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      error: error.message || 'Failed to verify authentication response',\n    };\n  }\n}"],"mappings":"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"}