{"version":3,"file":"recoverAccount.js","names":["toAccountId","error: any","getCredentialIdsContractCall","AccountRecoveryPhase","AccountRecoveryStatus","validateNearAccountId","hasAccess","vrfInputData: VRFInputData","createRandomVRFChallenge","errorResult: RecoveryResult","syncAuthenticatorsContractCall","base64UrlEncode","IndexedDBManager"],"sources":["../../../../src/core/PasskeyManager/recoverAccount.ts"],"sourcesContent":["import type { OperationHooks, EventCallback, AccountRecoverySSEEvent } from '../types/passkeyManager';\nimport { AccountRecoveryPhase, AccountRecoveryStatus, AccountRecoveryHooksOptions } from '../types/passkeyManager';\nimport type { PasskeyManagerContext } from './index';\nimport type { AccountId, StoredAuthenticator, VRFChallenge } from '../types';\nimport type { EncryptedVRFKeypair, ServerEncryptedVrfKeypair } from '../types/vrf-worker';\nimport { validateNearAccountId } from '../../utils/validation';\nimport { toAccountId } from '../types/accountIds';\nimport { base64UrlEncode } from '../../utils/encoders';\nimport { createRandomVRFChallenge } from '../types/vrf-worker';\nimport { WebAuthnManager } from '../WebAuthnManager';\nimport { IndexedDBManager } from '../IndexedDBManager';\nimport type { VRFInputData } from '../types/vrf-worker';\nimport {\n  getCredentialIdsContractCall,\n  syncAuthenticatorsContractCall\n} from '../rpcCalls';\n\n/**\n * Use case:\n * Suppose a user accidentally clears their browser's indexedDB, and deletes their:\n * - encrypted NEAR keypair\n * - encrypted VRF keypair\n * - webauthn authenticator\n * Provide a way for the user to recover their account from onchain authenticator information with their Passkey.\n */\n\nexport interface RecoveryResult {\n  success: boolean;\n  accountId: string;\n  publicKey: string;\n  message: string;\n  error?: string;\n  loginState?: {\n    isLoggedIn: boolean;\n    vrfActive: boolean;\n    vrfSessionDuration?: number;\n  };\n}\n\nexport interface AccountLookupResult {\n  accountId: string;\n  publicKey: string;\n  hasAccess: boolean;\n}\n\nexport interface PasskeyOption {\n  credentialId: string;\n  accountId: AccountId | null;\n  publicKey: string;\n  displayName: string;\n  credential: PublicKeyCredential | null;\n}\n\n// Public-facing passkey option without sensitive credential data\nexport interface PasskeyOptionWithoutCredential {\n  credentialId: string;\n  accountId: string | null;\n  publicKey: string;\n  displayName: string;\n}\n\n// Internal selection identifier for secure credential lookup\nexport interface PasskeySelection {\n  credentialId: string;\n  accountId: string | null;\n}\n\n/**\n * Account recovery flow with credential encapsulation\n *\n * Usage:\n * ```typescript\n * const flow = new AccountRecoveryFlow(context);\n * const options = await flow.discover(); // Get safe display options\n * // ... user selects account in UI ...\n * const result = await flow.recover({ credentialId, accountId }); // Execute recovery\n * ```\n */\nexport class AccountRecoveryFlow {\n  private context: PasskeyManagerContext;\n  private options?: AccountRecoveryHooksOptions;\n  private availableAccounts?: PasskeyOption[]; // Full options with credentials (private)\n  private phase: 'idle' | 'discovering' | 'ready' | 'recovering' | 'complete' | 'error' = 'idle';\n  private error?: Error;\n\n  constructor(context: PasskeyManagerContext, options?: AccountRecoveryHooksOptions) {\n    this.context = context;\n    this.options = options;\n  }\n\n  /**\n   * Phase 1: Discover available accounts\n   * Returns safe display data without exposing credentials to UI\n   */\n  async discover(accountId: string): Promise<PasskeyOptionWithoutCredential[]> {\n    const nearAccountId = toAccountId(accountId);\n    try {\n      this.phase = 'discovering';\n      console.debug('AccountRecoveryFlow: Discovering available accounts...');\n\n      // Get full options with credentials, requires TouchID prompt\n      this.availableAccounts = await getRecoverableAccounts(this.context, nearAccountId);\n\n      if (this.availableAccounts.length === 0) {\n        // throw new Error('No recoverable accounts found for this passkey');\n        console.warn('No recoverable accounts found for this passkey');\n        console.warn(`Continuing with account recovery for ${accountId}`);\n      } else {\n        console.debug(`AccountRecoveryFlow: Found ${this.availableAccounts.length} recoverable accounts`);\n      }\n\n      this.phase = 'ready';\n\n      // Return safe options without credentials for UI display\n      return this.availableAccounts.map(option => ({\n        credentialId: option.credentialId,\n        accountId: option.accountId,\n        publicKey: option.publicKey,\n        displayName: option.displayName\n      }));\n\n    } catch (error: any) {\n      this.phase = 'error';\n      this.error = error;\n      console.error('AccountRecoveryFlow: Discovery failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Phase 2: Execute recovery with user selection\n   * Securely looks up credential based on selection\n   */\n  async recover(selection: PasskeySelection): Promise<RecoveryResult> {\n    if (this.phase !== 'ready') {\n      throw new Error(`Cannot recover - flow is in ${this.phase} phase. Call discover() first.`);\n    }\n    if (!this.availableAccounts) {\n      throw new Error('No available accounts found. Call discover() first.');\n    }\n\n    try {\n      this.phase = 'recovering';\n      console.debug(`AccountRecoveryFlow: Recovering account: ${selection.accountId}`);\n\n      // Securely lookup the full option with credential\n      const selectedOption = this.availableAccounts.find(\n        option => option.credentialId === selection.credentialId &&\n                 option.accountId === selection.accountId\n      );\n\n      if (!selectedOption) {\n        throw new Error('Invalid selection - account not found in available options');\n      }\n      if (!selectedOption.accountId) {\n        throw new Error('Invalid account selection - no account ID provided');\n      }\n\n      const recoveryResult = await recoverAccount(\n        this.context,\n        selectedOption.accountId,\n        this.options,\n        selectedOption.credential || undefined,\n        selectedOption.credentialId && selectedOption.credentialId !== 'manual-input' ? [selectedOption.credentialId] : undefined\n      );\n\n      this.phase = 'complete';\n      return recoveryResult;\n\n    } catch (error: any) {\n      this.phase = 'error';\n      this.error = error;\n      console.error('AccountRecoveryFlow: Recovery failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get current flow state (safe display data only)\n   */\n  getState() {\n    // Convert internal accounts to safe display format\n    const safeAccounts = this.availableAccounts?.map(option => ({\n      credentialId: option.credentialId,\n      accountId: option.accountId,\n      publicKey: option.publicKey,\n      displayName: option.displayName\n    }));\n\n    return {\n      phase: this.phase,\n      availableAccounts: safeAccounts,\n      error: this.error,\n      isReady: this.phase === 'ready',\n      isComplete: this.phase === 'complete',\n      hasError: this.phase === 'error'\n    };\n  }\n\n  /**\n   * Reset flow to initial state\n   */\n  reset() {\n    this.phase = 'idle';\n    this.availableAccounts = undefined;\n    this.error = undefined;\n  }\n}\n\n/**\n * Get available passkeys for account recovery\n */\nasync function getRecoverableAccounts(\n  context: PasskeyManagerContext,\n  accountId: AccountId\n): Promise<PasskeyOption[]> {\n  const availablePasskeys = await getAvailablePasskeysForDomain(context, accountId);\n  return availablePasskeys.filter(passkey => passkey.accountId !== null);\n}\n\n/**\n * Discover passkeys for domain using contract-based lookup\n */\nasync function getAvailablePasskeysForDomain(\n  context: PasskeyManagerContext,\n  accountId: AccountId\n): Promise<PasskeyOption[]> {\n  const { nearClient, configs } = context;\n\n  const credentialIds = await getCredentialIdsContractCall(nearClient, configs.contractId, accountId);\n\n  // Do not invoke WebAuthn here; just return display options bound to credential IDs\n  if (credentialIds.length > 0) {\n    return credentialIds.map((credentialId, idx) => ({\n      credentialId,\n      accountId,\n      publicKey: '',\n      displayName: credentialIds.length > 1 ? `${accountId} (passkey ${idx + 1})` : `${accountId}`,\n      credential: null,\n    }));\n  }\n\n  // If no contract credentials found, still allow recovery by letting recover() prompt once\n  return [{\n    credentialId: 'manual-input',\n    accountId: accountId,\n    publicKey: '',\n    displayName: `${accountId}`,\n    credential: null,\n  }];\n}\n\n/**\n * Main account recovery function\n */\nexport async function recoverAccount(\n  context: PasskeyManagerContext,\n  accountId: AccountId,\n  options?: AccountRecoveryHooksOptions,\n  reuseCredential?: PublicKeyCredential,\n  allowedCredentialIds?: string[]\n): Promise<RecoveryResult> {\n  const { onEvent, onError, hooks } = options || {};\n  const { webAuthnManager, nearClient, configs } = context;\n\n  await hooks?.beforeCall?.();\n\n  onEvent?.({\n    step: 1,\n    phase: AccountRecoveryPhase.STEP_1_PREPARATION,\n    status: AccountRecoveryStatus.PROGRESS,\n    message: 'Preparing account recovery...',\n  });\n\n  try {\n    const validation = validateNearAccountId(accountId);\n    if (!validation.valid) {\n      return handleRecoveryError(accountId, `Invalid NEAR account ID: ${validation.error}`, onError, hooks);\n    }\n\n    onEvent?.({\n      step: 2,\n      phase: AccountRecoveryPhase.STEP_2_WEBAUTHN_AUTHENTICATION,\n      status: AccountRecoveryStatus.PROGRESS,\n      message: 'Authenticating with WebAuthn...',\n    });\n\n    const credential = await getOrCreateCredential(webAuthnManager, accountId, reuseCredential, allowedCredentialIds);\n    const recoveredKeypair = await deriveNearKeypairFromCredential(webAuthnManager, credential, accountId);\n\n    const { hasAccess, blockHeight, blockHash } = await Promise.all([\n      nearClient.viewAccessKey(accountId, recoveredKeypair.publicKey),\n      nearClient.viewBlock({ finality: 'final' })\n    ]).then(([hasAccess, blockInfo]) => {\n      return {\n        hasAccess,\n        blockHeight: String(blockInfo.header.height),\n        blockHash: blockInfo.header.hash,\n      };\n    });\n\n    if (!hasAccess) {\n      return handleRecoveryError(accountId, `Account ${accountId} was not created with this passkey`, onError, hooks);\n    }\n\n    const vrfInputData: VRFInputData = {\n      userId: accountId,\n      rpId: window.location.hostname,\n      blockHeight,\n      blockHash,\n    };\n\n    const deterministicVrfResult = await webAuthnManager.deriveVrfKeypair({\n      credential,\n      nearAccountId: accountId,\n      vrfInputData,\n    });\n\n    if (!deterministicVrfResult.success) {\n      throw new Error('Failed to derive deterministic VRF keypair and generate challenge from PRF');\n    }\n\n    const recoveryResult = await performAccountRecovery({\n      context,\n      accountId,\n      publicKey: recoveredKeypair.publicKey,\n      encryptedKeypair: {\n        encryptedPrivateKey: recoveredKeypair.encryptedPrivateKey,\n        iv: recoveredKeypair.iv,\n      },\n      credential,\n      encryptedVrfResult: {\n        vrfPublicKey: deterministicVrfResult.vrfPublicKey,\n        encryptedVrfKeypair: deterministicVrfResult.encryptedVrfKeypair,\n        serverEncryptedVrfKeypair: deterministicVrfResult.serverEncryptedVrfKeypair || undefined,\n      },\n      onEvent,\n    });\n\n    onEvent?.({\n      step: 5,\n      phase: AccountRecoveryPhase.STEP_5_ACCOUNT_RECOVERY_COMPLETE,\n      status: AccountRecoveryStatus.SUCCESS,\n      message: 'Account recovery completed successfully',\n      data: recoveryResult,\n    });\n\n    hooks?.afterCall?.(true, recoveryResult);\n    return recoveryResult;\n  } catch (error: any) {\n    onError?.(error);\n    return handleRecoveryError(accountId, error.message, onError, hooks);\n  }\n}\n\n/**\n * Get credential (reuse existing or create new)\n */\nasync function getOrCreateCredential(\n  webAuthnManager: WebAuthnManager,\n  accountId: AccountId,\n  reuseCredential?: PublicKeyCredential,\n  allowedCredentialIds?: string[]\n): Promise<PublicKeyCredential> {\n  if (reuseCredential) {\n    const prfResults = reuseCredential.getClientExtensionResults()?.prf?.results;\n    if (!prfResults?.first || !prfResults?.second) {\n      throw new Error('Reused credential missing PRF outputs - cannot proceed with recovery');\n    }\n    return reuseCredential;\n  }\n\n  const challenge = createRandomVRFChallenge();\n\n  return await webAuthnManager.getCredentialsForRecovery({\n    nearAccountId: accountId,\n    challenge: challenge as VRFChallenge,\n    credentialIds: allowedCredentialIds ?? []\n  });\n}\n\n/**\n * Derive NEAR keypair from credential\n */\nasync function deriveNearKeypairFromCredential(\n  webAuthnManager: WebAuthnManager,\n  credential: PublicKeyCredential,\n  accountId: string\n) {\n  return await webAuthnManager.recoverKeypairFromPasskey(\n    credential,\n    accountId\n  );\n}\n\n/**\n * Handle recovery error\n */\nfunction handleRecoveryError(\n  accountId: AccountId,\n  errorMessage: string,\n  onError?: (error: Error) => void,\n  hooks?: OperationHooks\n): RecoveryResult {\n  console.error('[recoverAccount] Error:', errorMessage);\n  onError?.(new Error(errorMessage));\n\n  const errorResult: RecoveryResult = {\n    success: false,\n    accountId,\n    publicKey: '',\n    message: `Recovery failed: ${errorMessage}`,\n    error: errorMessage\n  };\n\n  const result = { success: false, accountId, error: errorMessage };\n  hooks?.afterCall?.(false, result);\n  return errorResult;\n}\n\n/**\n * Perform the actual recovery process\n * Syncs on-chain data and restores local IndexedDB data\n */\nasync function performAccountRecovery({\n  context,\n  accountId,\n  publicKey,\n  encryptedKeypair,\n  credential,\n  encryptedVrfResult,\n  onEvent,\n}: {\n  context: PasskeyManagerContext,\n  accountId: AccountId,\n  publicKey: string,\n  encryptedKeypair: {\n    encryptedPrivateKey: string,\n    iv: string\n  },\n  credential: PublicKeyCredential,\n  encryptedVrfResult: {\n    encryptedVrfKeypair: EncryptedVRFKeypair;\n    vrfPublicKey: string\n    serverEncryptedVrfKeypair?: ServerEncryptedVrfKeypair\n  },\n  onEvent?: EventCallback<AccountRecoverySSEEvent>,\n}): Promise<RecoveryResult> {\n\n  const { webAuthnManager, nearClient, configs } = context;\n\n  try {\n    console.debug(`Performing recovery for account: ${accountId}`);\n    onEvent?.({\n      step: 3,\n      phase: AccountRecoveryPhase.STEP_3_SYNC_AUTHENTICATORS_ONCHAIN,\n      status: AccountRecoveryStatus.PROGRESS,\n      message: 'Syncing authenticators from onchain...',\n    });\n\n    // 1. Sync on-chain authenticator data\n    const contractAuthenticators = await syncAuthenticatorsContractCall(nearClient, configs.contractId, accountId);\n\n    // 2. Find the matching authenticator to get the correct device number\n    const credentialIdUsed = base64UrlEncode(credential.rawId);\n    const matchingAuthenticator = contractAuthenticators.find(auth => auth.credentialId === credentialIdUsed);\n\n    if (!matchingAuthenticator) {\n      throw new Error(`Could not find authenticator for credential ${credentialIdUsed}`);\n    }\n\n    const deviceNumber = matchingAuthenticator.authenticator.deviceNumber;\n    if (deviceNumber === undefined) {\n      throw new Error(`Device number not found for authenticator ${credentialIdUsed}`);\n    }\n\n    // 3. Restore user data to IndexedDB with correct device number\n    // Use the server-encrypted VRF keypair directly from the VRF worker result\n    const serverEncryptedVrfKeypairObj = encryptedVrfResult.serverEncryptedVrfKeypair;\n\n    await restoreUserData({\n      webAuthnManager,\n      accountId,\n      deviceNumber,\n      publicKey,\n      encryptedVrfKeypair: encryptedVrfResult.encryptedVrfKeypair,\n      serverEncryptedVrfKeypair: serverEncryptedVrfKeypairObj,\n      encryptedNearKeypair: encryptedKeypair,\n      credential\n    });\n\n    // 4. Restore only the authenticator used for recovery\n    await restoreAuthenticators({\n      webAuthnManager,\n      accountId,\n      contractAuthenticators: [matchingAuthenticator],\n      vrfPublicKey: encryptedVrfResult.vrfPublicKey\n      // deterministically derived VRF keypair\n    });\n\n    onEvent?.({\n      step: 4,\n      phase: AccountRecoveryPhase.STEP_4_AUTHENTICATOR_SAVED,\n      status: AccountRecoveryStatus.SUCCESS,\n      message: 'Restored Passkey authenticator...',\n    });\n\n    // 5. Unlock VRF keypair in memory for immediate use\n    console.debug('Unlocking VRF keypair in memory after account recovery');\n    const unlockResult = await webAuthnManager.unlockVRFKeypair({\n      nearAccountId: accountId,\n      encryptedVrfKeypair: encryptedVrfResult.encryptedVrfKeypair,\n      credential: credential,\n    });\n\n    if (!unlockResult.success) {\n      console.warn('Failed to unlock VRF keypair after recovery:', unlockResult.error);\n      // Don't throw error here - recovery was successful, but VRF unlock failed\n    } else {\n      console.debug('VRF keypair unlocked successfully after account recovery');\n    }\n\n    return {\n      success: true,\n      accountId,\n      publicKey,\n      message: 'Account successfully recovered',\n    };\n\n  } catch (error: any) {\n    console.error('[performAccountRecovery] Error:', error);\n    throw new Error(`Recovery process failed: ${error.message}`);\n  }\n}\n\n/** Stored authenticator onchain uses snake case */\nexport interface ContractStoredAuthenticator {\n  credential_id: string;\n  credential_public_key: Uint8Array;\n  transports: AuthenticatorTransport[];\n  registered: string; // Contract returns timestamp as string\n  vrf_public_keys?: string[];\n  device_number: number; // Always present from contract\n}\n\nasync function restoreUserData({\n  webAuthnManager,\n  accountId,\n  deviceNumber,\n  publicKey,\n  encryptedVrfKeypair,\n  serverEncryptedVrfKeypair,\n  encryptedNearKeypair,\n  credential\n}: {\n  webAuthnManager: WebAuthnManager,\n  accountId: AccountId,\n  deviceNumber: number,\n  publicKey: string,\n  encryptedVrfKeypair: EncryptedVRFKeypair,\n  serverEncryptedVrfKeypair?: ServerEncryptedVrfKeypair,\n  encryptedNearKeypair: {\n    encryptedPrivateKey: string;\n    iv: string\n  },\n  credential: PublicKeyCredential\n}) {\n  const existingUser = await webAuthnManager.getUser(accountId);\n\n  // Store the encrypted NEAR keypair in the encrypted keys database\n  await IndexedDBManager.nearKeysDB.storeEncryptedKey({\n    nearAccountId: accountId,\n    encryptedData: encryptedNearKeypair.encryptedPrivateKey,\n    iv: encryptedNearKeypair.iv,\n    timestamp: Date.now()\n  });\n  console.log(\"user data restored: serverEncryptedVrfKeypair\", serverEncryptedVrfKeypair);\n\n  if (!existingUser) {\n    await webAuthnManager.registerUser({\n      nearAccountId: accountId,\n      deviceNumber,\n      clientNearPublicKey: publicKey,\n      lastUpdated: Date.now(),\n      passkeyCredential: {\n        id: credential.id,\n        rawId: base64UrlEncode(credential.rawId)\n      },\n      encryptedVrfKeypair: {\n        encryptedVrfDataB64u: encryptedVrfKeypair.encryptedVrfDataB64u,\n        chacha20NonceB64u: encryptedVrfKeypair.chacha20NonceB64u,\n      },\n      serverEncryptedVrfKeypair,\n    });\n  } else {\n    await webAuthnManager.storeUserData({\n      nearAccountId: accountId,\n      clientNearPublicKey: publicKey,\n      lastUpdated: Date.now(),\n      passkeyCredential: existingUser.passkeyCredential,\n      encryptedVrfKeypair: {\n        encryptedVrfDataB64u: encryptedVrfKeypair.encryptedVrfDataB64u,\n        chacha20NonceB64u: encryptedVrfKeypair.chacha20NonceB64u,\n      },\n      serverEncryptedVrfKeypair,\n      deviceNumber\n    });\n  }\n}\n\nasync function restoreAuthenticators({\n  webAuthnManager,\n  accountId,\n  contractAuthenticators,\n  vrfPublicKey\n}: {\n  webAuthnManager: WebAuthnManager,\n  accountId: AccountId,\n  contractAuthenticators: {\n    credentialId: string,\n    authenticator: StoredAuthenticator\n  }[],\n  vrfPublicKey: string\n}) {\n  for (const { credentialId, authenticator } of contractAuthenticators) {\n    const credentialPublicKey = authenticator.credentialPublicKey;\n\n    // Fix transport processing: filter out undefined values and provide fallback\n    const validTransports = authenticator.transports.filter((transport) =>\n      transport !== undefined && transport !== null && typeof transport === 'string'\n    );\n\n    // If no valid transports, default to 'internal' for platform authenticators\n    const transports = validTransports?.length > 0 ? validTransports : ['internal'];\n\n    // Extract device number from contract authenticator data (now camelCase)\n    const deviceNumber = authenticator.deviceNumber;\n    console.log(\"Restoring authenticator with device number:\", deviceNumber, authenticator);\n\n    await webAuthnManager.storeAuthenticator({\n      nearAccountId: accountId,\n      credentialId: credentialId,\n      credentialPublicKey,\n      transports,\n      name: `Recovered Device ${deviceNumber} Passkey`,\n      registered: authenticator.registered.toISOString(),\n      syncedAt: new Date().toISOString(),\n      vrfPublicKey,\n      deviceNumber // Pass the device number from contract data\n    });\n  }\n}\n"],"mappings":"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"}