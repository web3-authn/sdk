{"version":3,"file":"qrScanner.js","names":["options: ScanQRCodeFlowOptions","events: ScanQRCodeFlowEvents","error: any","constraints: MediaStreamConstraints","parsedData: DeviceLinkingQRData"],"sources":["../../../src/utils/qrScanner.ts"],"sourcesContent":["import type { DeviceLinkingQRData } from '../core/types/linkDevice';\nimport { DeviceLinkingError, DeviceLinkingErrorCode } from '../core/types/linkDevice';\nimport { validateDeviceLinkingQRData } from '../core/PasskeyManager/scanDevice';\nimport { DeviceLinkingSSEEvent } from '@/core/types/passkeyManager';\n\n// ===========================\n// TYPES AND INTERFACES\n// ===========================\n\nexport interface ScanQRCodeFlowOptions {\n  cameraId?: string;\n  cameraConfigs?: {\n    facingMode?: 'user' | 'environment';\n    width?: number;\n    height?: number;\n  };\n  timeout?: number; // in milliseconds, default 60000\n}\n\nexport interface ScanQRCodeFlowEvents {\n  onEvent?: (event: DeviceLinkingSSEEvent) => void;\n  onQRDetected?: (qrData: DeviceLinkingQRData) => void;\n  onError?: (error: Error) => void;\n  onCameraReady?: (stream: MediaStream) => void;\n  onScanProgress?: (duration: number) => void; // Called periodically during scanning\n}\n\nexport enum ScanQRCodeFlowState {\n  IDLE = 'idle',\n  INITIALIZING = 'initializing',\n  SCANNING = 'scanning',\n  SUCCESS = 'success',\n  ERROR = 'error',\n  CANCELLED = 'cancelled'\n}\n\n// ===========================\n// SCANQRCODEFLOW CLASS\n// ===========================\n\n/**\n * ScanQRCodeFlow - Encapsulates QR code scanning lifecycle\n * Can be used in both React (useQRCamera) and non-React (PasskeyManager) contexts\n */\nexport class ScanQRCodeFlow {\n  private state: ScanQRCodeFlowState = ScanQRCodeFlowState.IDLE;\n  private mediaStream: MediaStream | null = null;\n  private video: HTMLVideoElement | null = null;\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private animationId: number | null = null;\n  private timeoutId: NodeJS.Timeout | null = null;\n  private progressIntervalId: NodeJS.Timeout | null = null;\n  private scanStartTime: number = 0;\n  private currentError: Error | null = null;\n  private detectedQRData: DeviceLinkingQRData | null = null;\n\n  constructor(\n    private options: ScanQRCodeFlowOptions = {},\n    private events: ScanQRCodeFlowEvents = {}\n  ) {\n    this.canvas = document.createElement('canvas');\n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) {\n      throw new Error('Unable to get canvas 2D context');\n    }\n    this.ctx = ctx;\n  }\n\n  /**\n   * Get current flow state\n   */\n  getState(): {\n    state: ScanQRCodeFlowState;\n    isScanning: boolean;\n    scanDuration: number;\n    error: Error | null;\n    qrData: DeviceLinkingQRData | null;\n  } {\n    return {\n      state: this.state,\n      isScanning: this.state === ScanQRCodeFlowState.SCANNING,\n      scanDuration: this.scanStartTime ? Date.now() - this.scanStartTime : 0,\n      error: this.currentError,\n      qrData: this.detectedQRData\n    };\n  }\n\n  /**\n   * Start scanning for QR codes\n   */\n  async startQRScanner(): Promise<void> {\n    if (\n      this.state !== ScanQRCodeFlowState.IDLE &&\n      this.state !== ScanQRCodeFlowState.ERROR &&\n      this.state !== ScanQRCodeFlowState.CANCELLED\n    ) {\n      return; // Already running\n    }\n\n    this.setState(ScanQRCodeFlowState.INITIALIZING);\n    this.currentError = null;\n    this.detectedQRData = null;\n\n    try {\n      // Build camera constraints\n      const constraints = this.buildCameraConstraints();\n\n      // Get camera stream\n      this.mediaStream = await navigator.mediaDevices.getUserMedia(constraints);\n\n      // Create video element if not provided externally\n      if (!this.video) {\n        this.video = document.createElement('video');\n        this.video.playsInline = true;\n        this.video.muted = true;\n      }\n\n      this.video.srcObject = this.mediaStream;\n      await this.video.play();\n\n      // Notify camera is ready\n      this.events.onCameraReady?.(this.mediaStream);\n\n      this.setState(ScanQRCodeFlowState.SCANNING);\n      this.scanStartTime = Date.now();\n\n      // Start progress tracking\n      this.startProgressTracking();\n\n      // Set timeout if specified\n      const timeout = this.options.timeout ?? 60000;\n      if (timeout > 0) {\n        this.timeoutId = setTimeout(() => {\n          this.handleError(new Error(`Camera scan timeout - no QR code detected within ${timeout}ms`));\n        }, timeout);\n      }\n\n      // Start scanning loop\n      this.scanFrame();\n\n    } catch (error: any) {\n      this.handleError(new Error(`Camera access failed: ${error.message}`));\n    }\n  }\n\n  /**\n   * Stop scanning and cleanup resources\n   *\n   * This method stops the scanning process and cleans up all internal resources.\n   * For React contexts with external video elements, use destroy() instead.\n   */\n  stop(): void {\n    this.setState(ScanQRCodeFlowState.CANCELLED);\n    this.cleanup();\n  }\n\n  /**\n   * Attach an external video element (for React contexts)\n   */\n  attachVideoElement(video: HTMLVideoElement): void {\n    this.video = video;\n    if (this.mediaStream && this.state === ScanQRCodeFlowState.SCANNING) {\n      this.video.srcObject = this.mediaStream;\n      this.video.play();\n    }\n  }\n\n  /**\n   * Detach the video element\n   */\n  detachVideoElement(): void {\n    if (this.video) {\n      this.video.srcObject = null;\n    }\n    this.video = null;\n  }\n\n  /**\n   * Switch to a different camera\n   */\n  async switchCamera(cameraId: string): Promise<void> {\n    const wasScanning = this.state === ScanQRCodeFlowState.SCANNING;\n    if (wasScanning) {\n      this.stop();\n    }\n\n    this.options.cameraId = cameraId;\n\n    if (wasScanning) {\n      await this.startQRScanner();\n    }\n  }\n\n  /**\n   * Get available video devices\n   */\n  async getAvailableCameras(): Promise<MediaDeviceInfo[]> {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.filter(device => device.kind === 'videoinput');\n    } catch (error) {\n      console.error('Error enumerating cameras:', error);\n      throw new Error('Failed to access camera devices');\n    }\n  }\n\n  /**\n   * Get the current media stream (for external video elements)\n   */\n  getMediaStream(): MediaStream | null {\n    return this.mediaStream;\n  }\n\n  // Private methods\n\n  private setState(newState: ScanQRCodeFlowState): void {\n    this.state = newState;\n  }\n\n  private buildCameraConstraints(): MediaStreamConstraints {\n    const constraints: MediaStreamConstraints = {\n      video: {\n        deviceId: this.options.cameraId || undefined,\n        width: { ideal: 720, min: 480 },\n        height: { ideal: 720, min: 480 },\n        aspectRatio: { ideal: 1.0 },\n        facingMode: this.options.cameraId ? undefined : this.options.cameraConfigs?.facingMode\n      }\n    };\n\n    // Override with custom width/height if provided\n    if (this.options.cameraConfigs?.width || this.options.cameraConfigs?.height) {\n      const videoConstraints = constraints.video as MediaTrackConstraints;\n      if (this.options.cameraConfigs.width) {\n        videoConstraints.width = { ideal: this.options.cameraConfigs.width, min: 480 };\n      }\n      if (this.options.cameraConfigs.height) {\n        videoConstraints.height = { ideal: this.options.cameraConfigs.height, min: 480 };\n      }\n    }\n\n    return constraints;\n  }\n\n  private startProgressTracking(): void {\n    this.progressIntervalId = setInterval(() => {\n      if (this.state === ScanQRCodeFlowState.SCANNING) {\n        const duration = Date.now() - this.scanStartTime;\n        this.events.onScanProgress?.(duration);\n      }\n    }, 100); // Update every 100ms\n  }\n\n  private async scanFrame(): Promise<void> {\n    if (\n      this.state !== ScanQRCodeFlowState.SCANNING\n      || !this.video\n      || !this.mediaStream\n    ) {\n      return;\n    }\n\n    try {\n      // Check if video is ready\n      if (this.video.readyState === this.video.HAVE_ENOUGH_DATA) {\n        // Draw video frame to canvas\n        this.canvas.width = this.video.videoWidth;\n        this.canvas.height = this.video.videoHeight;\n        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);\n\n        // Scan for QR code\n        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n        const qrData = await this.scanQRFromImageData(imageData);\n\n        if (qrData) {\n          const parsedData = this.parseAndValidateQRData(qrData);\n          this.handleSuccess(parsedData);\n          return;\n        }\n      }\n    } catch (error: any) {\n      // Fail the scan on validation or frame errors\n      this.handleError(error instanceof Error ? error : new Error(String(error)));\n      return;\n    }\n\n    // Schedule next frame\n    if (this.state === ScanQRCodeFlowState.SCANNING) {\n      this.animationId = requestAnimationFrame(() => this.scanFrame());\n    }\n  }\n\n  private async scanQRFromImageData(imageData: ImageData): Promise<string | null> {\n    const { default: jsQR } = await import('jsqr');\n    const code = jsQR(imageData.data, imageData.width, imageData.height, {\n      inversionAttempts: \"dontInvert\"\n    });\n    return code ? code.data : null;\n  }\n\n  private parseAndValidateQRData(qrData: string): DeviceLinkingQRData {\n    let parsedData: DeviceLinkingQRData;\n    try {\n      parsedData = JSON.parse(qrData);\n    } catch {\n      if (qrData.startsWith('http')) {\n        throw new Error('QR code contains a URL, not device linking data');\n      }\n      if (qrData.includes('ed25519:')) {\n        throw new Error('QR code contains a NEAR key, not device linking data');\n      }\n      throw new Error('Invalid QR code format - expected JSON device linking data');\n    }\n\n    // Use the validation function from scanDevice.ts\n    validateDeviceLinkingQRData(parsedData);\n    return parsedData;\n  }\n\n  private handleSuccess(qrData: DeviceLinkingQRData): void {\n    this.setState(ScanQRCodeFlowState.SUCCESS);\n    this.detectedQRData = qrData;\n    this.cleanup();\n    this.events.onQRDetected?.(qrData);\n  }\n\n  private handleError(error: Error): void {\n    this.setState(ScanQRCodeFlowState.ERROR);\n    this.currentError = error;\n    this.cleanup();\n    this.events.onError?.(error);\n  }\n\n  private cleanup(): void {\n    // Stop animation frame\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n\n    // Clear timeout\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n\n    // Stop progress tracking\n    if (this.progressIntervalId) {\n      clearInterval(this.progressIntervalId);\n      this.progressIntervalId = null;\n    }\n\n    // MediaStream Cleanup: Stop all tracks and clear all video references\n    // This ensures camera light turns off regardless of how the video element is managed\n    if (this.mediaStream) {\n      this.mediaStream.getTracks().forEach(track => track.stop());\n      this.mediaStream = null;\n    }\n\n    // Clear all video sources to ensure no lingering MediaStream references\n    if (this.video) {\n      this.video.srcObject = null;\n    }\n  }\n}\n\n// ===========================\n// CONVENIENCE FUNCTIONS\n// ===========================\n\n/**\n * Scan QR code from file with lazy loading\n */\nexport async function scanQRCodeFromFile(file: File): Promise<DeviceLinkingQRData> {\n  // Setup canvas\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  if (!ctx) throw createQRError('Unable to get canvas 2D context');\n\n  // Load and process image\n  const dataUrl = await new Promise<string>((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      if (e.target?.result) {\n        resolve(e.target.result as string);\n      } else {\n        reject(createQRError('Failed to read file'));\n      }\n    };\n    reader.onerror = () => reject(createQRError('Failed to read file'));\n    reader.readAsDataURL(file);\n  });\n\n  // Process image\n  const img = await new Promise<HTMLImageElement>((resolve, reject) => {\n    const image = new Image();\n    image.onload = () => resolve(image);\n    image.onerror = () => reject(createQRError('Failed to load image file'));\n    image.src = dataUrl;\n  });\n\n  // Scan QR code using shared logic\n  canvas.width = img.width;\n  canvas.height = img.height;\n  ctx.drawImage(img, 0, 0);\n\n  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n  const qrData = await scanQRFromImageData(imageData);\n\n  if (!qrData) {\n    throw createQRError('No QR code found in image');\n  }\n\n  return parseAndValidateQRData(qrData);\n}\n\n// ===========================\n// UTILITY FUNCTIONS\n// ===========================\n\n/**\n * Enumerate available video input devices\n */\nexport async function enumerateVideoDevices(): Promise<MediaDeviceInfo[]> {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    return devices.filter(device => device.kind === 'videoinput');\n  } catch (error) {\n    console.error('Error enumerating cameras:', error);\n    throw new Error('Failed to access camera devices');\n  }\n}\n\n/**\n * Detect if a camera is front-facing based on its label\n */\nexport function detectFrontCamera(camera: MediaDeviceInfo): boolean {\n  const label = camera.label.toLowerCase();\n  return label.includes('front') ||\n         label.includes('user') ||\n         label.includes('selfie') ||\n         label.includes('facetime') ||\n         label.includes('facing front');\n}\n\n/**\n * Detect camera facing mode from media stream settings\n */\nexport function detectCameraFacingMode(stream: MediaStream): boolean {\n  const videoTrack = stream.getVideoTracks()[0];\n  if (videoTrack) {\n    const settings = videoTrack.getSettings();\n    return settings.facingMode === 'user';\n  }\n  return false;\n}\n\n// ===========================\n// PRIVATE HELPER FUNCTIONS\n// ===========================\n\nasync function scanQRFromImageData(imageData: ImageData): Promise<string | null> {\n  const { default: jsQR } = await import('jsqr');\n  const code = jsQR(imageData.data, imageData.width, imageData.height, {\n    inversionAttempts: \"dontInvert\"\n  });\n  return code ? code.data : null;\n}\n\nfunction parseAndValidateQRData(qrData: string): DeviceLinkingQRData {\n  let parsedData: DeviceLinkingQRData;\n  try {\n    parsedData = JSON.parse(qrData);\n  } catch {\n    if (qrData.startsWith('http')) {\n      throw new Error('QR code contains a URL, not device linking data');\n    }\n    if (qrData.includes('ed25519:')) {\n      throw new Error('QR code contains a NEAR key, not device linking data');\n    }\n    throw new Error('Invalid QR code format - expected JSON device linking data');\n  }\n\n  // Use the validation function from scanDevice.ts\n  validateDeviceLinkingQRData(parsedData);\n  return parsedData;\n}\n\nfunction createQRError(message: string): DeviceLinkingError {\n  return new DeviceLinkingError(message, DeviceLinkingErrorCode.INVALID_QR_DATA, 'authorization');\n}"],"mappings":"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"}